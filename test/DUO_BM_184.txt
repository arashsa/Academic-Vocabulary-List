  
UNIVERSITETET I OSLO 
Institutt for informatikk 
 
 
 
 
 
 
Løsninger for feiltoleranse i 
systemer med mobile agenter 
 
 
 
 
Masteroppgave 
 
 
 
 
Eirik Broen 
 
 
 
31.01.2006 
  
 
 
     
 ii 
 
 
 
 
 
Forord 
 
Denne oppgaven er skrevet for graden master i informatikk ved Universitetet i Oslo. 
Oppgaven ble skrevet i tidsrommet mellom 1. Januar 2004 og 31. Januar 2005. 
 
Denne oppgaven har blitt til gjennom en lang og lærerik prosess. Jeg er glad for at jeg 
fikk muligheten til å gjøre denne erfaringen.  
 
Jeg vil gjerne benytte anledningen til å takke min veileder Steinar Kristoffersen for god 
hjelp underveis.  
 
Jeg vil også takke min samboer Marit for hennes uforbeholdne støtte og oppmuntring. 
Uten deg hadde ikke dette vært mulig. 
     
 iii 
 
Sammendrag 
 
Denne oppgaven undersøker muligheten for å lage en sikringsmekanisme for retur av 
resultater fra en mobil agent.  
 
Konteksten for bruk av et agentsystem er kjøp, salg og dynamisk prising av flybilletter. 
Oppgaven tar for seg bruken av agentsystem i forbindelse med innhenting av tilbud på 
flybilletter. Målsetningen for denne undersøkelsen har vært å utarbeide et forslag til en 
generell løsning for hvordan man kan sikre at en mobil agent returnerer sine resultater til 
en mobil klient som ikke er tilgjengelig over et internettverk. 
 
Oppgaven tar for seg teoretisk bakgrunn for bruk av agentsystemer og ser på løsninger 
for feilsikring i systemer som gjør bruk av mobile agenter. Den inneholder en 
klassifikasjon av publiserte løsninger for frakoblet operasjon. 
 
I forbindelse med denne oppgaven har det blitt laget et testsystem som illustrerer 
prinsippene bak sikringsmekanismen. Testsystemet er implementert i rammeverket 
JADE.  
   
     
 iv 
 
INNHOLD 
 
1 INNLEDNING                   1 
 
1.1 Problemstilling …………………………………………………………  2 
1.2 Metode ………………………………………………………………….  2 
1.3 Sammendrag ……………………………………………………………  3 
1.4 Struktur av oppgave …………………………………………………….  3 
 
2 KONTEKST         4 
 
2.1 Motivasjon for dynamisk prising ……………………………………… 5 
2.2 Marked ………………………………………………………………… 6 
2.3 Strategier for prising …………………………………………………... 6 
2.4 Produktkarakteristikk …………………………………………………. 7 
2.5 Prinsipper for dynamisk prising ………………………………………. 9 
2.6 Algoritmer for dynamisk prising …………………………………….... 10 
2.7 Agenter i relasjon til dynamisk prising ………………………………... 12 
 
3. TEORI          13   
 
3.1 Agent …………………………………………………………………… 13  
3.1.1 Definisjon av agentsystem ………………………………………… 13 
3.1.2 Karakteristikker ved en agent ……………………………………... 13 
3.1.3 Handlingsmønster ………………………………………………..... 14     
3.1.4 Agent interaksjon ………………………………………………….. 16 
3.1.5 Agent kommunikasjon …………………………………………….. 16  
3.1.6 Utvikling av agentsystem ………………………………………….. 18 
3.1.7 Motivasjon for agentsystemer ……………………………………... 18 
3.1.8 Fra objekt til agent …………………………………………………. 19 
3.1.9 Arv fra kunstig intelligens …………………………………………. 19 
3.1.10 Arv fra Objektorientert analyse …………………………………... 20 
3.1.11 Typer Agentsystem ………………………………………………. 20 
3.1.11.1 Statiske agenter ………………………………………………. 20 
3.1.11.2 Mobile agenter ……………………………………………….. 21  
3.1.11.3 Enkeltagent og fleragentsystemer (MAS) ……………………. 21 
3.1.12 Rammeverk og standardisering …………………………………… 22 
3.1.12.1 FIPA MAS infrastruktur ……………………………………… 23 
3.1.12.1.1 Agent …………………………………………………….. 24 
3.1.12.1.2 Directory facilitator ……………………………………… 24 
3.1.12.1.3 Agent management system ………………………………. 24 
3.1.12.1.4 Message Transport system ………………………………. 25 
3.1.12.2 JADE ………………………………………………………. 25 
3.1.12.2.1 JADE - Agent plattform …………………………………. 25 
3.1.12.2.2 JADE - Agent modell ……………………………………. 26 
     
 v 
3.1.12.2.3 JADE – kjernetjenester ………………………………….. 26 
3.2 Ontologi ………………………………………………………………… 27 
3.2.1 Definisjon …………………………………………………………... 27 
3.2.2 Motivasjon for bruk av ontologier ………………………………. 28 
3.2.3 Bruk av ontologi ………………………………………………… 29 
3.2.3.1 Bruk i agentsystem ………………………………………….. 29 
3.2.3.2 Semantisk nettverk ………………………………………….. 30 
3.2.3.2.1 RDF …………………………………………………….. 30 
3.2.3.2.2 DAML / OIL ……………………………………………. 31 
3.3 Routing ………………………………………………………………….. 32 
3.3.1 Definisjon …………………………………………………………... 32 
3.3.2 Historie ……………………………………………………………... 33 
3.3.3 Definisjon av begreper ……………………………………………... 33 
3.3.3.1 Node …………………………………………………………… 33 
3.3.3.2 Hop ……………………………………………………………. 34 
3.3.4 TCP / IP ……………………………………………………………. 35 
3.3.4.1 Beskrivelse av protokoll ………………………………………. 35 
3.3.4.2 IPv4 ……………………………………………………………. 36  
3.3.4.2.1 Mangler ved IPv4 …………………………………………. 36 
3.3.4.2.2 Metoder for å øke adresserom (NAT) …………………….. 37 
3.3.4.2 IPv6 / IPnG ………………………………………………….. 37 
3.3.4.3 IP og mobile enheter ………………………………………… 38 
3.3.4.3.1 GPRS / EDGE …………………………………………... 38 
3.3.4.3.2 UMTS ………………………………………………… 39 
3.3.4.4 Mobile IP ……………………………………………………. 39 
3.3.4.5 To primære oppgaver innen routing ………………………… 40 
3.3.4.5.1 Optimal rute …………………………………………….. 40 
3.3.4.5.2 Packet switching ………………………………………... 41 
3.3.4.6 Lokalisering av agenter i MAS ……………………………… 42 
3.4 Mobilitet ………………………………………………………………… 43  
3.4.1 Typer mobilitet ……………………………………………………... 43 
3.4.1.1 Terminalmobilitet ……………………………………………… 44 
3.4.1.1.1 Lokasjonskontroll ……………………………………………. 45 
3.4.1.1.2 Avleveringskontroll ………………………………………….. 45 
3.4.2 Løsninger for terminalmobilitet ……………………………………. 45 
3.4.2.1 Mobile IP ……………………………………………………..... 46 
3.4.2.1.1 Svakheter ved Mobile IP …………………………………….. 48 
3.4.2.1.2: Utvidelser, oppdatering av Mobile IP ………………………. 49 
3.4.2.1.2.1 HAWAII ………………………………………………… 49 
3.4.2.1.2.2 CellularIP ………………………………………………... 50 
3.4.2.1.2.3 Andre løsninger …………………………………………. 51 
3.4.3 Kodemobilitet ……………………………………………………..... 51 
3.4.3.1 Sterk mobilitet …………………………………………………. 51 
3.4.3.2 Svak mobilitet …………………………………………………. 52 
3.4.3.3 Klassifisering av løsninger for kodemobilitet …………………. 53 
3.4.3.3.1 Plattformbasert ……………………………………………. 53 
     
 vi 
3.4.3.3.2 Integrert …………………………………………………… 54 
3.4.3.3.3 Ekstern …………………………………………………….. 55 
3.4.3.4 Kodemobiliet i agentsystem …………………………………… 56 
3.4.4 FIPA mobility ………………………………………………………. 57  
3.4.4.1 Livssyklus …………………………………………………….... 57 
3.4.4.2 Protokoll ……………………………………………………….. 57 
3.4.5 Mobilitetsontologi ………………………………………………….. 58 
 
 
4 BESKRIVELSE AV LØSNINGSFORSLAG     59 
  
 
4.1 Målsetning ………………………………………………………………  59 
4.2 Avgrensning ……………………………………………………………. 59 
4.3 Valg av teknologi ………………………………………………………. 60 
4.3.1 agentplattform ……………………………………………………… 60 
4.4 Kravspesifikasjon ………………………………………………………. 61 
4.5 Use-case diagram ………………………………………………………. 62 
4.6 Aktørbeskrivelser ………………………………………………………. 62 
4.6.1 Mobil klient / Sluttbruker ………………………………………….. 62 
4.6.2 UIAgent ……………………………………………………………. 63  
4.6.3 BuyerAgent ………………………………………………………… 63  
4.6.4 TravelAgent ………………………………………………………... 63 
4.6.5 StorageAgent ………………………………………………………. 64 
4.7 Komponentdiagram ……………………………………………………. 64 
4.8 Komponent beskrivelse ………………………………………………… 65 
4.8.1 UIAgent ……………………………………………………………. 65 
4.8.2 BuyerAgent ………………………………………………………… 66 
4.8.3 TravelAgent ………………………………………………………... 68 
4.8.4 StorageAgent ………………………………………………………. 69 
4.8.5 PingResponder …………………………………………………….. 70 
4.8.6 Itinerary ……………………………………………………………. 70 
4.9 Sekvensdiagram ………………………………………………………… 71 
4.10 Kommentar til agentarkitektur ………………………………………… 72 
 
5 RESULTATER 
 
5.1 Generell løsning ……………………………………………………….... 73  
5.2 Testing ………………………………………………………………….. 74 
5.3 Test av skalerbarhet …………………………………………………….. 80 
 
6 DISKUSJON         82 
  
6.1 Tidligere arbeider ……………………………………………………….. 82  
6.1.1 Avgrensning …………………………………………………………... 82 
6.1.2 Klassifisering …………………………………………………………. 82 
     
 vii 
6.1.2.1 Sentral lagring / docking …………………………………………. 82 
6.1.2.2 Replikasjon / delegasjon …………………………………………. 83 
6.1.2.3 Resultatorientert ………………………………………………….. 84  
6.1.2.4 Klientinitiert retur ………………………………………………… 84 
6.1.3 Kriterium for klassifisering ………………………………………….... 84 
6.1.3.1 Statisk node ………………………………………………………. 85  
6.1.3.2 Sikkerhet …………………………………………………………. 85 
6.1.3.3 Eksterne Ressurser ……………………………………………….. 85 
6.1.3.4 Autonomi ………………………………………………………… 85 
6.1.3.5 Garanti …………………………………………………………… 85 
6.2 Gjennomgang av løsningstyper ………………………………………… 86 
6.2.1 Sentral lagring / docking …………………………………………… 86 
6.2.2 Replikasjon / delegasjon …………………………………………… 88 
6.2.3 Resultatorientert ……………………………………………………. 90 
6.2.4 Klientinitiert retur …………………………………………………... 92 
 
7 KONKLUSJON         95 
 
7.1 Problemer med agentsystem ……………………………………………. 95 
7.2 Løsningsforslag for resultatsikring ……………………………………... 95 
7.3 Hva har jeg lært ……………………………………………………........ 96 
7.4: Erfaring med bruk av JADE ………………………………………….... 96 
7.5 Fremtidig arbeid ……………………………………………………….... 97 
 
LITTERATUR LISTE         99 
ORDLISTE          107 
 
APPENDIX A – Kildekode         
      
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
     
 viii 
 
 
 
 
 
 
 
 
     
 1 
 
1 INNLEDNING 
 
I denne oppgaven undersøker jeg mulighetene for å utvikle en løsning med feiltoleranse i 
forhold til mobile agenter som skal returnere til mobile terminaler. Jeg undersøker denne 
problemstillingen i forbindelse med utviklingen et agentsystem for selgere og kjøpere av 
flybilletter. Bakgrunnen for valget av bransje er fremveksten av såkalt dynamisk prising 
av flybilletter. Dette scenario vil være bakgrunnen og motivasjonen for å utvikle et 
testsystem med selger og kjøpere av flybilletter. Mer spesifikt ser jeg på mulighetene for 
å utvikle en mobil agent som kan hente informasjon om flybilletter basert på parametere 
satt av en kunde. Denne agenten skal kunne forflytte seg til de ulike tilbyderne av 
flybilletter og på veiene av en kunde få tilbud som samsvarer med kunden sine 
reiseplaner. En viktig del av systemet er å sikre at agenten returnerer med et resultat til 
brukeren.   
 
Bruken av dynamisk prising innen flyindustrien er ingen ny foreteelse. Det har for 
eksempel i flere år vært vanlig å selge tur – retur billetter til en rimeligere stykkpris enn 
en enkelttur. Selger opererer ikke med en fast pris på en flytur, men bruker i stedet ulike 
faktorer knyttet til reisen og den reisende for å sette en endelig pris. Selger blir mer 
sofistikert og benytter seg av algoritmer og strategier for å maksimere profitt. Pris og 
service er gjenstand for forhandling og flyindustrien er en bransje hvor det i de siste årene 
har kommet til flere aktører slik at det kan være tidkrevende for en kjøper å få ett 
fullstendig bilde av tilbud. Det har det også kommet til flere typer mellomledd utenom de 
tradisjonelle reisebyråene. Herunder kan nevnes nettsteder som sammenligner priser og 
hjelper sine kunder med å sette sammen reiser. 
 
Jeg mener det eksisterer en åpning for bruk av ulike typer agentteknologi på både selger 
og kjøpersiden i forhold til kjøp og salg av flybilletter. I forhold til kjøperen vil bruk av 
agenter kunne gi kunden et fortrinn ved å gi denne et bedre overblikk over markedet og 
muligheten til forhandle med ulike selgere for å oppnå best mulig pris. For eksempel kan 
det være mulig for en kunde å la sin kjøperagent være med i en type auksjon for billetter.  
 
Agentsystemer representerer en arkitektur for distribuerte systemer som er relativt ny og 
som ser ut til å øke i popularitet. Agentsystemer representerer en ny måte å designe og 
implementere komplekse system på. Agentsystemer har flere fordeler sett i forhold til den 
rådende klient – tjener arkitekturen. En av disse fordelene er at et distribuert agentsystem 
kan hjelpe til å redusere nettverkstrafikk. En annen fordel er at agenter kan utføre 
oppgaver på veiene av en bruker og dermed lette arbeidsbyrden for denne brukeren. 
Agenten representerer et nivå av abstraksjon som kan gjøre det mulig for brukere med 
liten teknisk kunnskap å gjøre bruk av komplekse systemer. I forbindelse med 
utviklingen av en meningsbærende nettverksstruktur slik som semantiske nett kan 
autonome agenter støtte en bruker i for eksempel innsamling av informasjon.  
 
Agentsystemer er ennå ikke en helt moden teknologi og har flere problemer som må 
løses. Herunder kan nevnes sikkerhetsaspektet ved agentsystemer. Problemer med 
sikkerhet er spesielt knyttet til systemer med mobile agenter. I disse systemene er det 
     
 2 
både fare for at agenten kan utgjøre en sikkerhetsrisiko og at andre kan utgjøre en risiko 
for agenten. Standardisering av kommunikasjon mellom agenter og interaksjon mellom 
ulike agentplattformer er også et område det kreves mer forskning på. Et annet 
problemområde er sikringen av mobile agenter i forhold til at disse utfører transaksjoner 
på veiene av brukere. For eksempel transaksjoner som involverer reservasjon av billetter 
må helt fullføres eller ikke utføres i det hele tatt. Det er også behov for å sikre at mobile 
agenter utfører sitt oppdrag og returnerer til sitt utgangspunkt eller formidler sine 
resultater til en bruker på en veldefinert måte. 
 
1.1 Problemstilling 
 
Den konkrete problemstillingen i denne oppgaven er å undersøke mulighetene for å 
implementere en sikkerhetsmekanisme i forhold til retur av resultatene til en mobil agent. 
Jeg har tatt sikte på å komme frem til en generell løsning for å garantere at resultater fra 
en mobil agent ikke blir tapt på grunn av nettverksproblemer. Jeg mener dette er en viktig 
faktor i forhold til brukeraksept av agentsystemer. Jeg mener også at dette er en aktuell 
problemstilling sett på bakgrunn av overgangen til stadig mindre og mer mobile 
terminaler med nettverkstilgang. Eksempler på slike terminaler er mobiltelefoner og 
bærbare datamaskiner med trådløs nettverkstilkobling. Slike terminaler kan ikke alltid 
forventes å ha tilkobling til et internettverk til enhver tid. Følgelig eksisterter det et behov 
for teknologi som tillatter at de kan utføre oppgaver som involverer nettverkstilgang selv 
om de er frakoblede. Agenter er en mulig løsning for slik asynkron operasjon. Det er etter 
min mening en forutsetning at brukeren kan være sikker på at resultatene av slike 
operasjoner returneres tilbake til den mobile terminalen.  
 
 
1. 2 Metode 
 
Målet med denne oppgaven er å undersøke mulighetene for å implementere en 
sikringsmekanisme for retur av resultater fra mobile agenter. Metoden jeg vil benytte 
meg av for å nå dette målet er todelt: 
 
1:  
Litteraturgjennomgang som tar sikte på å undersøke andre løsninger for 
feilsikring for mobile agenter. Jeg har i denne gjennomgangen forsøkt å finne 
løsninger som direkte tar opp problemstillingen med mobile agenter som ikke kan 
returnere til sitt utgangspunkt. Jeg har også sett på løsninger forbundet med 
generell feilsikring av mobile agenter og sett på disse i lys av sikring av resultater 
for en mobil agent.  
 
2:  
Praktisk arbeid i form av et forslag til hvordan jeg mener dette problemet kan 
løses. I den forbindelse har jeg bygget et testsystem for å illustrere min løsning. 
Denne løsningen har blitt skrevet i Java og benyttet agentrammeverket JADE som 
basis for agentsystemet. Testsystemet har blitt testet på en samling heterogene 
noder med varierende antall agenter for å undersøke hvordan løsningen fungerer. 
     
 3 
 
1.3 Resultater 
 
Denne oppgaven tar for seg løsninger for sikring av resultater for mobile agenter. Den ser 
på eksisterende løsninger for feilsikring for mobile agenter og transaksjonsorienterte 
agenter. En generell løsning på problemet med en mobil agent som ikke kan vende 
tilbake til sitt utgangspunkt er presentert. Løsningen baserer seg i hovedsak på bruk av en 
sentral lagringsplass og en persistensmekanisme for mobile agenter. Jeg har tatt i bruk 
elementer fra tidligere publiserte løsninger for feilsikring for mobile agenter. Spesifikt 
benytter mitt forslag en reiseplan med funksjonalitet for å lagre lokasjoner knyttet til 
agenter som tilbyr en ønsket tjeneste og lokasjonen til en sentral lagringsplass. Denne 
løsningen skiller seg fra tidligere publiserte løsninger ved at den benytter seg en agent 
som implementerer en enkel protokoll for å teste om en node er tilgjengelig. 
Bruksområdet for dette løsningsforslaget er hovedsakelig mobile agenter som utfører en 
oppgave på veiene av en bruker. Eksempel på slik bruk er innsamling av informasjon og 
kjøp eller salg av produkter. 
 
1.4 Struktur av oppgave 
 
Oppgaven vil være strukturert på følgende måte: 
 
• Bakgrunn 
 
Her vil jeg gi en kort gjennomgang av bakgrunnen og bruk av mobile agenter i 
forbindelse med kjøp og salg av flybilletter. Denne gjennomgangen vil fokusere 
på bruk og prinsipper for dynamisk prising med vekt på forhold relatert til 
flyindustrien. Jeg vil også komme inn på dynamisk prising i forhold til bruk av 
agenter. Denne gjennomgangen er ment å fungere som en kontekst jeg vil referere 
til i resten av oppgaven. 
 
• Teoretisk grunnlag 
 
Jeg vil i dette kapitlet gjøre rede for det teoretiske grunnlaget for min oppgave. 
Her vil jeg spesielt ta for meg tre begreper:   
  
• Agenter 
 
• Routing 
 
• Mobilitet 
 
• Beskrivelse av forslag til løsning 
 
Jeg vil i dette kapitlet beskrive mitt forslag til en løsning. Hovedvekten i dette 
kapitlet vil være en designbeskrivelse av mitt testsystem.  
 
     
 4 
• Resultater 
 
Dette kapitlet vil ta for seg resultatene av mitt forsøk på å lage en generell løsning 
for sikring av retur av resultater for en mobil agent. Her vil kjøring av 
testsystemet beskrives. I den forbindelse vil jeg også komme inn på testsituasjon 
og oppsett for testing. 
 
• Diskusjon 
 
I diskusjonen vil jeg gå gjennom litteratur som omhandler mulige løsninger for 
retur av mobile agenter. Jeg vil presentere en klassifikasjon av ulike løsninger og 
sammenligne løsningene basert på 5 kriterium. Jeg vil så presentasjonen hver av 
gruppene med løsninger og vil i den forbindelse ta opp sterke og svake sider med 
hver av typene. 
  
• Konklusjon 
 
Konklusjonen vil ta for seg mine erfaringer med arbeidet med denne oppgaven. 
Jeg vil her oppsummere mine funn og se på hva slags praktisk anvendelse min 
løsning kan ha. Jeg vil også komme inn på forslag til fremtidig arbeid. 
 
 
2 KONTEKST 
 
Internett har endret både måten kjøpere velger hvilke selgere de vil kjøpe produkter av og 
måten selgere finner sine kjøpere i markedet. En konsekvens av den økte bruken 
elektroniske markeder er fremveksten av ulike strategier for dynamisk prising av 
produkter. Dynamisk prising kan formelt defineres som kjøp og salg av varer i et marked 
hvor pris er en flytende størrelse som reguleres etter tilbud og etterspørsel.  
 
Jeg vil i dette kapitlet se på prinsipper og algoritmer for å kalkulere priser og trender 
innenfor dynamisk prising og andre salgsstrategier. Hvordan dynamisk prising har 
utviklet seg og implikasjoner for kjøpere og selger samt påvirking av selve markedet. Jeg 
vil også se kort på ulike forsøk på å simulere ett marked med ulik kjøper og selger atferd. 
Hvilke produktkategorier som egner seg for dynamisk prising og hvilke som er 
vanskelige å selge ved bruk av slike prisstrategier. Videre følger en kort drøfting av 
automatiserte systemer og agenter i forhold til utviklingen av dynamisk prising og hvilke 
følger disse systemene har hatt for ulike bransjer og selskapers forretningsmodeller. Jeg 
vil hovedsaklig se på dynamisk prising i forhold til selgeren, men også komme inn på 
strategier som brukes av kjøpere og deres reaksjon på bruk av dynamiske priser. I forhold 
til selgere vil jeg se på deres muligheter til å analysere markedet i lys av elektronisk 
handel og deres strategier for å maksimere profitt og markedsandel. Her vil jeg komme 
inn på hvordan utstrakt bruk av dynamisk prising har påvirket salgsstrategier både innen 
markeder med kun en selger som har monopol og markeder hvor flere selgere 
konkurrerer om de samme markedsandelene. Jeg vil bruke eksempler fra andre bransjer, 
men konsentrere meg om flyindustrien. I den forbindelsen vil jeg kort oppsummere bruk 
     
 5 
av prismodeller og forskjellige strategier for å selge billetter og fylle flyseter. Jeg også 
komme inn på yield management og operasjons modellering.  
 
Har forbrukere endret sin kjøperatferd og i hvor stor grad benytter forbrukere seg av den 
store informasjonsmengden de har tilgang til for å bestemme seg hvilket produkt de skal 
kjøpe? Jeg vil forsøke å undersøke hvordan ulike selskaper forsøker å profilere seg og 
tiltrekke seg ulike segment av kjøpere ved å tilby ulike tillegg til et basisprodukt. 
 
Dette kapitlet er men å gi en kontekst for bruken av agenter til kjøp og salg av flybilletter. 
  
2.1 Motivasjon for dynamisk prising 
 
Selgere har gjennom alle tider forsøkt å utvikle strategier for å få høyest mulig profitt på 
produktene eller tjenestene de tilbyr. Mange forskjellige strategier har blitt utprøvd. Det 
har vært og er fortsatt stor variasjon i hvordan selskaper velger å profilere seg og 
markedsføre sine varer innenfor det samme markedssegmentet. Noen velger å 
spesialisere seg og søker en liten gruppe av potensielt kjøpesterke kunder i ett marked, 
andre velger å satse på å selge i stort volum og kapre så stor andel av markedet som 
mulig. Det som er felles for de selgende aktørene i ett marked er ønsket om å nå ut til sine 
potensielle kunder på en effektiv måte og selge sine produkter til den maksimale pris som 
markedet kan godta. Å nå ut til markedet har vært ett av de store problemene for mange 
selskaper da dette gjerne medfører store investeringer i form av markedsføring og 
distribusjon. 
 
Internett har ført til at det er mulig for mange flere aktører å nå ut til ett bredere 
kundegrunnlag. Kostnadene for å sette opp en webside eller butikk er ofte lave i forhold 
til å sette opp en fysisk butikk og kundepotensialet kan være stort. Introduksjonen av 
ulike mellomledd på Internett, såkalte infomediearies, som beskrevet av Grover og Teng 
[1] har gjort det lettere for små aktører å nå ut til et større marked. Disse mellomleddene 
formidler kontakt mellom potensielle kjøpere og tilbydere på Internet. Slike selskaper 
opererer typisk ved å sammenligne priser eller videreselger produkter fra flere selgere og 
gjør det mulig for relativt små selskaper å konkurrere med større og mer etablerte aktører. 
 
Det er også enklere og mer kostnadseffektivt å endre priser i ett elektronisk marked. 
Isteden for å fysisk oppdatere prislapper eller reklamemateriell kan priser nå endres raskt 
og på en automatisert måte. Agenter er en teknologi som kan benyttes for å utføre slike 
beregninger og/eller endringer av priser.    
 
Pris har alltid vært et viktig redskap for å selge produkter. Den aktøren som kan tilby den 
laveste prisen for ett produkt vil ofte sitte igjen med det største overskuddet. Dette er dog 
ingen fast regel da flere faktorer spiller inn på kunders valg av tilbyder.      
 
 
 
 
 
     
 6 
2.2 Marked 
 
Ett grunnleggende begrep innenfor økonomi er markedet. Ifølge Bakos [2] har alle 
markeder tre hovedfunksjoner: 
 
- Å koble kjøpere og selgere 
 
- Å legge til rette for utveksling av informasjon, produkter, tjenester og betalinger 
assosiert ved transaksjoner. 
 
- Å tilby et institusjonelt rammeverk som lover og reguleringer slik at markedet 
fungerer på en effektiv måte. 
 
Ett marked er i balanse når forholdet mellom tilbud og etterspørsel etter en vare er 
tilnærmet like. De fleste markeder er ikke i slik balanse og ofte finnes det enten ett 
overskudd på tilbydersiden eller en høyere etterspørsel enn det finnes tilgjengelige varer. 
Selskaper bruker markedet til å selge varene sine ved å finne kunder, men også til å forstå 
hvor stor etterspørsel det er etter ett bestemt produkt og hva kundene er villige til å betale 
for dette produktet. I denne sammenhengen blir informasjonsteknologi mye brukt for å 
skaffe seg ett konkurransefortrinn, dette gjelder både for tradisjonelle og elektroniske 
markeder. Informasjonen om etterspørselen i markedet brukes så av selskapene for å 
bestemme mengde produkter de vil tilby, når de vil tilby produktene og pris for 
produktet. En nøkkelfunksjon er her å finne ut hvilken pris markedet er villig til å betale. 
 
2.3 Strategier for prising 
 
For å estimere pris markedet er villige til å betale finnes det ulike strategier. En strategi 
en tilbyder kan ta i bruk er å følge med på hva konkurrentene gjør, vel å merke hvis dette 
er et marked med flere aktører. I elektroniske markeder som på Internett kan en aktør for 
eksempel bruke en automatisert agent for å regelmessig sjekke konkurrentenes priser og 
oppdatere sine egne priser slik at man hele tiden kan tilby den laveste prisen. Dette er en 
viss forenkling av emnet da det er en lang rekke andre faktorer som spiller inn på om det 
er gunstig for et selskap å senke prisen eller ikke. En innlysende faktor er den marginale 
prisen, altså den prisen som selskapet må ha for å dekke sine egne kostnader. Det kan 
finnes situasjoner hvor det er ønskelig å tilby ett produkt til under marginalprisen. Dette 
gjelder spesielt for produkter som har en begrenset varighet. Flybilletter og matvarer er 
eksempler på slike produkter hvor produktet blir verdiløst etter en viss dato.  
 
Andre strategier som kan brukes for å estimere etterspørselen i markedet er 
spørreundersøkelser, fokusgrupper og auksjoner. Auksjoner av ulik type er også en mye 
brukt måte både å estimere etterspørsel og forventet prisnivå på. I følge Appell et al. [3] 
brukes det hovedsaklig tre hovedtyper auksjoner; den engelske auksjon, den nederlandske 
auksjon og revers auksjon. I den engelske varianten starter prisen lavt og kjøperne byr 
over hverandre for å vinne budet. I den nederlandske varianten starter budet høyt og går 
nedover til en kjøper godtar summen. I reverserte auksjoner legger kunder eller 
mellomledd ut produkter de ønsker å kjøpe og så konkurrerer selgere om å tilby den beste 
     
 7 
prisen for produktene. Denne modellen er brukt i forhold til flybilletter av priceline.com 
som har en ”name-your-own-price” mekanisme som lar en kjøper legge inn den prisen 
han er villig til å betale. Deretter gjør priceline.com en dynamisk prisberegning basert på 
hvilken pris de kan få av flyselskapene og tilbyr kunden flere alternativ. Det skal her 
nevnes at priceline.com ikke opererer som noen direkte auksjon da de kjøper billetter av 
flyselskapene til en redusert pris og selger de videre med profitt. 
 
Reverserte auksjoner kan være en effektiv måte for selskaper å innhente informasjon om 
pris. Ved å gjennomføre enten begrensede auksjoner eller reverserte auksjoner kan 
selskapet på en kostnadseffektiv og rask måte undersøke hvilken pris markedet er villige 
til å betale.   
 
For å undersøke effekten av ulike strategier for dynamisk prising har det blitt utvikler 
flere markedssimulatorer [4][5][6]. Morris et al. har implementert to ulike simulatorer: 
Sardine som er en auksjonssimulator og The Learning Curve simulator som modellerer 
markeds scenarioer.  
 
2.4 Produktkarakteristikk 
 
Dynamisk prising og relaterte strategier har vært i bruk i flyindustrien og hotellnæringen i 
mange år. I disse markedene har bruken av dynamisk prising vist seg å være en stor 
suksess og ført til økning av profittmarginen for mange selskaper. Allikevel er det ikke 
sikkert at dynamisk prising fungerer like bra i alle markeder. 
  
Jayaraman og Baker [7] lister noen karakteristikker for produkter som egner seg for 
dynamisk prising. 
 
• Produktet kan ikke lagres, eventuelt at tap av potensielle inntekter inntrer hvis 
produktene ikke blir solgt innen en gitt tidsperiode. 
  
• Produktet kan klassifiseres og prises forskjellig. Det finnes en mulighet for å 
prise det samme produktet forskjellig for ulike markedssegmenter eller tilby 
ulike produktpakker. Flybilletter tilbys gjerne med ulike muligheter for 
kansellering, tidsbegrensing og tilleggsytelser som bedre mat eller større sete. 
 
• Sentralisert ordre prosessering. Ved å sammenstille informasjon om alle salg 
kan selskapene beregne total etterspørsel og hvilke produktpakker som selger 
best. 
 
• Høy verdiforskjell mellom inkrementell kostnad og inkrementell inntekt. Hvis 
produktet brukes er kostnadene assosiert med bruk lave i forhold til 
inntektene. Selskaper benytter seg av strategier for å finne en balanse mellom 
full dekning og høyest mulig pris for å øke sin profittmargin. 
 
     
 8 
• Midlertidige økninger og fall i etterspørselen etter ett produkt. I forhold til 
flyselskapene kan dette likestilles med høy og lavsesonger samt 
enkelthendelser som fører til økt eller senket etterspørsel etter flyreiser.      
 
Flybilletter har flere av disse karakteristikkene. For det første kan ikke produktet lagres. 
Hvis en billett til en flytur ikke er solgt før datoen som flyet går blir billetten verdiløs for 
selskapet. For flyindustrien er det ofte mer ønskelig å fylle opp ett fly selv om de må 
selge noen seter med tap da den inkrementelle økningen av utgifter ved å fylle disse 
setene ikke er spesielt høy i forhold til de faste kostnadene assosiert med en flytur. Disse 
faste kostnadene er relativt høye for flyindustrien da det trengs mye drivstoff, leie av 
flyplasstid, personell, vedlikehold og så videre for å gjennomføre en flyreise. Ved å selge 
de gjenværende setene til tapspris får flyselskapet dekket inn mer av sine faste kostnader 
enn om plassene stod tomme. I flyindustrien og reiseindustrien generelt blir dette referert 
til som dekningsgrad. Det er imidlertid en fin balanse mellom å dekke inn utgifter med 
billige billetter og å selge for mange billige billetter slik at selskapet går glipp av 
fortjeneste de kunne ha fått ved å selge billettene til fullpris. Flyindustrien har vært 
pionerer på å implementere systemer for å forutsi fremtidig etterspørsel, antall 
avbestillinger og akseptabel pris. 
 
Det eksisterer også et veletablert system for å prise flybilletter forskjellig for ulike 
kundegrupper. I hver sin ende av dette spektrumet finner vi forretningsreisende som vil 
ha mye service og høy fleksibilitet og i den andre enden finner vi privatkunder som søker 
etter billigst pris og gjerne fraviker noen krav om fleksibilitet og service. 
  
Flyselskaper har også en sentralisert ordreprosessering som muliggjør en gjennomgang 
av alle salg og prisforespørsler. Flyindustrien var en av de første bransjene til å innføre 
elektronisk ordre og bookingsystemer. Dette skjedde i 1962 da IBM laget ett system kalt 
Sabre for American Airlines. Sabre var ett automatisert system med informasjon 
tilgjengelig for alle reiseagenter tilknyttet American Airlines [8]. Systemet revolusjonerte 
flytrafikkindustrien og hjalp flyselskapene å takle den store veksten i antall passasjerer 
som inntraff på sekstitallet. Flytrafikkmarkedet var på denne tiden gjennomregulert i 
Amerika og billige billetter fantes kun på charter fly. Etter en avregulering på 70 tallet ble 
det mulig for lavprisselskapene å begynne å operere med nesten faste avganger og 
konkurrere med de store selskapene. Disse lavprisselskapene hadde gjerne bedre dekning 
på sine flygninger og holdt derfor kostnadene per sete nede. Det var rundt denne tiden at 
de store selskapene begynte å interessere seg for å tilby forskjellige typer billige billetter 
på de faste flygningene sine. I den forbindelse begynte flere av dem også å benytte seg av 
yield management. Yield management systemer lot flyselskapene å tilpasse sine etter 
hvert komplekse prisstrukturer og kunne allokere hvor mange og når billige billetter for 
en reise skulle slippes ut i markedet. Belobaba og Peter [9] definerer yield management 
som systemer som bruker operasjons modeller for å fastslå det riktige antallet seter som 
skal spares for sen booking av høy fortjeneste kunder. Hvis selskapet kunne være sikre på 
at de ikke gikk glipp av fortjeneste ved å selge billige billetter kunne de fylle opp fly og 
øke profitten betraktelig. Dette var meget viktig for selskap som hadde både 
forretningskunder og lavpriskunder. I dag finnes det flere nettsteder som tilbyr billetter 
som snart går ut på dato til reduserte priser. Ett eksempel på ett slikt sted er 
     
 9 
lastminutetravel.com (http://www.lastminutetravel.com) som tilbyr billetter fra en rekke 
selskaper.  
 
Flybilletter passer også under det siste kriteriet til Jayaraman og Baker nemlig at det 
forekommer tidsbegrensede fall og økninger i etterspørsel etter flyreiser. Under 
ferieavvikling og offentlige høytider er pågangen stor og selskapene kan regne med å 
fylle opp flyene sine med passasjerer som betaler en forholdsvis høy pris. Men i 
lavsesonger og etter spesielle hendelser, her kan terrorangrepet den 11. september nevnes 
som ett eksempel, synker etterspørselen etter flybilletter. Selskapene må da tilpasse antall 
avganger og redusere prisen på sine billetter for å fylle opp sine fly. Det er her yield 
management og dynamisk prising virkelig kommer til sin rett. Siden det også er mulig for 
flyselskaper å tjene penger på frakt av gods må også dette med i beregningen slik at fly 
som ikke er helt fulle kan lastes med mer gods og selskapet på den måten kan ta igjen 
sine faste kostnader og tjene penger. 
 
2.5 Prinsipper for dynamisk prising 
 
Det finnes som tidligere nevnt mange ulike strategier for å dynamisk prise produkter. Jeg 
vil her se litt nærmere på tilbuds prising (price markdown), pakkeprising (bundeling) og 
to algoritmer kalt måldrevet (Goal driven) og derivativ følgende (Derivative following) 
som brukes for å dynamisk justere pris. Jeg vil også komme inn på agenter og strategier 
for læring. 
 
Tilbudsprising er kjent fra flere bransjer som moteindustrien og bilindustrien der forrige 
sesongs modeller gjerne selges til redusert pris. Prinsippet for tilbudsprising er å tilby en 
vare for en bestemt pris i en viss periode og så gradvis redusere denne prisen etter 
perioden er over. På den måten kan bransjene fange opp kunder som ikke ser seg råd til å 
betale full pris og som kanskje ville kjøpt ett annet merke eller ikke kjøpt i det hele tatt. 
Siden produktet i den første perioden ligger ute til salg for fullpris er det også en sjanse 
for at det aldri kommer til å bli solgt for nedsatt pris da lagrene kan tømmes før perioden 
er over. Dermed risikerer selskapet ikke å spise opp sin egen fortjeneste ved å tape 
fullprissalg. Tilbuds prising brukes i dag av flere nettsteder og fungerer på en litt annen 
måte en beskrevet ovenfor. Forskjellen ligger her i at en selger legger ut en vare til en gitt 
pris og med en dato for når prisen kommer til å gå ned. Slik kan de kjøperne som gjerne 
vil sikre seg produktet kjøpe det til full pris eller de kan vente til prisen går ned, men 
risikerer da at det ikke er flere enheter igjen til salgs. Elmaghraby et al. [10] har 
undersøkt effekten av slik prising, men kunne ikke fastslå med sikkerhet under hvilke 
omstendigheter en slik strategi maksimerer en selgers profitt. Det er heller ikke fastslått 
hvilken strategi som er den mest optimale for en kjøper å følge i slike situasjoner.  
 
Tilbudsprising er også brukt i flyindustrien som for billetter som går ut snart. Prisen 
settes ned etter hvert som avreisedato nærmer seg og det er ett begrenset antall billetter 
som legges ut. Flyselskapene benytter seg ofte av beregninger for fremtidig etterspørsel 
og kan legge ut billige billetter i en motsatt rekkefølge av det som er beskrevet overfor. 
Det vil si at de legger ut ett visst antall billige billetter tidlig for å stimulere salg og 
estimere etterspørsel for en gitt avgang. Flyselskaper benytter seg ofte også av 
     
 10 
overbooking, altså at de selger flere billetter en det er seter på flyet, for å forsikre seg om 
full dekning. Dette baserer seg også på estimering av hvor mange av passasjerene som 
kommer til å avbestille turen sin. Lawrence et al. peker i sin artikkel [11] på at slike 
beregninger av antall avbestillinger ofte baserer seg på tall fra tidligere flygninger. 
 
En annen strategi for å øke profitt er å selge flere varer sammen og tilby en redusert pris 
for pakken. Dette kalles bundling og er vanlig innenfor salg av informasjonsprodukter og 
innen reiselivsnæringen. Chang, Li og Smith har påvist at slike pakkeløsninger ofte fører 
til økt salg og reduserte kostnader for selskapene som tilbyr dem [12]. Flyselskaper kan 
for eksempel tilby sine kunder en pakke bestående av flyreise, hotell, leiebil og billetter 
eller reservasjoner til severdigheter og restauranter. Disse pakkene selges så av 
mellomledd eller direkte fra de samarbeidende selskapene. På den måten kan selskapene 
øke sin kontaktflate med markedet og fange opp kunder som leter etter gode tilbud på 
slike pakkeløsninger. Prisen for de enkelte produktene i pakken er redusert i forhold til å 
kjøpe de individuelt og kjøperne får på denne måten en rabatt. For selgerne er denne 
rabatten nøye beregnet slik at alle de samarbeidende selskapene sitter igjen med profitt på 
det produktet de har i pakken.  
 
2.6 Algoritmer for dynamisk prising 
 
Jeg vil nå beskrive den første av de to algoritmene for å beregne pris dynamisk ut fra 
estimert etterspørsel. Begge algoritmene som beskrives baserer seg på at produktet som 
selges har en begrenset varighet og at målet er å maksimere profitt. 
 
Den første algoritmen kalles måldrevet (Goal driven). Denne algoritmen forsøker å spre 
salg av enheter over hele perioden de er til salgs slik at selgeren ikke går glipp av 
perioder med høy etterspørsel. Dette gjøres konkret slik at algoritmen baserer seg på salg 
fra dagen før og legger ut ett visst antall enheter til en fastsatt pris. Hvis salget er lavt en 
dag justeres prisen ned og vice-versa. I slutten av perioden legges alle enheter ut til en lav 
pris for å tømme lageret. Denne algoritmen er simulert av Morris et al. [13] i deres 
Learning Curve simulator. Simulasjonen baserte seg på salg av billetter til en 
baseballkamp. Forfatterne av denne artikkelen introduserer variabler i markedet slik at de 
kan se hvordan algoritmen klarer seg med både stigende og synkende etterspørsel. 
Etterspørsel blir også fordelt slik at det er scenarioer med høy/lav etterspørselsperioder i 
begynnelsen, midten eller slutten av salgsperioden. Deres undersøkelser viser at under 
disse forholdene fungerer den måldrevne strategien godt hvis markedet er tregt og det 
ikke er behov for finjusteringer i begynnelsen eller slutten av salgsperioden. Den 
måldrevne algoritmen skaper økt salg i forhold til å bruke en fast pris uten begrensninger 
på antall billetter solgt per dag i alle markedsforhold. Den viser seg også å være mer 
effektiv en den andre algoritmen i en monopolsituasjon utenom i et marked med 
synkende etterspørsel.  I denne situasjonen er det ingen fordel å vente med å selge 
billettene da prisen må senkes gjentatte ganger mot slutten av salgsperioden for å få full 
dekning. I konkurranse med den andre algoritmen er den mindre effektiv og får kun 
større profitt enn den andre ved ett tilfelle, når markedet har en topp i etterspørsel midt i 
salgsperioden. 
 
     
 11 
Den andre algoritmen kalles derivativt følgende (Derivative following). Denne 
algoritmen baserer seg på å selge så mange billetter i løpet av en dag til maksimal pris. 
Algoritmen tar den siste dagens totale salg og setter dette i forhold til den siste 
prisjusteringen. Hvis det totale salget etter siste prisstigning er høyere en dagen før settes 
prisen opp. Her må det legges til at det selvfølgelig er mulig å ha raskere oppdateringer 
enn per dag. Denne algoritmen har vært brukt i flere agentsystem, blant annet brukte 
Kepart et al. [14] den i sin undersøkelse av ulike strategier for pricebots. Pricebot er en 
automatisert agent som på veiene av en selger samler informasjon om konkurrenters 
priser, etterspørsel etter varen og dynamisk justerer prisen på en vare for å maksimere 
profitt. I Learning Curve simulatoren gjør denne algoritmen det betydelig bedre i 
konkurranse med både den måldrevne algoritmen og fast pris bortsett fra når den er en 
topp i etterspørsel midt i salgsperioden. Dette kommer av at denne algoritmen fører til 
mindre salg i perioden med høy etterspørsel. Ett interessant fenomen oppstår når to 
selgere begge bruker denne algoritmen. Det som skjer er at de to selgerne låses i en 
priskrig hvor den ene prøver å by under den andre.   
 
Denne simulasjonen har klart rom for forbedring da det er mange faktorer som spiller inn 
i ett virkelig marked. Det kan være at kjøperne foretrekker en selger fremfor en annen 
basert på tidligere erfaring. Det er også ukjent i hvor stor grad alle kjøpere bruker sin 
tilgang til prisinformasjon aktivt. Noen kjøpere bruker kanskje ikke noe tid på å sjekke 
priser mens andre benytter seg av både tid og teknologi for å finne frem til den beste 
prisen. Dermed bør ulik kjøperatferd også bygges inn i markedsmodellen. 
 
Morris et al. har også gjennomført en auksjonssimulasjon med flybilletter som salgsvare 
[6]. Systemet de har brukt for simulasjonen heter Arena og deres auksjonssystem er kalt 
Sardine. Systemet er etter hva forfatterne sier et svar på modellen som priceline bruker 
for sine auksjoner. I Sardine har både kjøper og selger større frihet og salget foregår 
direkte uten at det finnes noe mellomledd som først kjøper billetten av selgeren til en fast 
redusert pris. Selger kan kontrollere to parametere i auksjonen, hvor mange seter legges 
ut per dag og en minstepris for billettene. De vinnende budene velges ut etter budrunden 
er ferdig ved ett fast tidspunkt hver dag. Denne simulasjonen bruker to algoritmer på 
selgersiden. Den første kalles minsteprisstrategi (reserve price strategy) og er den 
derivativt følgende algoritme. Den andre kalles seteslippstrategi (seat releasing strategy ) 
og er beskrevet som av Greenwald et al. i deres artikkel om pricebots [15] som 
myopically optimal. Det vil si at selgeren bruker informasjon om kjøpernes atferd for å 
finne en optimal strategi og ser bort fra alle andre faktorer som for eksempel 
konkurrenter. Denne strategien går ut på at man baserer seg på salg fra de to siste dagene 
for å kalkulere hvor mange seter som skal legges ut for auksjon neste dag. 
 
Simulasjonen ble kjørt med forskjellige typer marked med stigende/synkende og konstant 
etterspørsel. Strategiene ble evaluert mot en gjennomkjøring med fast minstepris og ett 
fast antall seter som blir lagt ut for salg hver dag. Resultatet av simulasjonen ble at 
minsteprisstrategien klarte å følge etterspørselskurven godt og førte til økt fortjeneste i 
forhold til gjennomkjøringen med fast pris og fast antall seter. Sete slipp strategien gjorde 
det ikke like bra og klarte ikke å øke inntektene i forhold til fast pris og tilgjengelige 
     
 12 
seter. Dette styrket forfatternes hypotese om at det kreves informasjon om markedets 
tilstand og hvor mye selgeren har solgt i forhold til hvor mange seter som gjenstår å fylle. 
        
2.7 Agenter i relasjon til dynamisk prising 
 
Jeg har tidligere nevnt bruken av automatiserte agenter som pricebots i relasjon til 
dynamisk prising. Dette er ett felt som er i sterk vekst og det er ventet at bruken av slike 
agentsystemer vil bli meget viktige i fremtidens økonomi. Deck og Wilson [16] har sett 
på hvordan slike pricebots representerer et konkurransefortrinn for selskaper som 
benytter seg av dem. Disse agentsystemene benytter seg av ulike strategier for hvordan de 
skal reagere på forandringer i markedet. Noen slike agenter benytter seg av faste 
algoritmer, mens andre bruker forskjellige former for læring. Atter andre bruker en 
kombinasjon av læring og algoritmer. En agent som benytter seg av en lærings strategi 
har som mål å tilpasse seg andre krefter i markedet og utvikle en meningsfylt strategi som 
kan gi den ett fortrinn fremfor de andre agentene. 
 
I mange simulasjoner av agenter og markeder har man kun sett på enkelt parametere som 
pris. Dette er en forenkling av hvordan forholdet mellom kjøper og selger virker og det 
jobbes nå med å utvide antall parametere en agent tar i betraktning før den gjør sine valg. 
Dasgupta og Hashimoto [17] har laget en modell hvor agentene ser på hvordan flere 
attributter ved ett produkt kan påvirke forholdet mellom kjøper og selger og 
konkurrerende selgere. De peker på at tidligere forskning på området gjerne har som en 
forutsetning at alle selgere har fullstendig oversikt over markedet. Det vil si at de for 
eksempel til enhver tid kjenner til konkurrentenes priser. Dette er ikke en realistisk 
forutsetning og de foreslår en modell hvor det ikke er nødvendig for selgerne å ha 
fullstendig oversikt. Deres utregningsmodell krever dog at selgeren rangerer kjøpernes 
preferanser for de ulike attributtene ved et produkt. Disse attributtene kan være for 
eksempel pris, fleksibilitet på kjøp, leveringstid, tilleggstjenester osv.  
  
Jeg har i dette innledende kapitlet forsøkt å gi et innblikk i noen sider ved dynamisk 
prising. Gjennomgangen av strategier for dynamisk prising er ment å fungere som en 
ramme og motivasjon for bruk av et agentsystem til bruk for kjøp og salg av flybilletter. 
Jeg vil gjennom resten av denne oppgaven benytte salg av flybilletter som eksempel på 
bruk av agenter for kjøp og salg. Jeg har valgt å benytte flyindustrien som eksempel da 
dette historisk sett er en industri med sterk konkurranse og stor vilje til å ta i bruk ny 
teknologi. I det neste kapitlet vil jeg komme inn på den teoretiske bakgrunnen for min 
oppgave og ta for meg viktige termer i forhold til agenter, distribuerte systemer og 
mobilitet. 
 
 
 
 
 
 
 
 
     
 13 
3. TEORI 
 
3.1 Agent 
 
Agenter og agentstrukturer representerer en ny måte å analysere og designe komplekse 
systemer på. Agenter kan sees som en arvtager og videreføring av det objektorienterte 
designparadigmet. Som konsept er en agent en innkapsling av funksjonalitet, kunnskap 
og kapasitet. Eksempler på systemer som bygger på agentarkitekturen spenner fra 
forholdsvis enkle systemer som filtreringsapplikasjoner for e-post til meget komplekse 
systemer som kontrollsystem for flytrafikk. Jennings et al [18] tar for seg en rekke 
eksempler på både kommersielle agentsystemer og prototyper samt utviklingen av disse 
sett i et historisk perspektiv.  
 
Det hersker dessverre ingen fullstendig enighet om hva den korrekte definisjonen av 
begrepet agent er. Det er faktisk så utstrakt og forskjelling bruk av termen agent og 
assosierte begreper at det har fremtvunget forsøk på å spesifisere et rammeverk og 
formelle definisjoner av hva en agent egentlig er. For eksempel har Luck og d'Inverno 
[19] i sin artikkel forsøkt å utvikle et formelt rammeverk for agenter ved bruk av et 
spesifikasjonsspråk kalt Z. Jeg vil ikke gå nærmere inn på en beskrivelse av dette språket, 
men nøyer meg med å si at det er et språk bygget opp rundt førsteordens logikk som 
baserer seg på bruk av konsepter og predikater som definerer forholdene mellom disse 
konseptene. Et predikat er vanligvis et verb som sier noe om subjektet i en logisk 
påstand; for eksempel i påstanden ”billetten er ledig” er predikatet ”er ledig”. I denne 
oppgaven er termen agent brukt om programvare som agerer på veiene av en bruker, i 
dette tilfellet en kunde som ønsker å kjøpe en flybillett. En agent innehar noen 
grunnleggende karakteristikker som jeg nå vil se på. 
  
3.1.1 Definisjon av agentsystem 
 
Det finnes noen kriterier som ett system bør oppfylle for å kunne kalles ett agentsystem. 
Det finnes også noen grunnleggende egenskaper et stykke programvare må fremvise for å 
kunne kalles en agent. Jeg baserer min definisjon av agenter på arbeidet til Etzioni og 
Weld [20] og deres artikkel om agenter på Internett. 
 
3.1.2 Karakteristikker ved en agent 
 
En agent har en oppgave eller et mål som den vil forsøke å utføre, enten alene eller i 
samarbeid med andre agenter eller annen type programvare. Kriteriene for målet eller 
oppgaven agenten skal utføre er fastsatt av en bruker, men dette trenger ikke alltid å være 
tilfelle. 
 
En viktig karakteristikk ved en agent er at den innehar en viss grad av autonomi. Det vil 
si at en agent kan ta beslutninger på egen hånd. Graden av autonomi varierer fra agent til 
agent. Noen agenter tar mange beslutninger basert på kunnskap de bærer med seg mens 
andre agenter en mye mindre grad av selvbestemmelse. At agenten tar beslutninger på 
egen hånd innebærer ikke at den kan kalles intelligent av den grunn. Det agenten gjør er 
     
 14 
kort sagt å ta beslutninger basert på kriterier satt opp av brukeren eller diktert av miljøet 
den eksekverer i uten å rådføre seg med en menneskelig part mens den tar disse 
beslutningene. Her er det stor forskjell mellom ulike agenter og mens noen agenter kun 
handler ut fra enkle kriterium tar andre i bruk komplekse metoder for problemløsning. Et 
eksempel på slike avansert agentsystem ble lagt frem Foster et. al i deres gjennomgang av 
agentsystemer for å støtte avgjørelser (decision support) innen medisin [21]. Kvaliteter 
slik som autonomi og intelligens er noe som skiller seg klart fra hvordan et objekt 
fungerer. Objektet eksponerer kun passivt sine metoder slik at en bruker kan bruke 
funksjonalitet eller endre tilstanden som et objekt innkapsler. Jeg vil komme nærmere inn 
på forskjeller mellom objekter og agenter. 
 
 
 
Figur 3.1: Et Venn diagram fra Luck og d'Inverno Som viser agenthierarkiet hvor 
agenten er en videreføring av objektet og den autonome agenten er en videreføring av 
agenten. 
 
Det er et viktig poeng at graden av autonomi defineres klart. På den ene siden er det ikke 
ønskelig å begrense en agents selvbestemmelse så mye at det blir vanskelig å skille 
mellom en agent og normale objekter. Vi ønsker ikke kun å lage avanserte objekter som 
har et handlingsmønster som er gjennomdefinert, men det er heller ikke ønskelig at 
agenten har for stor grad av autonomi da dette kan føre til ett uoversiktlig, ustabilt og 
kaotisk system.. Det finnes ulike modeller for hvordan autonomi kan defineres. Det 
arbeides i dag på flere hold med å utvikle metoder og standarder for å definere grenser for 
autonomi hos agenter. Et eksempel på dette er arbeidet til Weiss et al. [22] som forsøker å 
definere grad av autonomi ved å definere roller agenten spiller. Weiss et al. benytter seg 
av XML for å definere de ulike agentrollene. 
 
3.1.3 Handlingsmønster 
 
En annen karakteristikk ved et agentsystem er at det bør være fleksibelt i forhold til 
miljøet det opererer i. Det vil si at en agent bør tilpasse sin eksekvering og metode for å 
     
 15 
oppnå sitt mål etter hvordan miljøet den opererer i til en hver tid er. I følge Norvig og 
Russel [23] forholder en agent seg til miljøet den lever i ved hjelp av veldefinerte 
sensorer. Gjennom disse sensorene danner agenten seg en persepsjon av hvordan 
virkeligheten ser ut. På samme tid påvirker agenten sitt miljø gjennom sine handlinger. 
Agenten påvirker miljøet gjennom det Russel og Norvig kaller effectors jeg finner ikke 
noe dekkende norsk ord for dette og velger derfor å kalle dette verktøy. Sett ut fra et 
menneskelig ståsted er sensorer ting slik som øyne og ører mens verktøy er hender og 
armer. Hva som utgjør disse sensorene og verktøyene er høyst individuelt ettersom hva 
slags agent vi snakker om. Ett eksempel på en sensor kan være ett nettverksverktøy som 
undersøker om nodene en mobil agent skal besøke er tilgjengelige. Ett eksempel på et 
verktøy kan være en mekanisme en sikkerhetsagent benytter seg av for å sile hvem som 
tilgang til en node, hvis agenten ikke godkjenner deg har du ikke aksess til ressurser på 
denne noden.  
 
 
 
 
Figur 3.2: En agent opplever omverdenen gjennom sensorer og påvirker den gjennom 
effectors. 
 
 
Det er to hovedtyper av handlingsmønster for en agent. En agent kan opptre på en aktiv 
eller reaktiv måte. Handlingsmønsteret kan også være en blanding av disse to.  
 
Ett aktivt handlingsmønster innebærer at agenten selv aktivt agerer i forhold til miljøet. 
Agenten agerer opportunistisk og målrettet, for eksempel ved å søke aktivt etter 
informasjon i omgivelsene sine. En billettagent vil for eksempel søke etter andre agenter 
som tilbyr tjenester hvor billettagenten kan søke etter tilbuds informasjon i selgerens 
data.  
 
Den andre hovedtypen av handlingsmønster en agent kan ha kalles reaktivt. At en agent 
har ett reaktivt handlingsmønster betyr at agenten har en viss oversikt over miljøet den 
opererer i og at den reagerer på forandringer i dette miljøet. En agent som er en del av et 
flytrafikksystem kan ha ett reaktivt handlingsmønster som for eksempel varsler en 
operatør om to fly som er på kollisjonskurs med hverandre. Et annet eksempel kan være 
en mobil agent som undersøker om det er mulig å forflytte seg til neste node i reiseruten 
og agerer ut i fra om det er mulig eller ikke. I ett system med flere agenter er det også 
     
 16 
vanlig at en agent reagerer på input fra andre agenter og tilpasser sin operasjon ut fra 
dette. Det er vanlig at agenter samarbeider om å løse en oppgave. For at dette skal kunne 
skje må agentene kunne ha en viss form for kommunikasjon.  
 
3.1.4 Agent interaksjon 
 
Det siste kriteriet jeg tar med som en agent bør oppfylle er å være sosial. Sosial betyr i 
denne sammenhengen at agenten bør kunne interagere med både kunstige agenter og 
mennesker for å kunne løse problemer eller hjelpe til med aktiviteter. Dette er spesielt 
viktig i ett fleragentsystem hvor de ulike agentene ofte må basere seg på ett tett 
samarbeid for å effektivt løse de problemene som systemet er designet for å løse. 
Interaksjonen mellom agenter skiller seg fra interaksjon i et objektorientert eller 
proseduralt system ved at de ulike agentene samarbeider og selv initierer handlinger 
basert på input fra andre agenter, interne planer og/eller påvirkning fra omverdenen. Det 
har blitt utviklet en spesiell form for UML notasjon for agenter kalt Agent UML. Agent 
UML ble først lagt frem av Bauer et al. i deres artikkel [24], men kom til som et 
samarbeid mellom Bauer, hans kollegaer og interesseorganisasjonene FIPA og OMG som 
henholdsvis arbeider med å utarbeide standarder for agentsystemer og objekt orientert 
programvare. Agent UML er i dag den mest brukte standarden for å beskrive 
agentsystemer og interaksjon i agentsystemer. Figur 3.3 viser et eksempel på Agent UML 
notasjon. Dette eksemplet viser interaksjon mellom en selger og en konsument som 
forhandler om en flybillett i en auksjon. 
 
     
 17 
 
Figur 3.3: Interaksjon mellom en kjøper og en selgeragent i et auksjonssystem vist i 
Agent UML. 
 
 
 
3.1.5 Agent kommunikasjon 
 
For at agenter skal kunne samarbeide må de også kunne kommunisere med hverandre. 
Dette nødvendigvis skje gjennom veldefinerte kanaler og via et språk som agentene kan 
forstå. Chaib-draa og Dignum tar for seg sin artikkel [25] trender innenfor 
agentkommunikasjon. For at det skal være mulig for agenter å kommunisere må det 
finnes et felles språk, dette kalles gjerne Agent Communication Language (ACL). I dag 
er det en variant av dette som har blitt utviklet av FIPA på bakgrunn av et annet språk 
kalt Arcol som i sin tid ble utviklet av Fransk Tèlècom som er det mest brukte språket for 
kommunikasjon mellom agenter. Målet med FIPA ACL var å utvikle et språk med en 
streng semantisk struktur slik at det skulle bli enklere for agenter utviklet i forskjellige 
     
 18 
språk og av forskjellige organisasjoner å kommunisere. ACL eksisterer på et eget lag 
over transportprotokoller slik som HTTP, IIOP eller TCP/IP.  
 
Behovet for et nytt ACL vokste frem som en reaksjon på at forsøk på å standardisere et 
annet mye brukt språk kalt Knowledge Query Management Language (KQML) hadde 
slått feil. KQML er et deklarativt språk, altså et språk som beskriver forholdene mellom 
konsepter og hva disse konseptene og forholdene betyr. Dette står i motsetning til 
prosedurale språk hvor målet er å beskrive hvordan noe skal utføres. Et annet eksempel 
på et deklarativt språk er SQL og et proseduralt språk er Java. 
 
KQML er delt inn i to ulike språk; Knowledge Interchange Format (KIF) og KQML som 
er et kommunikasjonsspråk. Meningen var at disse to skulle gjøre det mulig for 
heterogene agenter å utveksle informasjon gjennom noe som lignet på førsteordens 
logikk. Dessverre gikk utviklingen av KQML i flere retninger og det oppstod en viss 
forvirring om korrekt bruk av konsepter og predikater mye på grunn av et manglende 
regelverk for semantisk struktur. Dette førte til at det utviklet seg forskjellige ”dialekter” 
og behovet for et ny standard vokste frem. FIPA sitt forslag til et ACL er i dag det mest 
brukte språket for agentkommunikasjon. 
 
For at agenter skal kunne kommunisere trenger de ikke bare å snakke samme språk. De 
må også ha en felles forståelse av hva de snakker om. Det vil si de må ha en felles 
forståelse av konseptene som utgjør deres begrepsverden. En slik spesifikasjon av 
semantisk mening kalles en ontologi. Jeg vil komme tilbake til ontologier litt senere i 
dette kapitlet.    
 
3.1.6 Utvikling av agentsystem 
 
Interessen for agentsystemer har sprunget ut av flere vitenskaper og forskere har lenge 
vært interessert i lignende begreper. Det å delegere oppgaver som mennesket ikke kan 
gjøre selv eller som er for repetitive eller kjedelige å gjøre har alltid vært en viktig 
motivasjon for utvikling av ny teknologi.  
 
3.1.7 Motivasjon for agentsystemer 
 
Siden begynnelsen på nittitallet har begrepet agentteknologi blitt mer synonymt med 
programvare som hjelper en bruker med å utføre komplekse oppgaver. Ettersom 
datasystemer blir mer og mer sofistikerte og mange brukere ikke har muligheten eller 
interessen av å sette seg inn i alle detaljer av en prosess er agent teknologi sett som en 
mulig løsning. Brukeren trenger kun begrenset kunnskap om oppgaven han vil utføre og 
agenten trenger noe kunnskap om brukeren og dennes ønsker. Så kan agenten utføre de 
tyngste delene av en oppgave for brukeren slik at denne kan nå sine mål i forhold til 
databehandling. Dette er attraktivt i forhold til informasjonssamfunnet vi har i dag. 
Tilgangen på informasjon er enorm, men vår kapasitet til å sile denne informasjonen og 
finne frem til det som interesserer oss er begrenset. Her kan agenten spille en viktig rolle 
og hjelpe oss finne frem i informasjonsjungelen. Ett eksempel på en slik bruk av agenter 
     
 19 
er Fetch; et verktøy for å støtte innsamling av informasjon fra Internett. Dette verktøyet 
ble skrevet av og presentert i en artikkel av Innes Martin og Joemon Jose [26].   
 
3.1.8 Fra objekt til agent 
 
Utviklingen av teknologi er konstant i bevegelse og når en ny teknologi som skiller seg 
vesentlig fra hva som tidligere har vært standard blir introdusert kalles dette gjerne et 
paradigmeskifte. Det er usikkert om overgangen fra objektorientert analyse til 
agentsystemer kan kalles et paradigmeskifte siden de to lever side ved side og sikkert 
kommer til å gjøre det i fremtiden også. Det er imidlertid sikkert at agentsystemer 
representerer en ny måte å angripe problemer på. Nå er det kanskje litt misvisende å kalle 
agenter for nye da de faktisk har eksistert i en årrekke allerede. Jeg vil nå ta for meg en 
kort historie over utviklingen av agenter. 
 
3.1.9 Arv fra kunstig intelligens 
 
Først og fremst springer ideen om agentsystemer ut fra forskning innen kunstig 
intelligens (AI), objektorientert programmering og interaksjon mellom menneske og 
maskin. Det store målet innen kunstig intelligens har alltid vært å modellere 
menneskelige evner slik som evnen til selvstendig tankevirksomhet. En gren innen 
forskningsmiljøet rundt kunstig intelligens har vært opptatt med å bygge mer eller mindre 
intelligente enheter. Hvis disse enhetene har en viss oversikt over og agerer i miljøet de 
befinner seg i kan de betegnes som agenter.  
 
Selv om begrepet autonomi, altså selvstendighet, kan sees som sentralt innen kunstig 
intelligens var det ikke før midt på åttitallet at interessen for agentsystemer skjøt fart 
innen AI miljøene. Agenter er nært knyttet til forskning på planlegging hos maskiner og 
da spesielt i forhold til såkalte STRIPS systemer som beskrevet av Fikes og Nilson [27]. 
Et typisk STRIPS planleggingssystem har flere likhetsstrekk med agentsystemer. STRIPS 
systemer har en symbolsk modell av miljøet det opererer i, ett predefinert sett av 
handlinger og en planleggingsalgoritme. Ett slikt system jobber mot ett mål og prøver å 
nå dette målet ved å formulere en plan i førsteordenslogikk.  
 
Interessen for agentsystemer kom til dels i gang som en reaksjon på problemer med 
effektiviteten på disse planleggingssystemene. Reaktive agenter som baserte seg på 
førsteordenslogikk syntes ikke å kunne skalere fra små testverdener til den virkelige 
verden. En av de mest kjente kritikerne av klassisk kunstig intelligens, Rodney Brooks, 
mente at intelligent atferd oppstår via interaksjon mellom simplere atferdsmønster. 
Brooks utviklet en agentarkitektur som kalles subsumpsjon arkitektur. Denne arkitekturen 
benytter seg verken av noen symbolsk representasjon av miljøet eller noen form for 
logisk resonnement. Hans agenter var helt reaktive og fulgte et mønster hvor en 
predefinert situasjon utløste en spesiell handling. I sin gjennomgang av utviklingen av 
agentsystemer peker Green et al. [28] på at senere forskning på agenter gjerne har tatt en 
middelvei mellom den helt reaktive agenten og agenten med symbolsk representasjon og 
en logisk fremdriftsplan.  
 
     
 20 
3.1.10 Arv fra Objektorientert analyse 
 
Det finnes mange likheter mellom objektorienterte systemer og agentsystemer. Ett viktig 
prinsipp innen objektorienterte metode er innkapsling. Ett objekt har en indre status i 
form av instansvariabler og har kontroll over manipulasjonen av sin egen status via 
metoder. På den måten kan man si at ett objekt har en viss grad av autonomi. Objektet 
kan også i noen tilfeller modifisere hvilken tilgang og hvem som har tilgang til sin indre 
tilstand. For eksempel i Java kan man spesifisere at innstansevariabler og metoder er 
private, beskyttede eller for alle (public). På den andre siden har ikke objektet noen 
kontroll over sine egne handlinger eller når den utfører disse handlingen. Objektet 
eksponerer metoder som kan kalles av andre objekter og den har ingen kontroll over når 
eller om disse metodene blir eksekvert.  
 
I ett agentsystem er det opp til den enkelte agenten om den skal utføre en operasjon. 
Agenten kan eksponere metoder, men gjør sjelden det. For eksempel kan det hende at en 
agent kommuniserer med en annen agent og forsøker å få denne til å utføre en operasjon. 
Forskjellen mellom en agent og et objekt er her at det ikke er sikkert denne operasjonen 
blir eksekvert. Agenten som har funksjonaliteten kan velge om den skal utføre 
operasjonen eller ikke basert på hva den oppfatter som mest hensiktsmessig for å nå sitt 
overordnete mål eller hva som er mulig i forhold til den nåværende situasjonen. For 
eksempel kan en agent som agerer som en selger av flybilletter velge å avstå fra å selge 
en billett til en agent som agerer som kjøper. Grunne til at selgeren avslår kan for 
eksempel være at den ser det som mer profitabelt å holde igjen billetten og oppnå en 
høyere pris senere. En annen forskjell mellom objektorienterte systemer og 
agentsystemer ligger i forhold til fleksibilitet. Innen objektorienterte analyse finnes det 
ingen faste retningslinjer for hvordan man skal bygge inn aktiv, reaktiv eller sosial atferd. 
Det ligger i en agent sin natur at den kan tilpasse seg ulike situasjoner.   
  
3.1.11 Typer agentsystem  
 
Det finnes ulike typer agenter, men felles for de er at de er ett avgrenset stykke 
programvare som opererer på veiene av en bruker. De ulike typene av agenter kan deles 
inn i to hovedgrupper: lokale og distribuerte. Disse kan igjen deles inn i statiske og 
mobile agenter. Det er også et skille mellom agentsystemer med enkelt agenter som ikke 
kommuniserer og fleragentsystemer hvor agentene kommuniserer, såkalte Multi Agent 
Systems (MAS).  
 
3.1.11.1 Statiske agenter  
 
Statiske agenter opererer innenfor ett homogent miljø, gjerne på en maskin. Eksempler på 
slike agenter kan være et intelligente bruker grensesnitt som forsøker å tilpasse seg en 
bruker og dennes bruksmønster. Et annet eksempel er en intelligent sorterings mekanisme 
som filtrerer ut relevant informasjon fra et søk etter data på bakgrunn av hva den vet om 
en brukers interesser. Denne agenten kan for eksempel se på hva slags informasjon 
brukeren allerede har i form av filer på sin datamaskin.  
 
     
 21 
3.1.11.2 Mobile agenter  
 
Mobile agenter har muligheten til å bevege seg fra node til node i et nettverk. En mobil 
agent kan for eksempel reise fra en bærbar maskin og over til en node som har en tjeneste 
brukeren av den bærbare maskinen er interessert i. Motivasjonen for å benytte slike 
mobile agenter er flerdelt, men ett argument er at et slikt system sparer båndbredde. I 
stedet for at kommunikasjon mellom to eller flere noder som er fysisk avskilt i rom 
foregår ved at nodene sender hverandre meldinger reiser den mobile agenten over til den 
fjerne noden. Når den kommer frem kan den på veiene av sin eier utføre den ønskede 
operasjonen, men forskjellen er nå at alle meldinger som utveksles mellom agenten og 
tjeneren er lokale og derfor ikke bruker nettverksressurser. Et annet beslektet argument er 
at mobile agenter kan støtte frakoblet operasjon. Under frakoblet operasjon kan en klient 
sende fra seg en mobil agent og så koble seg fra nettverket. Den mobile agenten utfører 
så sitt oppdrag på veiene av klienten. Hvis så agenten skal returnere kan dette føre til et 
problem hvis klienten ikke er tilgjengelig.    
 
Mobile agenter hører til under distribuerte agenter. En mobil agent navigerer over 
nettverket med sin egen kode base. Det finnes mange ulike måter å gjøre dette på og en 
agent kan være lett eller tung i forhold til hvor stor data mengde som må sendes over 
nettverket. For eksempel kan en lett mobil agent være en mindre del av ett system som 
sendes over ett nettverk for å innhente informasjon for så å komme tilbake med data som 
prosesseres videre av hovedsystemet. En tung agent kan ha en større oppgave som å selv 
prosessere data og utføre handlinger på veiene av brukeren. I forbindelse med denne 
oppgaven vil jeg forsøke å lage en mobil agent som skal innhente billettinformasjon. 
Dette vil være en lett agent uten noen særlig grad av evne til å gjøre kompliserte 
beregninger.  
 
Mobile agenter har også flere andre bruksområder som for eksempel innen 
nettverkssikkerhet. Et mulig bruksområde innenfor sikkerhet er å utplassere mobile 
agenter som en type vokter som overvåker all trafikk inn og ut av et system. Dette kan 
selvfølgelig gjøres med statiske agenter eller annen programvare også, men ved bruk av 
mobile agenter åpnes muligheten for at nettverket dynamisk kan endre seg over tid. Hvis 
nettverkstopologien endres kan de mobile sikkerhetsagentene forflytte seg tilsvarende for 
å opprettholde et sikkert system. 
 
3.1.11.3 Enkeltagent og fleragentsystemer (MAS) 
  
Et agentsystem kan enten bestå av separate agenter som utfører hver sin oppgave og ikke 
samarbeider. Et slikt system kan sies å bestå av enkeltagenter. Hver av disse agentene har 
et mål eller en oppgave de søker å utføre og selv om det er mulig at de kommuniserer 
med andre systemer eller andre agenter for å utføre sine oppgaver så har hver av dem kun 
ansvar for å utføre sine egne oppgaver.  
   
I motsetning til systemer med enkelt agenter kan agenter i fleragentsystemer samarbeide 
for å løse en oppgave. Slike systemer utnytter den sosiale delen av agentmodellen og 
setter de ulike agentene til å samarbeide om å nå felles mål. For eksempel kan en 
     
 22 
sluttbruker med begrensede muligheter for å sende og motta data benytte seg av en lett 
agent som samarbeider med en rekke andre, trolig større, agenter om å innhente den 
informasjonen brukeren søker. Et annet eksempel er agenter som selv kun sitter på en 
avgrenset del av den tilgjengelige kunnskapene i et system.  Jennings og Woolridge [29] 
kaller slike systemer fleragentsystemer. Mye forskning innen agentsystemer retter seg 
nettopp mot slike agentsystemer og bruken av disse. Det er ikke alltid klart hva som er 
den beste løsningen i forhold til å benytte en enkel agent arkitektur eller et 
fleragentsystem. I sin artikkel [30] sammenlignet Peng og hans kollegaer to av disse 
fremgangsmåtene i forhold til et klassifikasjonssystem for dokumenter. Forfatterne av 
denne artikkelen kom frem til at kvaliteten på klassifikasjonen og hastigheten gikk 
gradvis ned ettersom de introduserte flere agenter. I dette tilfellet var altså et system med 
enkelt agenter bedre. De peker på at en viktig grunn til dette resultatet var de ekstra 
ressursene som måtte brukes på selve samhandlingen mellom agentene, denne 
ressursbruken oversteg ressursene benyttet på å løse selve oppgaven.   
 
Distribuerte agenter må ha en navigasjons modell og en kommunikasjons modell og har 
ofte også en sikkerhets modell. For at slike agenter skal kunne fungere trengs det et miljø 
som tillater at disse kan eksekvere. I et slikt miljø må de ulike maskinene tilby ett eller 
flere grensesnitt som agenten kan knytte seg til. Disse grensesnittene må kunne tilby data 
på en standardisert måte slik at data kan prosesseres av agentene. Jeg vil se nærmere på 
hvordan data kan representeres på en slik måte i neste del av dette kapitlet når jeg tar for 
meg kunnskapsbaser og ontologier. 
 
3.1.12 Rammeverk og standardisering 
 
Det finnes i dag flere forslag til rammeverk for agentsystemer. FIPA lister på sine sider 
[31] noen av de største; Aglets, FIPA-OS, D’Agents, Grasshopper, Odyssey, Tacoma, 
JADE og MOA, men det finnes mange flere. Disse rammeverkene har mange likheter 
både i utforming og funksjonalitet, men de har også mange forskjeller. Ingen av dem er 
helt komplette og det er forventet at teknologien på dette feltet vil modnes i løpet av de 
neste årene. Flere av disse rammeverkene bygger helt eller delvis på standarder for 
agentsystemer som er utarbeidet av FIPA. 
 
Foundation for Intelligent Physical Agents (FIPA) er en organisasjon som er interessert i 
å utvikle standarder for agenter og fleragentsystemer. Organisasjonen ble offisielt tatt opp 
som en standard komité av Institute of Electrical and Electronics Engineers (IEEE) i juni 
2005. FIPA har blant annet utviklet en livssyklusmodell for agenter og som tidligere 
nevnt utarbeidet et ACL samt flere generelle ontologier for å beskrive vanlige oppgaver 
forbundet med administrasjon og drift av et agentsystem. FIPA tar sikte på å lage 
standarder som er generelle nok slik at kommersielle og ikke-kommersielle aktører kan 
utvikle systemer og rammeverk som kan kommunisere og samhandle på tvers av 
heterogene systemer. FIPA ble startet i Sveits i 1996. 
 
Det eksisterer også en rekke verktøy for å utvikle agentsystemer såkalte agent ”toolkits”  
Serenko og Detlor har i sin artikkel [32] evaluert flere av disse i lys av bruk i en 
læringssammenheng. Noen av de mer kjente verktøysamlingene er AgentBuilder og 
     
 23 
JADE (Java Agent Development Framework). JADE er både et agentplattform og et 
rammeverk for å bygge agenter i.  Disse verktøyene skal gjøre det lettere å utvikle 
intelligente agenter ved å abstrahere vekk noen av detaljene i utviklingen av ett 
agentsystem. I denne oppgaven vil jeg benytte meg av JADE for å utvikle et agentsystem 
for innhenting av tilbud på flybilletter. Jeg vil benytte JADE som grunnlag for å se på 
mulige løsninger på problemet som oppstår hvis en mobil agent ikke kan returnere til sin 
hjemmenode.  
 
3.1.12.1 FIPA MAS infrastruktur 
 
Jeg vil nå se kort på noen grunnleggende prinsipper ved disse spesifikasjonene i forhold 
til et fleragentsystem. Jeg baserer min redegjørelse av FIPA standarder på deres egne 
standard dokumenter [33, 34]. FIPA sin standard beskrivelse for en MAS arkitektur er en 
abstrakt infrastruktur modell. Altså en modell som ikke er implementert, men som er 
ment å skulle fungere som retningslinjer for konkrete agentrammeverk. JADE er et 
eksempel på et slikt rammeverk som følger FIPA sin abstrakte modell. FIPA lister noen 
grunnleggende karakteristikker ved en sin infrastruktur: 
 
• Arkitekturen er bygget som et lag over andre strukturer, altså 
agentarkitekturen skal være klart skilt fra underliggende lag så vel som 
applikasjonslag som ligger over. Innenfor distribuerte systemer kalles gjerne 
en slik infrastruktur for mellomvare (middleware). 
 
• Arkitekturen skal være transparent for brukeren. Brukeren skal kun interagere 
med arkitekturen ved å benytte seg av tjenestene denne tilbyr gjennom 
veldefinerte grensesnitt. 
 
• Arkitekturen er basert på en standard spesifikasjon og bygger videre på 
praktiske erfaringer og utprøvde løsninger hentet fra utviklingen av 
agentsystemer. 
 
Infrastrukturen i et fleragentsystem består av et sett av tjenester og funksjonalitet som 
støtter agenter sine gjøremål slik som koordinasjon, kommunikasjon og mobilitet. Figur 
3.4 viser FIPA sin spesifikasjon av hva en infrastruktur for et fleragentsystem består av.  
 
     
 24 
 
 
Figur 3.4: Den grunnleggende strukturen i FIPA sin spesifikasjon av infrastruktur for en 
agentplattform. Her kan vi se et administrasjonssystem, en oppslagstjeneste og et 
transportsystem for meldinger.  
 
Jeg vil nå beskrive kort de ulike elementene i denne infrastrukturen. 
 
3.1.12.1.1 Agent 
 
Agenter er prosesser som har en identitet (en unik identifikasjon kalt Agent Identifier 
(AID), en eier og en tjeneste beskrivelse som beskriver hva slags tjenester den utfører. 
Agenter kommuniserer ved bruk av ACL og benytter seg av et transportsystem for å 
sende disse meldingene. 
 
3.1.12.1.2 Directory facilitator 
 
Directory facilitator tilbyr en slags ”gule sider” tjeneste til de andre agentene i et 
fleragentsystem. Andre agenter kan her registre/avregistrere sine tjenester og gjøre 
spørringer for å finne andre agenter med ønskede tjenester. En slik tjeneste er meget 
vanlig i fleragentsystemer, men ikke påkrevd. 
 
3.1.12.1.3 Agent management system 
 
Et agent administrasjons system (AMS) er ansvarlig for å kontrollere aksess til og bruk 
av agentsystemet. Alle agenter må registrere seg med administrasjonssystemet og som en 
følge av dette fungerer et AMS som en katalog over alle agenter i et system. Dette skiller 
seg fra en Directory Facilitator som lister agenter etter hva slags tjenester de utfører. I et 
agentsystem er det påkrevd å ha et AMS. 
     
 25 
 
3.1.12.1.4 Message Transport system 
  
Et Message Transport System (MTS) representerer den standard 
kommunikasjonsmetoden mellom agenter. På en platform er et MTS knyttet til en Agent 
Communication Channel (ACC). Et MTS er også relatert til en Message Transport 
Protocol (MTP) som definerer standard protokoll. Eksempel på slike protokoller er 
HTTP og IIOP. 
 
3.1.12.2 JADE 
 
Jeg vil nå se på JADE i noe mer detalj siden det er dette rammeverket jeg har valgt å 
benytte meg av i denne oppgaven. Jeg baserer min redegjørelse om JADE på Bellifemine 
et al. sin artikkel om JADE fra 2003 [35]. Bellifemine og de andre forfatterne av denne 
artikkelen er skaperne av JADE rammeverket. De er tilknyttet universitetet i Parma. 
JADE er implementert fullstendig i Java. 
 
Jeg valgte å bruke JADE som følge av at det er per dags dato det rammeverket med flest 
brukere hvorav mange av disse er tilknyttet universiteter og forskningsinstitutt. Den andre 
viktige grunnen til at jeg valgte å bruke JADE er at det er et prosjekt med åpen kildekode. 
Jeg mener dette er viktig sett fra et forskningssynspunkt og meget nyttig i forhold til min 
personlige læringsprosess. Jeg vil komme tilbake til mine erfaringer med bruk av JADE i 
diskusjonen i slutten av denne oppgaven. 
 
Som nevnt ovenfor er JADE et rammeverk for utviklingen av agenter og da spesielt 
fleragentsystemer som følger FIPA spesifikasjonene.  
 
3.1.12.2.1 JADE - Agent plattform 
 
JADE er som tidligere nevnt et rammeverk for å implementere og kjøre 
fleragentsystemer. JADE er bygget på FIPA spesifikasjonene og tilbyr således et AMS, 
en Directory Facilitator, et MTS og implementerer FIPA Management ontologien for å 
kalle tjenester fra AMS. Figur 3.5 viser en grafisk fremstilling av et fleragentsystem i 
JADE som er distribuert over tre noder. En JADE plattform er en logisk enhet som kan 
bli distribuert over flere fysisk atskilte vertsmaskiner. Hver vert er representert som en 
container, en container er eksekveringsmiljøet som agentene kan kjøre i. Dette 
eksekveringsmiljøet er en Java Virtual Machine (JVM). JADE bruker RMI for å 
kommunisere mellom JVM. I en JADE plattform er det påkrevd at det finnes en 
hovedcontainer. For å knytte til nye plasser agenter kan eksekvere i og forflytte seg til 
opprettes det nye containere som knyttes til hovedcontaineren. Bildet viser en plattform 
som har en hovedcontainer som holder et AMS og to perifere containere.  
 
     
 26 
 
Figur 3.5: Viser et eksempel på en JADE plattform med en hovedcontainer og to perifere 
containere. 
 
 
3.1.12.2.2 JADE - Agent modell 
 
Agentmodellen til JADE definerer hver agent som en eksekveringstråd (thread) og JADE 
sin Agent klasse (som alle brukeragenter må arve) implementerer Runnable grensesnittet. 
Agent klassen definerer også basisfunksjonalitet slik som registrering, sending av 
meldinger og tjenesteregistrering slik at en agent kan interagere med plattformen. En 
agent er unikt identifisert ved bruk av en AID. Innenfor en plattform er denne AID unik 
og inneholder flere opplysninger om en agent slik som navn og adresser. En agent i 
JADE har ulike atferder (Behaviours) som den gjør bruk av for å utføre sine oppgaver. En 
atferd kan sammenlignes med en metode hos et objekt. Det finnes flere maler for slike 
atferder som en utvikler kan gjøre bruk av for å implementere applikasjonsspesifikk 
funksjonalitet. En agent kan kjøre mer enn en atferd om gangen og en atferd kan kalle en 
annen atferd og på denne måten skape komplekse handlingsmønster. Koordinasjonen av 
når en atferd blir eksekvert er skult for utvikleren. Reglen er at atferder eksekveres 
parallelt. Hvis utvikler vil kontrollere til hvilken tid en atferd kjører og i hvilken 
rekkefølge kan han kalle block() som da holder igjen aktiviteter relatert til en atferd. 
 
3.1.12.2.3 JADE - kjernetjenester 
 
Kjernen i JADE er bygget opp rundt en rekke ulike tjenester, både tjenester spesifisert av 
FIPA og tilleggstjenester slik som replikasjon av hovedcontainer og sikkerhetstjenester. 
Hver av tjenestene kan bli aktivert separat. Tjenestene som aktiveres automatisk er: 
     
 27 
 
• Agent mobilitet 
 
• Meldingstjeneste 
 
• Agent administrasjon 
 
• Notifikasjonstjeneste   
 
Jeg har nå sett på noen grunnleggende karakteristikker for agenter og agentsystemer. Jeg 
har også tatt for meg arbeidet med standardisering og utviklingen av rammeverk for 
agentsystemer. I den neste delen av dette teorikapitlet vil jeg ta for meg begrepet 
ontologi. 
 
3.2 Ontologi 
 
Da jeg først begynte å skrive på denne oppgaven var jeg interessert i å undersøke ulike 
format som kunne passe til å utveksle informasjon om flybilletter. Med det mener jeg at 
jeg ville finne ut hvordan en kjøperagent kunne søke i en selger sin data om flybilletter. 
Jeg antok at grunnlaget for et slikt søk måtte være et velformet og strengt format slik at 
agenten kunne vite både hvor den skulle lete og hva den skulle se etter. I den forbindelse 
så jeg på flere elektroniske kataloget hvorav de fleste av disse var uttrykt i XML. Jeg ble 
imidlertid snart klar over at kun det å beskrive strukturen på data ikke var nok når en 
agent skulle orientere seg innenfor et domene. Jeg valgte derfor å ikke ta med disse 
katalogformatene. 
  
Agenten har behov for å kjenne til hva ulike konsepter innfor et domene betyr og hvordan 
de forholder seg til hverandre. I den forbindelse ble jeg oppmerksom på ontologier. 
 
3.2.1 Definisjon 
 
Det finnes flere forskjellige svar på hva den eksakte definisjonen på en ontologi er. 
Gruber [36, 37] gir en definisjon på ontologi sett fra et filosofisk synspunkt. Han 
beskriver ontologi som læren om eksistens - en ontologi er en systematisk beskrivelse av 
et domene. I denne definisjonen nevner Gruber også at begrepet ontologi ofte forveksles 
med epistemologi som er læren om kunnskap og viten. Ontologi er innen filosofi nært 
beslektet med det å lage et begrepsmessig bilde av omverdenen (conceptualization). 
Genesereth og Nilsson [38] definerer det å lage et slik begrepsmessig bilde som å 
klassifisere verden rundt oss som en samling konsepter, objekter og enheter som finnes i 
domenet vi er interessert i og relasjonene disse har til hverandre. Gruber kaller en 
ontologi for en formell spesifikasjon av en slik begrepsverden. 
 
“  
Ontology is the study of what there is, an inventory of what exists. An ontological 
commitment is a commitment to an existence claim 
” (http://www.artsci.wustl.edu/~philos/MindDict/ontology.html) 
     
 28 
 
“An ontology is an explicit specification of a conceptualization. [. . . ] In such an 
ontology, definitions associate the names of entities in the universe of discourse (e.g., 
classes, relations, functions, or other objects) with human-readable text describing 
what the names mean, and formal axioms that constrain the interpretation and well-
formed use of these terms. Formally, an ontology is the statement of a logical theory.”  
(Tom Gruber, http://www.ksl.stanford.edu/kst/what-is-an-ontology.html) 
 
En Ontologi er ikke avhengig av have slags type språk den er beskrevet i. Allikevel er en 
ontologi beslektet med språk i den forstand at vi gjerne definerer et vokabular som 
beskriver konsepter i vår ontologi. Det er nettopp et slikt vokabular agenter benytter seg 
av for å kommunisere med hverandre om konsepter og relasjoner innenfor et 
begrepsområde.  
 
3.2.2 Motivasjon for bruk av ontologier 
 
Bruken av ontologier varierer innenfor ulike applikasjonsområder. Beuster peker sin 
artikkel [39] på tre former for bruk av ontologier: 
 
• Modellering. Bruke ontologi som en velformulert modell av et domene. 
 
• Kommunisere. Vite eksakt hva det er vi kommuniserer om. 
 
• Resonere. Dra konklusjoner basert på vår modell av et domene. 
  
I forhold til agenter er alle disse tre bruksformene nyttige. En agent behøver å bygge opp 
en kunnskapsmodell om domenet den opererer. En slik kunnskapsmodell kalles noen 
ganger en Knowledge Base - et kunnskapsreservoar. En agent behøver også som nevnt å 
kommunisere på en fornuftig måte og den bør også kunne trekke konklusjoner basert på 
sin modell av domenet eller på bakgrunn av kommunikasjon med andre agenter. Figure 
3.6 viser et enkelt eksempel på en ontologi. 
  
 
Figur 3.6: Eksempel på en meget enkel ontologi som kun består av konsepter og som 
beskriver levende organismer 
     
 29 
 
3.2.3 Bruk av ontologi 
 
Etter man har beskrevet en ontologi kan man utnytte den for å utlede kunnskap og 
utveksle data mellom to agenter. I forhold til min oppgave hvor jeg har laget et enkelt 
agentsystem hvor kjøperagenter forsøker å innhente informasjon om flybilletter benytter 
jeg en enkel ontologi for å beskrive konsepter tilknyttet en flyreise. På den måten vet 
kjøperagenten eksakt hva den skal lete etter. Rettere sagt vet kjøperagenten hva den skal 
spørre en selgeragent om og selgeren vet eksakt hva kjøperen er på utkikk etter. De to 
agenttypene kan selv styre hele denne kommunikasjonsprosessen selv uten at en bruker 
behøver å involvere seg. I denne ontologien benytter jeg også et enkelt predikat for å 
definere at en flyreise er tilgjengelig. Jeg har uttrykt min ontologi i Java og bruker en 
klasse for å beskrive min ”flight” ontologi. I denne klassen benytter jeg tekst konstanter 
som peker på klasser som beskriver de ulike konseptene, predikatene og handlingene 
samt hvordan disse forholder seg til hverandre. 
 
Den delen av denne ontologien som omhandler en flyreise ser slik ut: 
 
Først setter jeg opp konstantene: 
 
public static final String FLIGHT = "FLIGHT"; 
public static final String FLIGHT_DESTINATION = "destination"; 
public static final String FLIGHT_ORIGIN = "origin"; 
public static final String FLIGHT_NUMBER = "flight_number"; 
public static final String FLIGTH_DATETIME = "date"; 
public static final String FLIGTH_ID = "fid"; 
…. 
Så legger jeg til et konseptskjema: 
 
add(new ConceptSchema(FLIGHT), Flight.class); 
…. 
Og til sist definerer jeg hva dette konseptskjemaet består av: 
 
ConceptSchema cs = (ConceptSchema)getSchema(FLIGHT);cs.add(FLIGHT_NUMBER, 
(PrimitiveSchema)getSchema(BasicOntology.INTEGER), ObjectSchema.OPTIONAL); 
 cs.add(FLIGHT_ORIGIN, (PrimitiveSchema)getSchema(BasicOntology.STRING)); 
 cs.add(FLIGHT_DESTINATION, (PrimitiveSchema)getSchema(BasicOntology.STRING)); 
 cs.add(FLIGTH_DATETIME, (PrimitiveSchema)getSchema(BasicOntology.DATE)); 
 cs.add(FLIGTH_ID, (PrimitiveSchema)getSchema(BasicOntology.FLOAT)); 
 
3.2.3.1 Bruk i agentsystem 
 
Å benytte ontologier for å beskrive et domene for bruk med et fleragentsystem er en 
metode som er tatt i bruk med stor suksess innen svært ulike felt. For eksempel benyttet 
Sujanani et. al  [40] seg av en dette i deres artikkel om bruk av ontologier for å beskrive 
finansielle markeder for bruk med et fleragentsystem skrevet i JADE. Sujanani og de 
     
 30 
andre forfatterne av denne artikkelen peker på at en av de vanskeligste oppgavene med å 
utforme en ontologi var å sette seg inne i domenet de skulle modellere. Dette er i høy 
grad også tilfelle med domenet jeg har valgt å se på, men for denne oppgaven har jeg kun 
utviklet en meget enkel ontologi som kun er ment å illustrere hvordan to agenter benytter 
en ontologi for å kommunisere.    
 
Det finnes som sagt flere ulike typer ontologier og mange bruksområder. En av disse 
bruksområdene er det som kalles det semantiske nettet. W3C definerer et semantisk 
nettverk som et nettverk hvor data kan bli delt og gjenbrukt av flere ulike typer 
applikasjoner og for ulike domener [41]. Slike nettverk er sett av mange som fremtiden 
innenfor nettverksbaserte tjenester. Det semantiske nett tilbyr tjenester på en slik måte at 
ikke bare mennesker kan finne frem, men også agenter. Det er også kommet en rekke 
forslag til bruk av agentteknologi i sammenheng med introduksjonen av et semantisk 
nett. I forhold til mitt eksempel med en kjøperagent som leter etter tilbud på flybilletter 
vil det kunne være mulig å sende en agent ut på det semantiske nettet og denne agenten 
vil selv finne frem til aktuell selgere. Flere artikler har også foreslått å implementere 
semantiske nettjenester som atferdsorienterte agenter [42, 43, 44]. Dette er en mulig 
utvidelse av den typen system jeg vil forsøke å implementere i forbindelsen med denne 
oppgaven. 
 
3.2.3.2 Semantisk nettverk 
 
Jeg vil gi en kort beskrivelse av hva det semantiske nett bygger på. Grunnlaget for det 
semantiske nettet er Resource Description Framework (RDF). 
"The Semantic Web is an extension of the current web in which information is 
given well-defined meaning, better enabling computers and people to work in 
cooperation." (The Semantic Web”, Scientific American) [45]  
3.2.3.2.1 RDF 
 
RDF er et rammeverk som benytter seg av eXtensible Markup Language (XML) og 
Uniform Resource Identifier (URI) for å beskrive betydningen av termer og relasjoner 
mellom disse. Det er stor aktivitet rundt forskning på semantiske nett og det blir lagt ned 
mye arbeide i å utvikle tjenester og se på mulig bruk av slike nettverk. Jeg vil i denne 
oppgaven begrense meg til å gi et lite overblikk over semantiske nett sett i forhold til 
agenter og ontologier. Bruken av agenter har en sentral plass i utviklingen av semantiske 
nett tjenester. Det semantiske nettet muliggjør nemlig at maskiner eller programmer slik 
som agenter på en veldefinert måte kan søke etter ønsket informasjon på veien av en 
bruker. Figur 3.7 gir et bilde av den lagvise protokollstrukturen i et semantisk nettverk. 
 
 
     
 31 
 
 
Figur 3.7: Viser de ulike protokollagene i det semantiske nettet 
 
3.2.3.2.2 DAML / OIL 
 
McIlraith et al. [46] har sett på mulighetene som åpner seg ved bruk av semantiske 
nettjenester i kombinasjon med agentsystemer. I denne artikkelen ser forfatterne på 
utviklingen av ulike programmeringsspråk spesielt beregnet for å kode inne semantisk 
mening som kan tolkes av agenter. Ett av disse er språkene er DARPA Agent Markup 
Language (DAML). DAML har blitt til grunnet vanskeligheter med å definere forholdene 
mellom termer i et domene. DAML er tenkt benyttet sammen med Ontology Inference 
Language (OIL) som er språk for å definere og trekke ut kunnskap fra ontologier. I den 
siste versjonen av DAML som heter DAML+OIL er det to teknologiene integrert.  
 
Ved bruk av DAML+OIL kan man lage såkalt semantisk kode. Forenklet sett kan dette 
beskrives som at man kan koder inn mening i nett-tjenester. En tjeneste får en betydning 
slik den har i den virkelige verden. Herfra er det mulig å benytte en agent til å utføre 
oppgaver på veiene av en menneskelig bruker da agenten nå kan vite med sikkerhet hva 
det er den leter etter og hvordan den skal kommunisere med en tjeneste. For eksempel er 
det tenkelig at slike tjenester vil bli vanlige for bestilling og kjøp av varer og tjenester 
som flyreiser. 
 
I denne delen av teorikapitlet har jeg sett på ontologier og forsøkt å gi en beskrivelse av 
hva de er og hva de brukes til. Jeg har sett på ontologi i forhold til agenter og utviklingen 
av semantiske nettverk. Jeg har også forsøkt å trekke paralleller mellom utviklingen av 
semantiske nettjenester og agentteknologi. Videre vil jeg ta for meg begrepet routing og 
se på det i forhold til mobile agenter og mobile terminaler. 
 
     
 32 
3.3 Routing 
 
Jeg vil nå undersøke noen grunnleggende prinsipper i forhold til routing. Jeg velger å ta 
med en gjennomgang av dette emnet da det er sentralt i forhold til det teoretiske 
grunnlaget for min oppgave. Beskrivelsen av routing vil bli strukturert på følgende måte: 
Først vil jeg se kort på routing som et generelt begrep og definere noen sentrale termer 
knyttet til routing. Videre vil jeg se på modeller og protokoller for nettverkstrafikk, 
metoder for å øke adresserom og herunder komme inn på hvorfor dette har relevans for 
utviklingen av mobile agentsystem. Jeg vil så se kort på routing for mobile enheter og i 
den forbindelse gi en kort beskrivelse av Mobil IP. Dette er fulgt av en beskrivelse av de 
to hovedoppgavene innen routing, å sette opp en optimal rute og packet switching.  
Jeg vil komme inn på implikasjoner for utviklingen av agentsystem. Kapitlet avsluttes 
med en beskrivelse av routing i forhold til agentsystemer, nærmere bestemt mekanismer 
for å finne lokasjonen til en agent.  
 
3.3.1 Definisjon 
  
Cisco definerer begrepet routing slik: 
 
”Routing is the act of moving information across an internetwork from a source to a 
destination. Along the way, at least one intermediate node typically is encountered.” 
(http://www.cisco.com/univercd/cc/td/doc/cisintwk/ito_doc/routing.htm) 
 
Når informasjon skal sendes over ett nettverk må det først beregnes en optimal rute over 
nettverket fra sender til destinasjon. Det finnes flere ulike algoritmer for å finne en 
optimal rute gjennom et nettverk, men jeg vil ikke komme inn på disse i denne oppgaven. 
Informasjonsmengden som skal sendes over et internettverk kan normal ikke sendes i sin 
helhet og må derfor brytes opp i mindre enheter. Disse mindre enhetene innkapsles i noe 
tilsvarende en konvolutt kalt en frame og det legges til såkalt header informasjon. Hver 
av disse header tilleggene tilhører et bestemt lag i OSI modellen og inneholder 
informasjon som prosesseres av det respektive laget. Figur 3.8 viser oppdelingen av OSI 
modellen og illustrerer hvordan header informasjon blir lagt til en dataenhet. Disse 
mindre enhetene som er kapslet inn og tillagt header- informasjon kalles gjerne pakker. 
Et internettverk er flere mindre nettverk som er koblet sammen ved bruk av IP, Internett 
protokollen. Et internettverk kalles også et internett, men må ikke forveksles med 
Internett med stor i som er ett spesifikt internett.  Aktiviteten routing foregår i det tredje 
laget, nettverkslaget, av nettverksreferansemodellen til OSI som har syv lag.  
 
     
 33 
 
 
Figur 3.8: De syv lagene av OSI modellen med en fremstilling av hvordan data pakkes 
inn og header informasjon legges til i de ulike lagene før det overføres via Internettet 
 
3.3.2 Historie 
 
Overgangen til distribuerte og større nettverk med heterogene, altså ulike, noder drev 
frem behovet for protokoller for routing av data fra et utgangspunkt på ett nettverk til en 
destinasjon på et annet. Et heterogent nettverk står i kontrast til et homogent nettverk. At 
et nettverk er homogent betyr at det består av like noder. At nodene er like betyr i denne 
sammenhengen at de benytter samme type programvare, les operativ system. Jeg har ikke 
mulighet til å komme inn på alle de ulike fasettene av routing, men jeg vil forsøke å 
belyse noen sentrale begreper og beskrive noen nøkkelkomponenter innen routing.  
 
3.3.3 Definisjon av begreper 
 
Jeg vil starte med å gå gjennom noen sentrale begreper relatert til routing. Dette er ikke 
ment å være noen utfyllende liste, men heller en redegjørelse for termer jeg vil benytte 
senere i gjennomgang av teoretisk grunnlag for min oppgave og diskusjon av tidligere 
publiserte løsninger.  
 
3.3.3.1 Node 
 
ATIS [48] definerer en node som en terminal på en vilkårlig gren av et nettverk eller en 
kobling mellom to eller flere grener av et nettverk. En node kan for eksempel være en 
server (endepunkt) eller en router (koblingspunkt). En pakke som sendes over et 
internettverk kan sies å komme fra en node og være på vei til en annen; fra et 
utgangspunkt og til en destinasjon. På veien mellom utgangspunktet og destinasjonen må 
en slik pakke typisk innom minst en annen node. Slik er det også for en agent som har 
muligheten til å migrere, altså en mobil agent. Man kan si at agenten lever på en node, 
     
 34 
dens hjem og så migrerer til fremmede noder over et nettverk. Dette kan være et lokalt 
nettverk (LAN) eller et mye større internettverk slik som Internett. En node i et nettverk 
er registrert med en adresse og på den måten kan en agent navigere seg frem til en 
destinasjon, på samme måte sendes en pakke til en node basert på adressen som er oppgitt 
som destinasjon.  
 
3.3.3.2 Hop 
 
Nodene som en pakke eller en agent må reise gjennom kalles gjerne mellomliggende 
noder. Figur 3.10 viser en grafisk fremstilling av hvordan en pakke beveger seg fra 
utgangspunkt til destinasjon gjennom flere mellomliggende noder. En forflyttning av en 
pakke fra en node til en annen kalles et hopp (hop). Innen litteratur om agentsystemer og 
da spesielt mobile agenter og fleragentsystemer snakker man ofte om enkelthopp (single-
hop) eller multihopp (multi-hop) agenter. I et enkelthopp agentsystem reiser en agent til 
en destinasjon og utfører sitt oppdrag der. Det er ingen mellomliggende noder agenten må 
reise gjennom. Etter oppdraget er utført sender agenten enten resultatet tilbake eller 
migrerer tilbake til utgangspunktet med resultatene. Hvis informasjon skal hentes fra 
andre noder i nettverket skjer dette ved separate operasjoner.  
 
 
Figur 3.10 Viser en multi-hop sti fra et utgangspunkt til en destinasjon går gjennom 
mellomliggenede noder  
 
Hvis en agent må forflytte seg over en eller flere noder for å nå sin destinasjon er dette et 
såkalt multihopp. I et multihopp agentsystem kan en agent også besøke flere 
destinasjoner, utføre sine operasjoner og akkumulere ett resultat. McDonald et al. 
beskriver i sin artikkel [49] hvordan resultatet som tilslutt kommer tilbake til 
utgangspunktet er et aggregat av resultatene fra to eller flere destinasjoner. I testsystemet 
jeg vil lage i forbindelse med denne oppgaven tar jeg sikte på å utvikle en kjøperagent 
som benytter seg av en reiseplan (itinerary) for å utføre multihopp migrasjon.  
 
I et agentsystem som benytter seg av multihopp forflyttninger er det en viss sjanse for at 
dette kan være en kilde til feil eller en sikkerhetsrisiko. I sin artikkel [50] peker Feldman 
og Chuang på at handlingene til de mellomliggende nodene i et slikt system vanligvis er 
skjulte. Dette betyr at den mellomliggende noden i verste fall kan unnlate å videresende 
en agent slik at denne aldri når sitt mål. Forfatterne sier videre at det er mer vanlig at den 
mellomliggende noden setter prioriteten for å videresende agenten meget lavt slik at det 
tar tid før den blir sendt videre og dermed oppstår en flaskehals i systemet. Feldman og 
Chunag evaluerer også ulike teknikker for å sikre at mellomliggende noder oppfører seg 
som forventet.  
 
 
     
 35 
3.3.4 TCP / IP 
 
Jeg vil nå se kort på Internet Protokollen (IP) siden denne protokollen er så sentral for 
hvordan et internett fungerer og ligger i bunn for forflyttningen av agenter mellom noder.  
 
3.3.4.1 Beskrivelse av protokoll  
 
IP er på mange måter det som har gjort Internett til hva det er i dag. IP oppstod i 
forbindelse med utviklingen av en protokoll for å muliggjøre kommunikasjon mellom 
flere maskiner på separate nettverk. IP var faktisk først kun en del av en annen 
nettverksprotokoll ved navn Transmission Control Protocol (TCP) og disse to 
protokollene benevnes ofte sammen som TCP/IP. De to protokollene ble senere formelt 
skilt fra hverandre [51].  
 
TCP er en transportprotokoll og hører til i det fjerde laget av OSI modellen og IP er en 
nettverksprotokoll. IPv4 er i dag den mest brukte nettverksprotokollen i internett. Det 
skal også legges til at det har vokst frem en deskriptiv standard rundt TCP/IP som 
beskriver en modell med fire lag og som er en forenkling av OSI modellen. Denne 
modellen er ikke ment å være noen offisiell referansemodell for utvikling av 
nettverkskommunikasjon på samme måte som OSI sin modell. Figur 3.11 viser hvordan 
denne modellen forholder seg til OSI modellen.  
 
 
 
 
 
     
 36 
Figur 3.11: En grafisk fremstilling av TCP/IP sett i forhold til OSI modellen 
 
 
3.3.4.2 IPv4 
 
IPv4 er den mest brukte nettverksprotokollen på Internett i dag. TCP/IPv4 ble til i 1981 
som følge av bred etterspørsel etter en nettverksprotokoll med et klart lagvis skille og 
uavhengighet fra den underliggende maskinarkitekturen. TCP/IPv4 ble meget populært i 
UNIX miljøer etter at University of Berkeley implementerte IPv4 i deres 4.2 BSD UNIX 
[52] og la ut kildekoden. Denne koden har senere vært gjenstand for en rekke 
forbedringer. 
 
IPv4 opererer med et 32 bit adresserom inndelt i klasser. Det finnes tre ulike klasser av 
adresser disse kalles A, B og C adresser. Det er 128 Klasse A nettverksnummer og ett 
klasse A nettverk kan inneholde 16 777 214 unike adresser. Det finnes 16 384 klasse B 
nettverksnummer og ett klasse B nettverk kan inneholde 65 534 unike adresser. Det 
finnes 2 097 152 klasse C nettverksnummer og ett klasse C nettverk kan inneholde 256 
unike adresser. Det finnes også en klasse D som er reservert for multicasting og en klasse 
E som er reservert for forskning. Til sammen utgjør dette teoretisk et adresserom på 2^32 
som tilsvarer over 4 milliarder unike adresser. Roberts og Challinor ser i sin artikkel [53] 
på bruken av nettverksnummer og påviser at kapasiteten ikke blir brukt fullt ut da mange 
adresser er låst til store nettverksnummer (klasse A) og ikke brukes innen organisasjonen 
som eier adresserommet. 
 
3.3.4.2.1 Mangler ved IPv4 
 
Siden Internet har vokst med en fart ingen på forhånd kunne forutse begynte man på 90 
tallet å slippe opp for ledige adresser. Dette er et problem som blir mer alvorlig for hver 
dag som nye noder tilsluttes Internet. Det var særlig introduksjonen av mobile enheter 
som mobiltelefoner, PDA, sensorer og andre ressurser som er ment å alltid være 
tilstedeværende (ubiqutous) som skaper problemer for IPv4. Denne mangelen på unike 
adresser som kan være en del av problemet i forhold til returnerende mobile agenter. På 
grunn av mangel på statiske IP adresser må adressene som tildeles mobile terminaler 
skiftes ut med en hyppig frekvens for eksempel når koblingen til nettverket blir brutt.  
 
3.3.4.2.2 Metoder for å øke adresserom (NAT) 
 
I dag benyttes flere teknikker for å øke antall adresser tilgjengelige i lokale nettverk. En 
mye brukt standard for å øke antall interne IP adresser kalles Network Address 
Translation (NAT). NAT kjøres på en router som er kontaktpunktet mellom et LAN og 
Internett. Ved bruk av NAT kan man nå flere noder i et LAN gjennom den samme IP 
adressen. NAT tar seg av å fordele pakker til den riktige maskinen etter at den har 
kommet til den offentlige eksponerte adressen. Bakdelen med å bruke NAT er at nodene 
bak NAT boksen er usynlige for omverdenen. De kan altså ikke kontaktes direkte eller 
forflyttes uten å miste sitt unike nettverksnummer. Dette er ett problem i forhold til 
     
 37 
mobile agent systemer og mobile terminaler som skifter miljø og aksesspunkt til 
nettverket.  
 
For mobile agentsystemer skaper NAT problemer når agenten skal returnere hvis verten 
den kom fra har byttet nettverksnummer som følge av at terminalen har skiftet lokasjon 
og nettverk eller at den har blitt slått av og på igjen. Hvis dette har skjedd har terminalen 
også skiftet sin nettverksadresse og agenten vil ikke lykkes i å komme tilbake med sine 
resultater til brukeren fordi den ikke vet hvor denne befinner seg. Resultatet av dette er at 
agenten blir liggende i en kø på en nærliggende node for så å bli destruert etter en gitt 
tidsperiode. 
 
3.3.4.2 IPv6 / IPnG 
 
IPnG (next generation) som også kalles IPv6 forsøker å bøte på noen av problemene med 
som ligger i strukturen til IPv4. Arbeid med IPnG startet i 1994 på initiativ av Toronto 
Internet Engineering Task Force (IETF). Det kom mange forslag til en ny standard 
protokoll og IPv6 i sin nåværende form er en sammensmelting av flere av disse.  
 
Visjonen med IPv6 var å konstruere en protokoll som kunne øke adresserommet, være 
optimal for både nettverk med stor båndbredde og trådløse nettverk med lite båndbredde 
samt inkludere nye sikkerhets og QoS (tjenestekvalitet) mekanismer. Med denne 
økningen av adresserommet vil det være mulig å tildele unike adresser til mobile 
terminaler uten å bruke teknikker slik som NAT.  
 
For at IPv6 skal bli en suksess er det meget viktig at denne versjonen av protokollen er 
kompatibel med den gamle versjonen. Det er urealistisk å tro at det vil være mulig med 
en overgangsperiode for så å gå til en fullstendig utskifting av software på millioner av 
noder tilknyttet Internett. Derfor har pakker under IPv6 den samme strukturen som 
pakker i IPv4 og det er utviklet metoder for å innkapsle IPv6 pakker inn i IPv4 omslag en 
såkalt ”wrapper” for så å sende denne gjennom en del av internettverket som fortsatt 
benytter IPv4. Denne løsningen inkluderer å oversette IPv6 adresser til IPv4 kompatible 
nettverksnummer.  
 
For å bøte på mangelen av adresser er IPv6 basert på Simple Internett Protocol Pluss 
(SIPP) som opererer med 128 bit adresser [54]. På denne måten er det mulig å tildele 
unike IP adresser til alle noder i internettverket og følgelig blir alle noder mulig å nå via 
sin adresse, såfremt noden ikke er slått av eller koblet fra. Selv i et scenario hvor noden er 
koblet fra er det tenkelig at det kan finnes en type lagringsplasser eller køer hvor pakker 
kan vente til destinasjonsnoden er klar til å motta. I forhold til mobile agenter vil dette 
bety at man har en høyere grad av garanti for at en agent vil komme tilbake til 
utgangspunktet hvor den oppsto og ble sendt ut. 
 
3.3.4.3 IP og mobile enheter 
 
Mobile enheter slik som bærbare maskiner som er koblet til et nettverk ved hjelp av et 
trådløst aksesspunkt benytter naturlig nok IP. Kanskje mer overraskende er det at også 
     
 38 
mobiltelefoner benytter Internett protokollen for å sende data, men gjør det hovedsaklig i 
skrivende stund via mellomledd. Selv om jeg har valgt i implementere mitt testsystem for 
en bærbar maskin eller en PDA kan et slikt system også være til stor nytte på en 
mobiltelefon. Det er mulig å implementere et slikt system på dagens mobiltelefoner, men 
det kreves at funksjonaliteten reduseres noe spesielt i forhold til bruk av Java. Jeg velger 
dog å ta med et overblikk over routing for mobiltelefoner da jeg mener dette kan gi et 
mer helhetlig bilde av routing i forhold til mobile agenter. 
 
3.3.4.3.1 GPRS / EDGE 
 
I dag tilbyr mange mobiltelefoner data I/O over CDMA eller GPRS nettverk. Teknologier 
som GPRS og EDGE er tillegg til GSM standarden som også kalles 2G – andre 
generasjon mobilkommunikasjon. Med disse tilleggene kalles nettverket ofte 2.5G. I 
disse typene nettverk benyttes dedikerte kanaler til kommunikasjon, kanalene er enten 
separate radio frekvenser eller tidsintervaller på kanalen dedikert til data og signalisering.  
 
For eksempel melder en mobiltelefon i ett GPRS nettverk sitt behov for en datakanal 
gjennom en protokoll kalt slotted-ALOHA, kanalen som brukes for å melde behovet 
kalles Packet Random Access Channel (PRACH). Mobiltelefonen melder sitt behov for 
en datakanal til en basestasjon. Basestasjonen svarer via Packet Grant kanalen (PAGCH) 
og tildeler mobiltelefonen en eller flere tidsintervaller på data kanalen som kalles Packet 
Data Trafic Channel (PDTCH). Den mobile enheten benytter så denne kanalen til å sende 
IP pakker (v4 eller v6) via en protokoll kalt Sub Network Dependent Convergence 
Protocol (SNDCP). Basestasjonen sender så denne pakken videre til den lokale pakke 
ruteren som kalles en Serving Gprs Support Node (SGSN). Denne noden sender den 
videre til en IP portal (gateway) for GPRS mer bestemt en Gateway GPRS Support Node 
(GGSN) og her kommer pakken inn i Internett [55]. Det er altså denne portalen (gateway) 
som er registrert med en IP adresse. Når så data kommer tilbake til mobiltelefonen fra 
Internett blir disse pakkene rutet til den samme GGSN som sendte pakker ut og derfra 
videre til den lokale pakke ruteren og videre til mobiltelefonen. Figur 3.11 viser en 
skjematisk fremstilling av GPRS arkitekturen.  
 
 
Figur 3.11: En skjematisk fremstilling av GPRS arkitekturen 
     
 39 
 
3.3.4.3.2 UMTS 
 
Flere mobiloperatører er nå i ferd med eller har allerede begynt å tilby tredje generasjons 
mobiltjenester (3G). Ryggraden i det nye systemet er en teknologi kalt Universal Mobile 
Telecommunication System (UMTS). UMTS nettverk vil kunne tilby en lang rekke nye 
tjenester og raskere dataoverføring en dagens nettverk kan. Med utskiftningen av nettverk 
er det også kommet forslag om overgang fra bruk av IPv4 til bruk av IPv6 adresser i dette 
nettverket [56]. Innenfor mobiltelefoni er en slik overgang et mulig scenario da dette vil 
være en betydelig enklere operasjon. Grunnen er at tallet på mobiloperatører i verden er i 
størrelsesorden av noen hundre i motsetning til millioner av rutere i dagens Internett. 
Keshav skriver i sin artikkel [57] om mobiltelefoner og Internet at det er ventet at i de 
nye 3G mobilnettverkene vil gjøre bruk av en ny infrastruktur kalt IP Multimedia 
Subsystem (IMS). Hovedkomponenten i denne infrastrukturen vil være IPv6 og alle 
enheter bli tildelt en unik IPv6 adresse. Dette vil være en stor fordel i forhold til routing 
av mobile agenter da en agent kan være sikker på å komme tilbake såfremt terminalen 
ikke er slått av. Det er også tenkelig at i et slikt nettverk hvor alle terminaler har en fast 
adresse kan det være en lagringsmekanisme knyttet til hver slik adresse. Dette kan 
fungere på lik linje med hvordan SMS og MMS meldinger lagres når en mobiltelefon er 
slått av og så sendes til telefonen når denne kommer tilbake på nettverket.  
 
Selv om mobiltelefoner kanskje er den mest vanlige mobile enheten finnes det mange 
andre. Herunder kommer mer utviklede mobiltelefoner også kalt Smartphones, PDA og 
selvfølgelig bærbare datamaskiner. De ovenfor nevnte teknologier er på nåværende 
tidspunkt interessante da de er spesielle for mobiltelefoner, men vil nok på sikt forsvinne 
ettersom mobiltelefonen og den bærbare datamaskinen blir mer like. Jeg tror det er 
rimelig å anta at utviklingen på dette området vil fortsette og at vi innen kun få år 
kommer til å se mobiltelefoner med både lagring og kapasitet for databehandling på linje 
med dagens bærbare datamaskiner.    
 
3.3.4.4 Mobile IP 
 
For andre mobile enheter slik som bærbare maskiner finnes det systemer for å tilby 
samme IP adresse i en mobil kontekst. En mye anvendt standard kalles Mobile IP. Mobile 
IP benytter to IP adresser, en hjemme adresse (Home IP) og en midlertidig adresse (Care-
of-address). Hjemmeadressen er konstant mens den midlertidige adressen endres ettersom 
den mobile terminalen forflytter seg. Denne standarden baserer seg på et agentsystem 
hvor det finnes en såkalt Home Agent som tar seg av registreringen av en mobil terminal 
sin faktiske adresse ettersom den forflytter seg [58]. Jeg vil komme nærmere inn på 
hvordan Mobile IP fungerer og dens styrker og svakheter i kapitlet som omhandler 
løsninger for mobilitet. 
 
 
 
 
 
     
 40 
3.3.4.5 To primære oppgaver innen routing 
 
Videre vil jeg kort se på de to hovedoppgavene innen routing. Disse oppgavene er: 
 
1: å etablere en optimal rute fra lokasjon A til lokasjon B 
 
2: å dele en informasjonsenhet opp i pakker og sende disse pakkene gjennom nettverket 
for senere å sette pakken sammen igjen når de har nådd sin destinasjon. 
 
3.3.4.5.1 Optimal rute 
 
Den første oppgaven i routing er å etablere den optimale ruten gjennom internettverket. 
Her støter vi straks på flere problemer. Å komme frem til den optimale ruten gjennom ett 
internettverk er ikke et trivielt problem. For å sette opp den optimale reiseplanen for en 
enkelt pakke må flere forhold tas i betraktning. Blant annet må det tas hensyn til trafikk 
gjennom noden(e) vi vil transportere pakken gjennom, båndbredde og antall hopp fra 
mellomliggende node frem til destinasjon. Det er her ett skille mellom typer av noder. 
Den ene typen noder kalles verter (hosts) som typisk er datamaskiner koblet til ett 
nettverk. Den andre typen kalles rutere og er egentlig verter som er dedikert til å tilby 
porter til andre nettverk, såkalte gateways (portaler). Det er vanlig at en vert ikke har 
kjennskap til mer enn et par forskjellige slike portaler. For å gjøre beregningen av den 
optimale ruten lettere å prosessere vedlikeholder de fleste nodene i ett nettverk en 
rutetabell (routing table) med ruteinformasjon. Denne informasjonen kan variere ettersom 
hvilken algoritme som benyttes. En node som er en vert og ikke fungerer som en router 
har typisk en kort og ukomplisert rutetabell mens en ruter kan holde tabeller som kommer 
opp i størrelser over 64 MB. Ruterne sender hverandre standardiserte meldinger slik at de 
kan oppdatere sine tabeller med jevne mellomrom. Det er mulig å fastslå ut fra disse 
rutetabellene om en node er mulig å sende en pakke til eller om den ikke er tilgjengelig. 
Hvis en mellomliggende node ikke er tilgjengelig er det mulig å dynamisk utarbeide en 
ny rute. Derimot hvis destinasjonsnoden ikke er mulig å nå vil det ofte resultere i at 
pakken(e) som sendes blir liggende i kø i nettverket og blir slettet etter en gitt 
tidsintervall.  
 
I forhold til en returnerende mobil agent kan det at en node ikke er tilgjengelig medføre at 
agenten slettes og alt arbeid den har utført for brukeren går tapt. I denne oppgaven vil jeg 
forsøke å utarbeide et forslag til en agentarkitektur som tar høyde for at noden som var 
utgangspunktet for agenten kan være uttilgjengelig. Jeg vil foreslå benytte en reiseplan 
som dynamisk bygges opp før den mobile agenten migrerer. Ruteplanen vil være et 
eksternt objekt som legges til den mobile agenten. Med rute mener jeg her en liste over 
destinasjoner agenten skal besøke og ikke nødvendigvis en eksakt rute gjennom Internett 
da den optimale ruten vil endre seg i sanntid. Denne fremgangsmåten er foreslått av blant 
annet Erfurth et al i deres artikkel om mobile agenter i dynamiske nettverk [59]. 
 
 
 
 
     
 41 
3.3.4.5.2 Packet switching 
 
Den andre hovedoppgaven innen routing er å dele opp meldingene i pakker som så 
sendes over et internettverk fra et utgangspunkt til en destinasjon. Pakkene kan ta 
forskjellige veier gjennom nettverket på vei til sin destinasjon. Når de når sin destinasjon 
settes pakkene igjen i sammen til den originale meldingen. Dette kalles gjerne packet 
switching.  
 
Switching er implementert med flere ulike algoritmer. Før en informasjonsmengde kan 
sendes ut over internettverket må den sendende noden finne den fysiske adressen, MAC 
adressen, til mottageren. Den sendende noden må dele opp informasjonsmengden den 
ønsker å sende i pakker og så legge disse pakkene inn i en slags virtuell konvolutt kalt en 
Frame. Denne konvolutten inneholder blant annet informasjon om hva som finnes inne i 
pakken og den fysiske adressen til destinasjonen for pakken. For å finne ut den fysiske 
adressen til destinasjonsnoden brukes ofte en Address Resolution Protocol (ARP) [60]. 
ARP tilbyr en dynamisk oversettelse av 32 bits IP adresser (IPv4) og maskinvareadresser 
som for eksempel en 48 bits MAC Adresse. Mange rutere i et internettverk tilbyr ARP 
tjeneste samt RARP som er reversert oversettelse fra maskinvareadresse til IP adresse. 
Figur 3.12 viser strukturen på en IP pakke.  
 
 
 
Figur 3.12: Skjematisk fremstilling av header struktur for en IP frame 
 
 
Når så en pakke reiser gjennom internettverket ser ruteren på header informasjonen i 
konvolutten pakken ligger inne i. Hvis pakken skal reise via flere mellomliggende noder, 
en inneholder konvolutten både IP adresse til destinasjonsnoden og fysisk adresse til den 
første ruteren. Hvis denne ruteren ikke vet hvordan den skal sende pakken til den 
endelige destinasjonen vil resultatet vanligvis være at pakken blir droppet, altså tapt. 
     
 42 
Derimot hvis ruteren vet hvordan den skal sende pakken endrer den destinasjonsadressen 
til neste hopp, som vanligvis er en ruter, og slik går det frem til pakken har kommet til en 
ruter som har direkte kontakt med destinasjonsnoden. Når dette inntreffer blir 
protokolladressen til destinasjonsnoden omgjort til en fysisk adresse. Avhengig av 
hvilken protokoll som benyttes til å sende pakken vil utgangspunktnoden få beskjed 
tilbake om sendingen av pakken var vellykket dette skjer i TCP, men ikke i UDP. 
 
En agent blir også delt opp på tilsvarende måte før den beveger seg over et nettverk. I 
forhold til JADE og Java baserte agenter så blir agenten serialisert, altså omgjort til en 
streng av bits før den deles opp og sendes over internettverket. Detaljene for hvordan 
dette skjer er avhengige av hvilken transportprotokoll som benyttes. 
 
3.3.4.6 Lokalisering av agenter i MAS 
 
Innenfor et fleragentsystem behøver agentene som lever der en måte å lokalisere andre 
agenter som tilbyr tjenester de ikke kan utføre selv. For å tilby denne funksjonaliteten er 
det foreslått flere ulike lokaliseringsmekanismer. Denne aktiviteten er en forutsetning for 
å kunne sette opp en rute for meldinger mellom agenter eller for en agent som skal 
migrere. I mitt testsystem kommuniserer en brukeragent med en Directory Facilitator for 
å finne lokasjonene til aktuelle selgeragenter. Disse lokasjonene utgjør så reiseplanen for 
kjøperagenten.  
 
Ben-Ami og Shehory har i sin artikkel [61] evaluert ulike former for 
lokasjonsmekanismer for agenter i fleragentsystem. De identifiserer to hovedtyper; den 
første er en sentralisert metode hvor en agent eller tilsvarende tilbyr 
lokasjonsinformasjon. De andre agentene kan gjøre spørringer mot denne agenter og 
registrere seg med sine tjenester. Dette er den mest brukte metoden og også den som 
JADE benytter seg av. Den andre hovedtypen av metoder er en peer-to-peer basert 
metode. Her holder hver agent en mindre liste over andre agenter og tjenestene disse 
tilbyr. Hvis en agent her ikke har en agent i sin liste som tilbyr den ønskede tjenesten 
sender den en melding til alle agenter i sin liste med spørsmål om å finne en agent som 
tilbyr rett tjeneste. De andre agentene ser så i sin liste og spør videre hvis de ikke kan 
svare, dette er en rekursiv metode. 
 
Ben-Ami og Shehory evaluerer de to metodene opp mot hverandre i forhold til store 
fleragentsystemer. De bemerker blant annet at metoden med en sentral enhet for 
lokasjonsinformasjon er sårbar for feil hvis denne noden krasjer og at den også kan være 
en flaskehals hvis det er veldig mange agenter i systemet.  
 
Jeg har i denne delen av teorikapitlet sett på begrepet routing. Jeg har sett på ulike 
protokoller for å sende en informasjonsenhet over ett internettverk og forsøkt å relatere 
dette til mobile agenter. I den siste delen av teorikapitlet vil jeg se på mobilitet som et 
generelt begrep. 
 
 
 
     
 43 
 
3.4 MOBILITET 
 
I dette kapitelet vil jeg se på begrepet mobilitet og forsøke å knytte dette opp mot 
problemstillingen i denne oppgaven. Jeg vil begynne med å gi en kort beskrivelse av 
problemområdet hvor jeg vil forsøke å ytterligere avgrense problemstillingen som denne 
oppgaven forsøker å løse. Jeg vil se på ulike typer mobilitet og relatere disse til 
agentsystemer og da spesielt i forhold til fleragentsystemer. Jeg vil klassifisere mobilitet 
inn i to hovedkategorier. Herunder vil jeg også komme inn på mobilitet som et mer 
generelt begrep hvor noden som beveger seg ikke nødvendigvis er endepunkt i et 
agentsystem. 
 
I forbindelse med drøftingen av mobilitetsbegrepet vil jeg presentere ulike publiserte 
løsninger. Jeg vil forsøke å klassifisere disse løsningene og gi eksempler på bruk. 
Klassifiseringen vil basere seg på hva slags type mobilitet løsningen adresserer og på 
hvilken måte løsningen er integrert inn i et agentsystem. 
 
Drøftingen av mobilitet vil bli strukturert på følgende måte: Først vil jeg presentere to 
hovedkategorier av mobilitet. I den forbindelse vil jeg gi en kort beskrivelse av hver av 
hovedtypene og ytterligere inndele disse i undertyper. Jeg vil så presentre ulike 
kategoriene av løsninger og gi en kort beskrivelse av karakteristiske egenskaper. Videre 
vil jeg forsøke å sammenligne de ulike kategoriene av løsninger ut fra deres generelle 
egenskaper. I forbindelse med hver kategori av løsning vil jeg presentere anvendt bruk i 
noe detalj og gruppere i forhold til klassifikasjonen nevnt ovenfor. Deretter vil jeg drøfte 
de ulike løsningene i forhold til den enkelte løsning sine styrker og svakheter. I den 
forbindelsen vil jeg se på hvilke spesifikke problemstillinger den enkelte løsningen har 
tatt sikte på å adressere. Jeg vil også komme kort inn standarder innen agentsystemer og 
da spesielt FIPA sin standard for mobilitet. 
 
Jeg vil i hovedsak konsentrere meg om løsninger hvor agenter og agentsystemer er i 
fokus selv om mobilitetsbegrepet har mye et videre bruksområde. Jeg er interessert i å se 
på problematikken rundt generell mobilitet av noder og transport av binær data over 
heterogene nettverk. I forhold til dette er jeg spesielt interessert i å undersøke løsninger 
for fleragentsystem som inneholder mobile agenter. Noen av mobilitetsløsningene jeg vil 
presentere er særegne for agentsystemer mens andre løsninger er av en mer generell art. 
 
3.4.1 Typer mobilitet 
 
Fiege et al de beskriver i sin artikkel [62] tre typer mobilitet: 
 
• Fysisk: Fysisk mobilitet betegner hendelser hvor brukeren kobler seg fra et 
aksesspunkt og kobler seg til et annet. 
 
• Logisk: Logisk mobilitet inntreffer når en bruker beveger seg for eksempel fra ett 
rom til et annet, men fortsatt er koblet til det samme aksesspunktet. 
 
     
 44 
• Kode mobilitet: Kode forflyttes fra en maskin til en annen og eksekveres på den 
nye maskinen. 
 
3.4.1.1 Terminalmobilitet 
 
I forhold til mobilitet i agentsystem er jeg mest interessert i den første kategorien og den 
tredje kategorien. Videre i denne oppgaven vil jeg referere til den første typen mobilitet 
som terminalmobilitet og den andre som kodemobilitet. Hovedvekten av denne 
teorigjennomgangen vil dreie seg om løsninger for kodemobilitet.  
 
Wang Q. og Abu-Rgheff identifiserer i sin artikkel [63] to hovedaktiviteter innenfor 
terminalmobilitet: 
 
• lokasjons kontroll (location management) 
 
• avleveringskontroll (handoff management).  
 
I forhold til en mobil agent som har oppstått og hører hjemme på en mobil terminal er 
spesielt lokasjonskontroll viktig. Det er jo nettopp denne lokasjonen den mobile agenten 
behøver å vite for å kunne returnere til sitt utgangspunkt. Allikevel er begge disse 
begrepene er aktuelle i forhold til mobile agenter. Jeg vil nå gi en kort beskrivelse av 
begge. 
 
Det skilles gjerne mellom to typer terminalmobilitet; makro og mikromobilitet. Disse 
typene mobilitet kalles også inter-domain mobility og intra-domain-mobility. Et domene 
regnes her som en type nettverk. Når en terminal streifer utenfor sitt nettverk og kobles til 
et nytt kalles det makromobilitet. Når en terminal beveger seg innenfor sitt administrative 
nettverk kalles dette mikromobilitet. Figur 3.13 fremstiller forskjellen mellom de to 
typene mobilitet.  
 
 
     
 45 
 
Figur 3.13: Intra-domain og Inter-domain routing 
 
3.4.1.1.1 Lokasjonskontroll 
 
Lokasjonskontroll består av to hovedoppgaver; lokasjonsregistrering og samtalelevering 
(call delivery). Den første av oppgavene består hovedsaklig i at den mobile terminalen 
med jevne mellomrom oppdaterer en lokasjonsdatabase med sin nåværende posisjon. 
Samtalelevering består så av to trinn, det første er å finne lokasjonsdatabasen som tjener 
den aktuelle mobile terminalen og den andre er å finne riktig subbnett innenfor den 
terminalen sitt registreringsområde. Det siste trinnet kalles også paging og består av at vi 
sender forespørsler til alle subbnett innenfor registreringsområdet. 
 
3.4.1.1.2 Avleveringskontroll 
 
Avleveringskontroll er navnet på prosessen som holder en mobil terminal sin kobling 
aktiv når den beveger seg fra et tilkoblingspunkt til et annet. Avlevering kan være 
innenfor det samme systemet og kalles da en horisontal avlevering eller det kan være 
mellom heterogene nettverk og kalles da vertikal avlevering. Denne delen av 
mobilitetsbegrepet ligger litt utenfor hovedfokus i min oppgave og jeg vil derfor ikke 
komme nærmere inn på problemstillinger knyttet til Avleveringskontroll. Jeg nøyer meg 
med å forutsette at denne prosessen skjer transparent for agentsystemet og blir tatt hånd 
om av et lavere lag i nettverksmodellen. 
 
3.4.2 Løsninger for terminalmobilitet 
 
Jeg vil nå se på noen anvendte løsninger for terminalmobilitet. Jeg vil forsøke å 
kategorisere løsningene etter hvilket lag av OSI modellen de hører hjemme i. 
 
Jeg vil begynne med å presentere en kort oppsummering av utviklingen av 
mobilitetskontroll innen mobiltelefonnettverk. Løsningene som her blir presentert er 
     
 46 
linklagsløsninger, det vil si at hører hjemme på linklaget av OSI modellen. Dette 
innebærer at disse løsningene er bundet til den enkelte aksessteknologien de er laget for. 
Denne typen mobilitetsløsninger blir også kalt aksessmobilitet eller linklagsmobilitet. 
  
Helt siden den andre generasjonen av mobiltelefonnettverk (2G) har det eksistert 
løsninger for terminalmobilitet. Under GSM registrerte de mobile terminalene sin 
posisjon i Home Location Registers (HLR). Under dette systemet oppdaterte den mobile 
terminalen sin posisjon ved å sende Mobile Application Messages (MAP) til en HLR 
hver gang når den krysset grensene for et lokasjonsområde; en avgrenset celle innenfor et 
større regionalt område. I 2.5G nettverk rapporterte de mobile terminalene sin posisjon til 
sin HLR gjennom Serving GPRS Support Node (SGSN). Under 2.5G systemer ble det 
mulig med mer finkornet lokasjonsbestemmelse. Både under 2G og 2.5G var 
mobilitetskontroll begrenset til terminalmobilitet og knyttet til linklaget. 
 
I 3G nettverk under UMTS rapporter de mobile terminalene sin posisjon gjennom en 
kombinasjon av SGSN og GGSN (Gateway GPRS Support Node). UMTS støtter i likhet 
med GPRS global terminalmobilitet, men disse mobilitetsløsningene er som tidligere 
nevnt knyttet opp til bestemte aksessteknologier. For eksempel så har ikke 3G nett en 
enkelt type aksesstandard, den består av tre radio standarder; cdma2000, EDGE og 
WCDMA [64]. Det er høyst sannsynlig at dagens og fremtidens brukere av 3G nettverk 
vil ha et ønske om også å benytte seg av andre aksessteknologier som for eksempel 
WLAN løsninger slik som IEEE 802.xx, Bluetooth eller kabelaksesspunkter. Derfor ble 
det i forbindelsen av utviklingen av den tredje generasjonen av mobilkommunikasjon 
(3G) introdusert flere forslag til løsninger for en uavhengig standard for 
terminalmobilitet. Mobile IP ble blant annet fremlagt som et forslag til en 
mobilitetsprotokoll for makromobilitet. Kombinasjonen av en SGSN og en GGSN er blitt 
integrert i en node og kan nå fungere som en såkalt hjemmeagent for den mobile noden. 
Jeg vil komme nærmere inne på hva en hjemmeagent er når jeg nå skal beskrive Mobile 
IP.   
 
3.4.2.1 Mobile IP 
 
Mobile IP (RFC 2002) er en standard som ble lagt frem av en gruppe innenn Internet 
Engineering Task Force (IETF). Målet med standarden var å tillate at en mobil node 
kunne ha 2 IP adresser, en fast hjemmeadresse og en midlertidig adresse [65]. Poenget 
med å ha to adresser er at det skal være mulig for mobile terminaler å streife gjennom 
forskjellige nettverk og koble seg til ulike kontaktpunkt, men fortsatt være kontaktbare 
via sin statiske IP adresse.  
 
Mobile IP hører hjemme på nettverkslaget i til OSI modellen i motsetning til 
mobilitetsløsningene i GPRS og UMTS som er linklagsløsninger. Løsningen er ment å 
gjøre mobilitets funksjonalitet transparent for høyere protokoller som TCP. Hvis en mobil 
terminal skal kunne opprettholde transportlagkoblinger må den beholde den samme IP 
adressen selv om den flytter seg inn i nye nettverk. I forhold til en mobil agent er dette en 
aktuell problemstilling når en mobil agent skal returnere til den mobile terminalen hvor 
dens hjemmeplattform kjører. Forutsatt at terminalen er på og har kontakt med 
     
 47 
internettverket kan den ha forflyttet seg og ha skiftet domene, men får fortsatt levert 
meldinger som sendes til den originale IP adressen. På denne måten kan den mobile 
agenten navigere tilbake til sitt utgangspunkt for så å bli videresendt til terminalen sin 
nåværende fysiske posisjon.  
 
Mobil IP er i seg selv et system som gjør bruk av agenter. Mobile IP opererer med tre 
hovedenheter: 
 
• Den mobile noden 
 
• to forskjellige agenter: 
  
o Hjemmeagent (home agent) 
  
o Fremmedagent. (foreign agent) 
 
 
Den mobile noden er koblet til en hjemmeagent og denne hjemmeagenten holder nodens 
statiske IP adresse. Hjemmeagenten er ansvarlig for å levere alle pakker sendt til noden 
når denne ikke befinner seg i sitt hjemmenettverk. Når den mobile noden forflytter seg 
utenfor sitt hjemmenettverk melder den fra til sin hjemmeagent om sin nye adresse, 
denne adressen kalles en care-of-adress. Den mobile noden blir gjort oppmerksom på at 
den har beveger seg inn i et nytt subbnett av en fremmedagent tilhørende dette nettverket. 
Den mobile noden kan så få en ny adresse på ved å lytte til meldinger sendt av 
fremmedagenten en slik adresse kalles en fremmedagent adresse. Alternativt kan noden 
få en adresse ved å kontakte den lokale DHCP (Dynamic Host Configuration Protocol) 
kontrolleren eller PPP (Point-to-Point Protocol), en slik adresse kalles en 
forhåndsklargjort adresse. Når så hjemmeagenten får den midlertidige adressen oppretter 
den en binding mellom den statiske og den midlertidige adressen slik at pakker som 
sendes til hjemmeadressen kan videresendes til den midlertidige adressen. 
 
Alle pakker som sendes til den mobile noden blir nå fanget opp av hjemmeagenten og så 
kapslet inn med den nye adressen og så send videre. Selve innkapslingen tar gjerne for 
som en ny IP pakke. Denne operasjonen kalles ofte tunneling siden den faktiske 
datapakken som sendes ikke er synlig for nettverket der den beveger seg fra tunnelens 
åpning til sluttpunkt. Hvis den midlertidige adressen er en fremmedagent adresse fanger 
fremmedagenten opp pakken, fjerner innkapslingen og pakken blir sendt videre til den 
mobile noden. Hvis den midlertidige adressen er en forhåndsklargjort adresse sendes 
pakken direkte til den mobile noden som selv fjerner innkapslingen. Figur 3.14 viser en 
skjematisk fremstilling av Mobile IP og bruken av agenter. 
 
     
 48 
 
 
Figur 3.14: Viser hvordan en mobil node har forflyttet seg fra sitt hjemmenettverk over 
til et annet nettverk. Når en korresponderende node ønsker å sende en melding til den 
mobile noden skjer dette gjennom en virtuell tunnel mellom hjemmeagenten og 
fjernagenten som så leverer meldingen til den mobile noden. 
 
3.4.2.1.1 Svakheter ved Mobile IP 
 
Mobile IP har flere svakheter, hvorav den største er at protokollen ikke er effektiv. Alle 
pakker som sendes fra en korresponderende node til den mobile node må gå gjennom 
hjemmeagenten. Denne ”treveis” ruten er ofte betraktelig lengre enn hva den hadde vært 
hvis den sendende noden kunne rute sine pakker direkte til den mobile agenten eller dens 
nærmeste fremmedagent. Når en mobil node skifter nettverk og fremmedagent kan ikke 
den nye fremmedagenten informere den gamle om sin adresse. Følgelig blir alle pakker 
som er sendt til den gamle fremmedagenten tapt. I tillegg til dette har Mobil IP potensial 
for å skape svært mye nettverkstrafikk hvis terminalen skifter nettverk ofte og hver gang 
oppdatere sin lokasjon hos hjemmeagenten selv om den ikke kommuniserer med andre 
noder. Akyildiz et al. viser i sin artikkel [66] at dette kan føre til mye trafikk spesielt om 
det er lang distanse mellom den mobile noden og hjemmeagenten. Figur 3.15 viser den 
triangulære ruten som oppstår under Mobile IP. 
 
     
 49 
 
 
Figur 3.15: Viser den triangulære ruten som oppstår ved bruk av mobile IP 
 
3.4.2.1.2: Utvidelser, oppdatering av Mobile IP 
 
Det er kommet flere utvidelser og forbedringer av Mobile IP, blant annet en forbedret 
algoritme for routing av pakker fra en node til en mobil terminal. Perkins og Johnson [67] 
har tatt for seg denne algoritmen og forklarer at ideen er at en pakke fra den sendende 
noden skal gå direkte til den mobile terminalen. Når en node skal sende en pakke til en 
mobil terminal sjekker den først om den har en midlertidig adresse for den mobile 
terminalen. Hvis den har det sender den pakken direkte dit, hvis den ikke har adressen 
sendes pakken på vanlig måte til hjemmeagenten. Når hjemmeagenten mottar en pakke 
og sender denne videre til den mobile terminalen sender den samtidig en melding tilbake 
til den sendende noden slik at denne kan oppdatere sin binding og sende neste pakke 
direkte. Alternativt kan den sendende noden oppdage at den mobile terminalen har skiftet 
adresse ved at fremmedagenten i nettverket noden forsøkte å sende pakken til signaliserer 
at den mobile terminalen ikke finnes der lenger. Hvis dette skulle skje vil pakken som ble 
sendt feil ikke være tapt slik som i den originale protokollen. Grunnen er at når den 
mobile terminalen kobler seg til en ny fremmedagent gir denne beskjed til den gamle 
fremmedagenten om å videresende alle pakker. 
 
3.4.2.1.2.1 HAWAII 
 
Mobile IP er i dag den dominante løsninger for makromobilitet, men det finnes flere 
konkurrerende løsninger for mikromobilitet. Jeg vil se på to av de andre publiserte 
forslagene; HAWAII og CellularIP.  
 
Selv om Mobile IP ble mer effektiv etter utvidelsene og ved at fremmedagenten som blir 
skiftet ut kan videresende pakker til den nye fremmedagenten er protokollen fortsatt ikke 
ideell for mikromobilitet. Grunnen til dette er at hver gang den mobile terminalen 
beveger seg og skifter aksesspunkt må hjemmeagenten oppdateres med den nye adressen. 
 
     
 50 
Handoff Aware Wireless Access Internet Infrastructure (HAWAII) er en konkurrerende 
protokoll for mikromobilitet. Under HAWAII beholder den mobile terminalen sin 
nettverksadresse ettersom den beveger seg gjennom et administrativt nettverk. 
Hjemmeagenten og andre noder i dette nettverket er ikke oppmerksomme på at 
terminalen beveger seg.  
 
I denne protokollen utføres all mobilitetskontroll av en domain root router (DRR). Denne 
ruteren er ansvarlig for å sette opp og oppdatere en spesiell sti til hver mobile terminal, 
den gjør dette ved å oppdatere videresendingstabellen (forward table) hos selekterte 
rutere i domenet med angivelse av sti til den mobile noden (host based path entries). 
HAWAII benytter seg av Mobile IP som standard for mobilitet mellom domener (inter-
domain). I forhold til Mobile IP reduserer HAWAII nettverkstrafikk når den mobile 
terminalen beveger seg innenfor et domene (intra-domain). HAWAII begrenser antallet 
lokasjonsoppdateringer som må sendes til hjemmeagenten og reduserer dermed 
nettverkstraffiken.  
 
Når den mobile terminalen beveger seg er det kun ruten fra DRR til det nærmeste 
aksesspunktet som må oppdateres. Ramjee et al. Nevner i sin artikkel om HAWAII [68] 
at et problem med denne protokollen er at rutere støtter et begrenset antall nedtegnelser 
av vertsadresser i sine videresendingstabeller. Hvis det finnes for mange terminaler i 
domenet vil det ikke være mulig å opprettholde korrekt sti til alle. Forfatterne mener dette 
kan løses ved å være nøye med å angi riktig størrelse på et domene og benytte seg av en 
restriktiv strategi for hvilke rutere som blir oppdatert når en terminal bytter basestasjon 
innefor domenet.  
 
3.4.2.1.2.2 CellularIP 
 
Cellular IP (CIP) som beskrevet av Valkó [69] er en konkurrerende løsning for 
mikromobilitet. I likhet med HAWAII forutsetter den bruken av Mobile IP eller en 
tilsvarende løsning for makromobilitet. CIP nettverk er koblet til Internett gjennom en 
portal (gateway). Pakker som skal til en mobil terminal kommer til denne portalen først. 
Portalen finner så frem til terminalen og leverer pakken. CIP benytter seg av et distribuert 
lager for å holde rede på lokasjonen til hver mobile terminal innenfor domenet. En mobil 
node signaliserer til portalen at den har beveget seg og byttet aksesspunkt ved hjelp av 
vanlige IP pakker. Alle mobile terminaler sender slike pakker med jevne mellomrom. Når 
en mobil terminal beveger seg innenfor et CIP nettverk oppdateres lokasjonen automatisk 
innad i nettverket og denne prosessen er helt transparent for noder utenfor nettverket som 
kun forholder seg til portalen.  
 
3.4.2.1.2.3 Andre løsninger 
 
Det finnes flere løsninger på for terminal mobilitet utover de to jeg har nevnt her. 
Campbell og Gomez nevner i sin gjennomgang av protokoller for mikromobilitet [70] for 
eksempel protokoller som baserer seg på en hierarkisk nettverksstruktur. Slike løsninger 
kalles gjerne hierarkiske mobilitetsløsninger. Tanken bak disse er å redusere trafikk til 
hjemmeagenten ved å innføre to midlertidige adresser. En global adresse som er til en 
     
 51 
portal som betjener flere lokale nettverk og en lokal adresse innenfor nettverkene som 
kan nås fra denne portalen. På den måten vet ikke hjemmeagenten til den mobile 
terminale den virkelige midlertidige adressen, men sender i stedet pakker til portalen. 
Portalen videresender så disse pakkene til den lokale midlertidige adressen. Når så 
terminalen beveger seg mellom nettverk som kan nås fra portalen oppdateres kun den 
lokale midlertidige adressen, hjemmeagenten er helt uvitende om dette. Slik reduseres 
nettverkstrafikk og distansen pakker må reise for å nå en mobil terminal.   
 
3.4.3 Kodemobilitet. 
 
Den andre hovedtypen mobilitet, kodemobilitet, har oppstått i forbindelse med utvikling 
av distribuerte systemer. Det finnes forskjellige typer kodemobilitet og to av de viktigste 
formene er: 
 
• Remote EValuation (ROV)  
 
• Code On Demand (COD).  
 
Forenklet sett kan man si at Under ROV overfører klienten kode til en tjener som 
eksekverer denne og returnerer et resultat til tjeneren mens under COD kan en klient 
hente den koden den behøver for å utføre en oppgave. I situasjoner hvor disse typene 
kodemobilitet eller bruk av Remote Procedure Call (RPC) / Remote Method Invocation 
(RMI) baserte teknologier er usikre eller skaper for mye nettverkstrafikk kan det å flytte 
kode til en eksekverende enhet være løsningen.  
 
RPC er en mye brukt teknikk for å bygge distribuerte systemer. Under RPC gjør en klient 
et kall til en prosedyre (funksjon / metode) som om denne skulle vært lokal selv om den 
eksisterer på en fjern node. Kallet er som et normalt prosedyrekall hvor argumenter 
sendes inn og resultat kommer tilbake. Forskjellen ligger i at kallet sendes over nettverket 
til noden som har koden til prosedyren og så sendes resultatene av eksekvering av denne 
prosedyren tilbake igjen til klienten. Java RMI er den objektorienterte versjonen av RPC.  
   
Hvis både kode og tilstand (state) flyttes over til en fjern node er vi inne på det mobile 
agent designparadigmet. Her flyttes den eksekverende enheten over til noden hvor arbeid 
skal utføres og dette resulterer i en gevinst i form av redusert sjanse for tap av data og 
redusert nettverkstrafikk. Fuggetta et al. forsøker i sin artikkel [71] å etablere en felles 
taksonomi og begrepsforståelse innen kodemobilitet. Jeg vil basere meg på deres 
inndeling og navngiving i min beskrivelse av dette emnet. Forfatterne av denne artikkelen 
innfører blant annet begrepene sterk mobilitet, svak mobilitet og eksekverende enhet. Jeg 
velger å referere til en eksekverende enhet som en agent i denne oppgaven.   
 
3.4.3.1 Sterk mobilitet 
 
Sterk mobilitet refererer migrasjon av både kode og eksekveringstilstand, med 
eksekveringstilstand menes verdi på instansvariabler, programteller og 
eksekveringsstabel (stack). I systemer som tilbyr sterk mobilitet kan en agent avbryte sin 
     
 52 
eksekvering på en node og migrere til seg til en annen og fortsette eksekvering der.  
 
Det kan være flere grunner til at det er ønskelig å forflytte både kode og tilstand. For 
eksempel kan dette være en form for sikkerhetsmekanisme hvis en node er i ferd med å 
skru seg av eller bli overbelastet. I slike tilfeller kan agenten bevege seg til en node hvor 
det er ressurser tilgjengelige slik at den kan sluttføre sitt oppdrag. Sterk mobilitet er 
muliggjort gjennom to mekanismer; migrasjon og kloning. 
 
I migrasjonsfasen blir eksekveringen av en agent fryst og både agenten og 
eksekveringstilstand blir gjort klar til å sendes til en fjern node. For eksempel hvis det er 
snakk om en agent implementert i Java er det sannsynlig at den blir serialisert før den 
sendes over nettverket. Når en agent eller et objekt serialiseres gjøres det om til en streng 
av bits som senere kan rekonstrueres. Systemet overfører så den klargjorte agenten til den 
fjerne noden. Når agenten når sin destinasjon begynner kloningsfasen. I denne fasen 
gjenskaper den fjerne noden agenten og dens eksekveringstilstand samt setter opp de 
ressursene som kreves for at agenten skal kunne utføre sitt oppdrag. På denne måten kan 
en agent fortsette sitt arbeid fra det punkt hvor den ble avbrutt. I følge Carzaniga et al. 
[72] kan både migrasjon og kloning følge et reaktivt eller aktivt (proactive) mønster. Det 
vil si at både migrasjon og kloning kan initieres av agenten selv eller utløses av eksterne 
faktorer. Eksterne faktorer kan her for eksempel være at noden agenten for øyeblikket 
kjører på er i ferd med å bli overbelastet. 
 
3.4.3.2 Svak mobilitet 
 
Svak mobilitet er migrasjon av kode og i noen tilfeller data. Hvis data overføres er det 
gjerne for å rekonstruere innstanse variabler agenten holdt når den skulle migrere til den 
fremmede noden. Tilstedeværelsen av data som brukes til rekonstruksjon må ikke 
forveksles med det komplette bildet av en agent og dens eksekveringstilstand som 
overføres mellom systemer som støtter sterk mobilitet. En agent som forflyttes ved i et 
system med svak mobilitet kan ikke stoppe eksekvering midtveis i en operasjon for så å 
fortsette når den når den nye noden. 
 
Svak mobilitet kan innebære en forflyttning av hele eller deler av kodegrunnlaget for en 
agent. Deler av kodegrunnlaget kan forflyttes for å utføre en del av jobben agenten er satt 
til. Alternativt kan hele kodegrunnlaget forflyttes slik at agenten i sin helhet initieres på 
den fremmede noden. Selve forflyttningen av kode kan initieres fra både den lokale og 
den fjerne noden. Den fjerne noden kan hente kode, dette kalles Code fetching. 
Alternativt kan den lokale noden sende kode til en fjern node, dette kalles Code shipping.  
 
De fleste agentsystemer som er implementert i Java støtter kun svak mobilitet. Grunnen 
til dette er at eksekveringsmodellen til Java ikke tillater at en agent har tilgang til 
programtelleren eller kjøretidsstabelen. Siden de fleste agentsystemer er skrevet i Java 
betyr dette at det finnes få systemer som tilbyr sterk mobilitet. Det finnes dog noen 
systemer som enten benytter seg av en modifisert virtuell maskin (VM) eller som endrer 
Java sin kompileringsmodell. Av eksempler på den første kategorien kan nevnes 
JavaThread, D’Agents, Sumatra, Merpati og Ara. CIA prosjektet benytter seg av en 
     
 53 
modifisert versjon av Java Platform Debugger Architecture for å realisere sterk mobilitet. 
Chakravarti et al. beskriver i sin artikkel [73] et forslag til hvordan sterk mobilitet kan 
implementeres for flertrådede agentsystemer skrevet i Java. Deres grunnleggende tanke er 
at hver eksekveringstråd holder en referanse til en serialiserbar versjon av sin 
eksekveringstilstand til enhver tid. På denne måten kan eksekveringstilstanden 
serialiseres samtidig som agenten og sendes over til en annen node.  
 
3.4.3.3 Klassifisering av løsninger for kodemobilitet 
 
Jeg vil nå forsøke å klassifisere ulike løsninger for kodemobilitet. Her finnes det ingen 
fast avgrensning mellom makro/mikromobilitet eller ulike løsningstyper. Jeg vil forsøke å 
klassifisere de ulike løsningene ut fra hvor mobilitetsaspektet passer inn i et agentsystem 
sin arkitektur. I hvilken grad løsningen er sammenkoblet eller avskilt fra agentsystemets 
øvrige funksjonalitet. Jeg har valgt å bruke tre hovedkategorier: 
 
3.4.3.3.1 Plattformbasert 
 
Løsninger som passer i denne kategorien er i stor grad sammenvevd med den enkelte 
agentplattformen. Denne koblingen kan være manifestert som mobilitetsmoduler 
spesifikke for agentsystemet eller på annen måte være en integrert del av mobile agenter 
og miljøet de opererer i. Denne typen kodemobilitet ligger nært opp til hva FIPA kaller 
en simpel mobilitetsprotokoll. Agentplattformen er ansvarlig for å implementere all 
funksjonalitet som har å gjøre med mobilitetskontroll. Agentplattformen eksponerer så 
noen metoder som agenter i dette systemet kan benytte hvis de ønsker å migrere til eller 
klones på en fjern node.  
 
Alle mobile agenter og deres interne logikk vil nødvendigvis måtte inneholde kall til 
agentplattformen sine mobilitetsfunksjoner. Styrken til denne typen løsning med 
kodemobilitet er at den reduserer kompleksiteten i utviklingen av agenter. Når en agent 
skal utvikles behøver man ikke ta noen hensyn til mobilitet bortsett fra å benytte de ferdig 
definerte mobilitetsfunksjonene fra agentplattformen. Når mobilitet styres direkte av 
agentplattformen medfører dette også mindre nettverkskommunikasjon sett i forhold til 
integrerte løsninger hvor agenten må kommunisere med seg selv for å være sikker på at 
forflyttning og rekonstruksjon har gått etter planen. Bakdelen med denne typen løsning er 
at den gjør utviklingen av agentplattformen mer komplisert. Plattformen er ansvarlig for 
all kontroll av mobilitet og må implementere funksjonalitet for dette.     
 
JADE inneholder en agentplattform som er bygget etter FIPA sine spesifikasjoner for 
agentsystemer. Plattformen er skrevet i Java og det er muligheter for å kunne distribuere 
en agentplattform samt å kjøre plattformen på en terminal med begrenset kapasitet ved 
hjelp av en omskrevet kjerne kalt LEAP. JADE tilbyr svak mobilitet ved serialisering av 
objekter slik som andre agentsystemer skrevet i Java. Hvis det er ønskelig med sterk 
mobilitet er dette helt opp til utvikleren og må implementeres separat. 
 
I JADE er mobilitetsfunksjonalitet bygget inn i plattformen. En plattform kan spres over 
flere maskiner og hver av disse representerer en container som agenter kan leve i. 
     
 54 
Agenter kan migrere mellom containere, de kan klones mellom containerer, men kan ikke 
migrere til et fremmed agentsystem. Grunnen til dette er at det ennå ikke finnes noen god 
standard for hvordan slik interaksjon mellom ulike plattformer skal foregå. Det er også en 
begrensing i denne versjonen av Jade at en agent kan bare migrere innenfor en plattform, 
altså intraplattform (intra-platform). Med den nye versjonen av Jade som blir sluppet i 
begynnelsen av Februar 2006 er det implementert interplattform (inter-plattform) 
mobilitet via ACL meldinger.  
 
Agenter som vil migrere i JADE kan selv initiere forflyttningen eller de kan be 
plattformen om å forflytte seg. Funksjonalitet for migrasjon eller kloning er ligger i 
plattformen og kall til disse metodene er spredt ut over alle klasser og roller som skal 
være mobile. For å initiere migrasjon av en agent kalles metoden doMove() og for å klone 
kalles metoden doClone() [74]. Alle klasser som skal kunne forflytte seg må gjøres 
serialiserbare. JADE benytter seg av FIPA sin mobilitetsontologi.  
 
AGLETS rammeverket ble utviklet av IBM og er i likhet med JADE et Java basert 
agentsystem. Også i dette systemet baserer man seg på at mobilitetsfunksjonalitet tilbys 
av agentplattformen. Agenter i AGLETS rammeverket arver metoder av Aglets klassen 
og blir i denne forbindelsen også gjort serialiserbare. Mobilitet under denne plattformen 
er realisert ved serialisering av objekter. Aglets kan forflytte seg over et nettverk på en av 
to måter; de kan enten bli sendt over til en fjern vert ved å kalle dispatch() eller de kan 
hentes tilbake fra en vert ved å kalle retract(). 
 
Skaperne av Aglets inkluderte flere designmønstre i den første utgivelsen av 
rammeverket. Blant disse var det flere reisemønstre som Itinerary, Ticket og Forward. 
Under itinerary mønsteret skilles agentens reiseplan fra resten av agentens kode og legges 
i et objekt som kalles en Itinerary [75]. Dette objektet holder en liste over lokasjoner den 
mobile agenten skal besøke, hva den skal gjøre i spesielle situasjoner som når en vert 
ikke eksisterer og kan alltid si agenten hvor den skal bevege seg ved neste forflyttning.  
 
3.4.3.3.2 Integrert 
 
Denne kategorien er for løsninger som ikke har en sterk kobling til agentplattformen. 
Løsninger i denne kategorien ligger nært opp til det FIPA kaller en fullverdig 
mobilitetsprotokoll. Disse løsningene lar agenten selv være ansvarlig for de fleste 
aspektene ved mobilitetskontroll.  
 
Agentene både implementerer og gjør bruk av mobilitetsfunksjonalitet. Når mobile 
agenter som benytter denne typen mobilitet forflytter seg til en annen agentplattform tar 
de også med seg all mobilitetsfunksjonalitet og kan fortsette å benytte seg av denne 
uavhengig av hva slags type mobilitet agentplattformen de har forflyttet seg til støtter. 
Fordelen med denne typen mobilitetsløsning er at den reduserer kompleksiteten i 
utvikling av agentplattformen da denne ikke behøver å ta hensyn til mobilitet i like stor 
grad som for de plattformbaserte løsningene. Dette medfører da nødvendigvis en mer 
komplisert utvikling av mobile agenter og gjentakelse av kode som har å gjøre med 
mobilitet. Dette fører igjen til at størrelsen på agentene vokser og det kan være en kilde til 
     
 55 
problem når disse skal forflyttes over nettverk, særlig hvis tilgangen til nettverk er sen 
eller ustabil.  
 
Denne formen for agentmobilitet kan være et sikrere alternativ til en plattformbasert 
løsninger hvis den følger FIPA anbefalingen som dikterer at agenten først må sjekke at alt 
har gått bra med migrasjon og rekonstruksjon før agenten sin identitet og kontroll 
overføres til det fremmede agentsystemet.     
 
Jeg har ikke funnet noen eksempler på agentsystem som benytter en full 
mobilitetsprotokoll slik som den er beskrevet av FIPA. 
 
3.4.3.3.3 Ekstern  
 
Disse løsningene er som navnet tilsier eksterne for både agenten og agentplattformen. 
Løsninger fremstår som en egen og uavhengig del av agentsystemet. Denne 
løsningstypen er karakterisert av at den skiller applikasjonsspesifikk logikk og kode fra 
logikk og kode relatert til mobilitetsaspektet. Styrken ved denne typen løsninger kan være 
at den reduserer kompleksiteten i et agentsystem siden den skiller ut 
mobilitetsfunksjonalitet fra resten av systemet. En annen positiv effekt av ett slikt skille 
kan være redusert mengde med kode siden kall assosiert med bevegelse av agenter ikke 
behøver å gjentas i for alle mobile agenter i systemet.  
 
Eksterne løsninger viderefører kjente designprinsipper fra objektorienterte systemer hvor 
man søker å skape klart definerte moduler som kun samarbeider gjennom veldefinerte 
grensesnitt. På den måten øker man mulighetene for å utvide funksjonalitet på ett område 
uten å måtte gjøre store endringer i hele systemet. På samme tid øker man også sjansen 
for at de ulike komponentene kan brukes på ny i andre systemer. I forhold til 
agentsystemer er dette et godt poeng da disse som fenomen er forholdsvis nye og 
sannsynligvis vil komme til å gå gjennom en hurtig utvikling hvor gjenbruk av 
komponenter kan være ønskelig. Det er også en gevinst å hente på redusert kompleksitet i 
forhold til utvikling av både agentplattform og agenter ved bruk av en ekstern løsning for 
mobilitet.     
 
The Mobility Aspect Pattern (MAP) er foreslått som en mobilitetsløsning av Garcia et al 
[76]. I sin artikkel peker forfatterne på flere svakheter ved andre mobilitetsløsninger for 
agentsystemer. De trekker spesielt frem at det i andre løsninger er en sterk kobling 
mellom applikasjonsspesifikk og mobilitetsspesifikk funksjonalitet. Dette mener 
forfatterne fører til økt kompleksitet og større rom for feilkilder i utviklingen 
agentsystemer. De mener at integrasjonen av mobilitet som en del av kjernen i et 
agentsystem har en rekke bakdeler.  
 
Tilstedeværelsen av mobilitetsfunksjonalitet gjør annen kode uoversiktlig er det også 
vanskelig å oppdatere og vedlikeholde ett slikt system. Hvis en utvikler vil bytte ut eller 
endre mobilitetsfunksjonalitet må han gjøre dette gjennom hele systemet. Dette er 
tidkrevende og fører ofte til feil i kode. Hvis all mobilvetesfunksjonalitet er samlet og 
interagerer med resten av systemet gjennom klart definerte mekanismer står utviklere og 
     
 56 
brukere mye friere til å utvide og vedlikeholde sitt system. Forfatterne argumenterer også 
for at det siden mobilitetsfunksjonalitet ofte er spredt utover flere klasser, roller og 
metoder er ikke en objektorientert metode effektiv for å skille ut mobilitetsfunksjonalitet. 
I stedet foreslår de en metode basert på Java Aspects. 
 
Aspects har vokst frem som en reaksjon på at det ofte oppstår situasjoner hvor lik 
funksjonalitet må spres over flere klasser eller roller i et system. Et eksempel på dette kan 
være sikkerhetsfunksjonalitet. Mange klasser og roller i et system kan tenkes å gjøre bruk 
av sikkerhetsfunksjonalitet, men det er ikke ønskelig å spre denne utover hele systemet. 
Løsninger kan da være å samle kode for sikkerhet i Aspects og bruke disse for klassene 
eller rollene som behøver sikkerhet. Aspects er ett tillegg til Java programmeringsspråket 
og legger til en ny type – et Aspect [77].  
 
Garcia et. al deler et agentsystem opp i tre hovedkomponenter; en kjerne som tar seg av 
alle grunnleggende aspekter ved agentsystemet, en komponent for andre agenthensyn 
som læring, interaksjon og samarbeid og en tredje komponent som er ansvarlig for 
mobilitet. Hver av disse komponentene har en eller flere grensesnitt. Ett grensesnitt kan 
være en av to typer, et vanlig grensesnitt eller ett krysskuttende grensesnitt (crosscutting 
interface). Disse krysskuttende grensesnittene er spesielle for Aspects og kan tilby 
tjenester til de andre komponentene. I dette tilfellet mobilitetsfunksjonalitet. På denne 
måten kan mobilitet skilles fra resten av systemet.  Mobilitetsaspektet introduseres inn i 
systemet ved hjelp av en komponent som kalles en mobilitetsplattform. Denne 
komponenten er ansvarlig for å registrere hvilke deler av agentsystemet som er mobilt og 
under hvilke forutsetninger de delene skal kunne forflytte seg. 
 
Dette rammeverket skal ifølge forfatterne være kompatibelt med flere agentplattformer 
som for eksempel JADE. AspectM krever da at det blir satt opp sammen med plattformen 
slik at mobilitetsfunksjonalitet fra denne kan benyttes gjennom predefinerte abstrakte 
klasser og grensesnitt. 
 
3.4.3.4 Kodemobiliet i agentsystem 
 
I forhold til design av et system som inneholder mobile agenter er det flere problemer 
knyttet til både terminalmobilitet og kodemobilitet.  
 
• Hvordan skal en mobil terminal som kjører en agentplattform lokaliseres?  
 
• Hvordan skal data leveres til denne terminalen?  
 
• Skal systemet støtte sterk mobilitet eller svak mobilitet?  
 
• Hvilke deler av systemet skal være ansvarlige for terminalmobilitet og hvilke er 
ansvarlige for kodemobilitet?  
 
• Skal all mobilitetsfunksjonalitet være synlig for den som programmerer systemet 
eller bør noe være transparent og styrt av et lavere lag som for eksempel 
     
 57 
nettverkslaget eller linklaget?  
 
Disse spørsmålene er kun et lite utvalg av problemstillingene som finnes i forbindelse 
med design av et mobilt agentsystem.  
 
Det finnes flere forslag til hvordan mobilitetsaspektet i et agentsystem kan løses. Blant 
annet omfatter dette spesifikasjon av de elementene av agentsystemet som skal ta seg av 
mobilitet, beskrivelse av forhold hvor en agent behøver å flytte på seg. Disse løsningene 
inneholder også funksjonalitet for å håndtere at agenter migrerer fra en agentplattform på 
en lokal node til en fjern node, initiering og start av agenter på den fjerne noden, retur til 
hjemmeplattformen og den enkelte agent sin reiseplan. 
 
3.4.4 FIPA mobility 
 
Forflyttning av agenter og kode er et viktig problemområde innenfor agentsystemer, dette 
har FIPA tatt konsekvensen av og spesifisert to ulike protokoller som uttrykker viktige 
begreper innen mobilitet [78]. FIPA skiller mellom to typer mobilitet i et agentsystem; 
forflyttning av terminaler som for eksempel en PDA eller bærbar maskin mellom ulike 
nettverket og forflyttningen av agenter/kode mellom noder. FIPA er mest opptatt av å 
definere standarder og protokoller for å øke mulighetene for samspill (interoperability) 
mellom ulike agentplattformer. Derfor har de ikke presentert noen faste regler for 
hvordan mobilitet skal implementeres, men isteden forsøkt å definere et minimum av 
tjenester som må være til stede hvis et agentsystem skal kunne utnytte mobilitet. 
 
3.4.4.1 Livssyklus 
 
I denne spesifikasjonen blir det lagt til en ny tilstand til livssyklusen for agenter. Denne 
tilstanden blir kalt transitt og har to metoder som kan benyttes for å få en agent inn eller 
ut av tilstanden, move() og execute(). Kun mobile agenter kan gå inn i denne transitt 
tilstanden. Move setter agenten inn i transittilstand og kan kun initieres av agenten selv. 
Excecute bringer agenten ut av transittilstanden og kan bare initieres av agentsystemet.    
 
3.4.4.2 Protokoll 
 
FIPA ser at det finnes flere måter å uttrykke mobilitet på i en agentplattform og nøyer seg 
derfor med å presentere to eksempelprotokoller. De definerer en simpel 
mobilitetsprotokoll hvor agenten delegerer all kontroll av mobilitet til agentplattformen. I 
denne protokolltypen benytter agenten seg kun av enkle funksjoner eksponert av 
agentsystemet. Som tidligere nevnt er et eksempel på en slik funksjon doMove() som 
brukes i JADE plattformen.  
 
Den andre protokolltypen kalles for en fullverdig mobilitetsprotokoll. I den 
protokolltypen er agenten selv ansvarlig for mobilitetskontroll. Her har hver agent 
funksjonalitet for å kunne flytte seg selv og muligens sin eksekveringstilstand (state) over 
til en fremmed agentplattform. Agenten passer selv på at den har blitt flyttet over og 
rekonstruert på den andre siden før den sender over sin identitet og overgir kontroll til 
     
 58 
den nye agenten. En slik overførsel blir ofte kalt kloning og etter en slik operasjon er 
agenten ansvarlig for å melde fra til sin hjemmeplattform og eventuelt andre plattformer 
om forflyttningen.  
 
De to protokollene har ulike egenskaper og antatte fordeler. Den simple protokollen 
reduserer kompleksiteten i utviklingen av agenter og kan enkelt legges til eksisterende 
agentplattformer i form av FIPA ACL utvidelser. Den fullverdige protokollen reduserer 
kompleksiteten i utviklingen av agentplattformer og gir den enkelte agenten utvidede 
muligheter for å kontrollere mobilitet. 
 
3.4.5 Mobilitetsontologi 
 
FIPA introduserer også ett tillegg til sin agentontologi som beskriver termer relatert til 
mobilitet. FIPA sin agentontologi beskriver forskjellige aspekter ved en agent og dennes 
liv på en agentplattfrom. Blant annet beskriver den en mobil agent, en agentprofil, et 
agentsystem og et agentoperativsystem.  
 
Jeg har i denne siste delen av teorikapitlet sett på begrepet mobilitet. Jeg begynte med å 
gjøre en inndeling av begrepet. Videre så jeg på to typer mobilitet; terminalmobilitet og 
kodemobilitet. Jeg klassifisere så ulike typer av løsninger for disse to klassene av 
mobilitet og fremheve sterke og svake sider ved løsningene. I den forbindelse forsøkte 
jeg å se på løsningene i lys av mobiliet for agenter. Til slutt så jeg på FIPA sin 
spesifikasjon for mobilitet. I det neste kapitlet vil jeg beskrive mitt forslag til sikring av 
resultatene fra en mobil agent som ikke kan returnere til sitt utgangspunkt. 
   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
     
 59 
 
4 BESKRIVELSE AV LØSNINGSFORSLAG 
 
I dette kapitlet vil jeg gi en teknisk beskrivelse av mitt forslag til og konstruksjon av en 
sikringsmekanisme for mobile agenter. Kapitlet vil ta form som et designdokument. Dette 
vil være strukturert på følgende måte: Kapitlet begynner med en introduksjon om 
målsetningen for dette testsystemet og en avgrensning av funksjonalitet. Dette er 
etterfulgt av en forklaring på valg av teknologi og agentplattform. Så følger en kort 
kravspesifikasjon og en beskrivelse av de ulike aktørene i systemet. Videre vil jeg 
presentere de forskjellige komponentene i systemet og gi et overblikk over flyt. Kapitlet 
avsluttes med en vurdering av min foreslåtte agentarkitektur. 
 
4.1 Målsetning 
 
Denne oppgaven omhandler mulighetene for å implementere et mobilt agentsystem for 
dynamisk prising av flybilletter samt innhenting av tilbud. Spesifikt er problemstillingen 
knyttet til retur av kjøperagenten etter at denne har utført sitt oppdrag. Jeg vil forsøke å 
utarbeide et designforslag som tilrettelegger for frakoblet operasjon. Med frakoblet 
operasjon menes her alle situasjoner hvor bruker og dennes terminal ikke er i forbindelse 
med et internettverk. Jeg vil se bort fra problemstillinger knyttet direkte til kjøpet av 
billettene og detaljene i forhandling av pris mellom kjøper og selger. 
  
Lokasjon er et viktig begrep for denne typen applikasjoner. Det er nødvendig for den 
sendende noden, som i dette tilfellet er en mobil enhet i form av en bærbar maskin, å 
kunne fortelle agenten den sender ut hvor den skal returnere til. Det er også av viktig at 
agenten vet hvor den skal reise og hva som er den optimale ruten gjennom et 
internettverk til bestemmelsesstedet. I denne delen av oppgaven vil jeg forsøke å utforme 
ett designutast for et slikt agentsystem. Spesielt vil jeg se på mulige løsninger for å 
oppfylle et krav om at agenten må ha et sted å returnere til etter den har løst sine 
oppgaver. Ideelt sett bør agenten returnere til sitt utgangspunkt, altså i dette tilfellet 
sluttbrukerens maskin. Allikevel kan det oppstå en situasjon hvor det ikke er mulig for 
den mobile agenten å returnere hjem etter endt oppdrag. Det er ett krav til denne 
arkitekturen at den kan takle en situasjon hvor sluttbrukeren faller ut fra nettverket eller 
på annen måte er utilgjengelig. Den mobile terminalen kan være utilgjengelig som følge 
av at den er skrudd av, har mistet kobling til nettverket eller har forflyttet seg om endret 
IP adresse. Dette er en aktuell problemstilling i forhold til for eksempel bærbare 
datamaskiner med trådløs tilkobling som bytter nettverk eller ikke er tilgjengelige via nett 
til enhver tid.  
 
4.2 Avgrensning 
 
Denne prototypen har som sin primære målsetning å løse problemet som oppstår når en 
mobil agent skal returnere til sitt utgangspunkt og dette utgangspunktet ikke lenger er 
mulig å nå over nettverket. Systemet baserer seg på at utgangspunktet for den mobile 
agenten er en mobil terminal som er en PDA eller bærbar maskin. Det er også tenkelig at 
den mobile terminalen er en mobiltelefon. Jeg vil se bort fra et scenario hvor terminalen 
     
 60 
forsvinner fra nettverket og aldri kommer tilbake. Designforslaget vil basere seg i 
hovedsak på et sentralisert lager for agenter som ikke kan returnere på vanlig måte. Den 
mobile agenten vil selv sørge for å opprette kontakt med dette lager og vil selv initiere 
selve lagringsprosessen. Når en bruker igjen kommer tilbake til nett kan resultatene fra 
den lagrede agenten hentes og fremvises. Det vil være en begrensning på hvor lenge en 
agent kan lagres før den hentes av en bruker. 
 
4.3 Valg av teknologi 
 
Jeg har i denne oppgaven tatt gjort noen forutsetninger i forhold til bruk av teknologi. Jeg 
var først og fremst interessert i å utarbeide et eksempel på min prinsipielle løsning. Jeg 
var også opptatt av å undersøke og benytte meg av en allerede eksiterende 
agentplattform. Jeg ville forsøke å bidra til utviklingen av agentsystem ved å bygge 
videre på en agentplattform som hadde åpen kildekode. Dette med åpen kildekode var 
viktig for meg da jeg ikke hadde noen erfaring med programmering av agenter og håpet å 
kunne lære mer om dette ved å ha tilgang til koden for selve rammeverket.  
 
En annen viktig faktor i valg av teknologi var å benytte teknologi som tillot enkel 
utplassering og eksekvering på et heterogent sett av maskiner. 
 
4.3.1 agentplattform 
 
Det eksiterer flere plattformer og verktøy i dag som er designet med tanke på utvikling og 
drift av fleragentsystem. JADE [79] er et slikt rammeverk som følger FIPA sine 
spesifikasjoner for agentplattformer. Som tidligere beskrevet i kapitlet om agenter ble 
JADE ble utviklet som et prosjekt med åpen kildekode og har blitt en av de mest 
populære ikke-kommersielle plattformene til bruk for forskning og i 
undervisningssammenheng. JADE er under konstant utvikling og den seneste versjonen 
ble slupper i mars 2005. Selv om det er en stund siden siste oppdatering av 
hovedplattformen er det kommet til flere tillegg til plattformen i mellomtiden. Det er også 
varslet at det vil komme en ny versjon av plattformen i begynnelsen av februar 2006.  
 
Det finnes flere konkurrenter til JADE slik som FIPA-OS, Grasshopper og Voyager, men 
jeg har i denne oppgaven valgt å benytte meg av JADE da denne plattformen så ut til å ha 
det mest aktive utviklermiljøet. JADE er skrevet i Java og er derfor kjørbar på alle 
plattformer så lenge Java er installert. 
 
 
 
 
 
 
 
 
 
 
     
 61 
4.4 Kravspesifikasjon 
 
Jeg har forsøkt å utvikle en kort kravspesifikasjon basert på min valgte problemstilling. 
Denne kravspesifikasjonen er også relatert til dynamisk prising innenfor flyindustrien.   
 
Her følger noen krav som systemet skal eller bør oppfylle.: 
 
- Skal takle at den mobile terminalen skifter nettverk 
    
- Skal takle at den mobile terminalen kobler seg fra nettverket for en lengre 
periode. 
 
- Systemet skal inneholde en ruteplanlegger. Dette vil være en ekstern enhet som 
agenten skal bære med seg som holder informasjon om den mobile agenten sin 
reiseplan 
 
- Plattformavhengig og nettverksuavhengig – skal kjøre i et heterogent 
nettverksmiljø. 
 
- Kjøperagenter skal være autonome og selv være ansvarlige for å sikre at 
sluttbrukeren får levert et resultat. 
 
- Enkelt å bruke, enkelt brukergrensesnitt 
 
- Beskrivelse og utveksling av ontologi via ACL beskjeder 
 
- Primært for en bruker av bærbar terminal tilknyttet med trådløs tilkobling som for 
eksempel IEEE 802.11, men bør også fungere likt for terminaler som er tilkoblet 
mobilnettet. 
  
- Bør kunne kontakte brukeren av den mobile terminalen når denne skal hente 
agenten igjen. 
 
- Bør støtte ulike typer agenter på kjøperside. Den enkelte kjøperagent skal kapsle 
inn en bestemt strategi for å innhente tilbud på flybilletter. 
 
- Systemet bør ha et meget lite avtrykk altså størrelse på applikasjonen bør være 
begrenset. Dette er spesielt viktig i forhold til klient. 
 
- Gjøre bruk av så mye eksisterende teknologi med åpen kildekode som mulig 
 
 
 
 
 
 
     
 62 
 
 
 
 
 
 
 
 
 
 
4.5 Use-case diagram 
 
 
Figur 4.1: Use-case diagram 
 
4.6 Aktørbeskrivelser 
 
4.6.1 Mobil klient / Sluttbruker 
 
Denne aktøren representerer sluttbrukeren i systemet som er en person. Det som 
karakteriserer denne brukeren er at det ikke kan forventes mer enn moderat grad av 
teknisk innsikt i systemet. Derfor er det meget viktig for denne aktøren at systemet er lett 
å bruke og feiltolerant. Denne aktøren har som mål å spesifisere ulike kriterier for en 
flyreise og poste disse til systemet. Systemet skal så ta seg av å oppfylle aktørens 
hovedmål som er å lokalisere tilbud på flyreiser som passer til den enkelte bruker sine 
     
 63 
krav til en reise. Denne aktøren har også som en viktig karakteristikk at den mobil, altså 
at den kan antas å skifte lokasjon og/eller nettverk en eller flere ganger i tidsrommet 
mellom input av brukerkriterium og fremvisning av resultat. Det er også tenkelig at denne 
brukeren ikke har stabil nettverkstilgang til alle tider. 
 
4.6.2 UIAgent 
 
Denne aktøren er en agent og opptrer som grensesnitt for en bruker. Den aktøren er 
ansvarlig for å vise et grensesnitt slik at bruken kan sette opp kriterium for en flyreise. 
Denne aktøren er også ansvarlig for å opprette og initiere en kjøperagent BuyerAgent som 
gjør bruk av brukerens kriterium. Denne aktøren er også ansvarlig for å sjekke om en 
tidligere utsendt agent har returnert eller om den har blitt lagret som følge at den ikke 
kunne returnere. Ved tilfeller der en mobil kjøperagent ikke har returnert er denne 
aktøren ansvarlig for å kontakte den sentrale lagringsagenten StorageAgent slik at den 
kan få overført resultatene til den mobile kjøperagenten. 
 
4.6.3 BuyerAgent 
 
Denne aktøren er også en agent. Denne aktøren har som mål å finne reiseagenter den kan 
kommunisere med. Målet med denne kommunikasjonen er å finne tilbud på flybilletter 
som samsvarer med kriterium satt opp av en bruker. Kjøperagenten forsøker å innhente 
en liste over tilgjengelige reiseagenter og forflytter seg så til lokasjonene hvor disse 
befinner seg. Etter å ha innhentet tilbud fra alle de tilgjengelige reiseagentene vender 
denne aktøren tilbake til den mobile brukeren. Utover dette har denne aktøren en viss 
grad av autonomi da den er ansvarlig for å godta eller forkaste tilbud på flybilletter den 
får presentert. Kjøperagenten opptrer på en aktiv måte i den forstand at den initierer 
forhandlinger med en eller flere salgsagenter i prosessen med å innhente de beste 
tilbudene ut fra en sluttbruker sine kriterier. Kjøperagenten har som mål å lokalisere 
tilbud som maksimerer nytteverdien for en bruker. Hvis det ikke er mulig å returnere med 
resultat til brukeren forsøker agenten å bli lagret på den sentrale noden ved å be om å bli 
lagret av en lagringsagent, StorageAgent. 
  
4.6.4 TravelAgent 
 
Denne aktøren er i likhet med kjøperagenten en programvareaktør. Denne agenten har 
som mål å selge flest mulig flybilletter ved å gi tilbud til kjøperagenter. Agenten forsøker 
å maksimere profittmargin ved å dynamisk prise billetter etter fastsatte kriterium. For å 
oppnå sitt mål om å skape profitt for sitt selskap må salgsagenten snakke samme språk og 
ha den samme begrepsforståelse som kjøperagenten. Dette innebærer at de må enes om 
en ontologi. Hvis dette skal være et system som kan motta ulike agenter fra flere kilder er 
det viktig for denne aktøren at den har mekanismer for å utveksle og bli enig om en felles 
begrepsforståelse med en kjøperagent. I motsetning til kjøperagenten er det en 
karakteristikk ved denne agenten at den ikke er mobil. Agenten lever hele sitt liv på den 
samme noden.  
 
 
     
 64 
 
4.6.5 StorageAgent 
 
Denne aktøren er ansvarlig for all persistensfunksjonalitet i systemet. Denne aktøren er 
lokalisert på hovedcontaineren og skal alltid være tilgjengelig for mobile agenter og 
UIAgenter som vil hente resultat fra lagrede agenter. Denne aktøren har som mål å lagre 
mobile agenter på en slik måte at de unikt kan identifiseres og hentes ut av lager.  
 
4.7 Komponentdiagram 
 
Komponentdiagrammet er ment å gi et overblikk over komponentene i systemet. Jeg har 
valgt å ikke ta med nettverket mellom disse komponentene for gjøre det enklere å lese. 
Siden jeg ikke har ett eget utplasseringsdiagram (deployment) har jeg valgt å illustrere en 
agent og en typisk reise fra den mobile terminalen til en selger og så videre til en annen 
selger og tilslutt retur tilbake til igjen. Altså en migrasjon som involverer flere hopp 
(multi-hop). Diagrammet viser den alternative flyten som inntreffer hvis en kjøperagent 
ikke kan migrere tilbake til den mobile brukeren. Jeg har utelatt å legge inn flyt for 
henting av lagrede resultater for å gjøre diagrammet mer oversiktlig.  
 
 
Figur 4.2: Komponentdiagram 
 
 
 
 
     
 65 
4.8 Komponent beskrivelse 
 
Jeg vil gi en kort beskrivelse av hver av hovedkomponentene i systemet. Hver av 
komponentene vil være illustrert ved et enkelt diagram. Hvis komponenten er en agent vil 
diagrammet kun vise navn på agenten og hvilke ulike atferder denne agenten tilbyr. En 
atferd (behaviour) er manifestasjonen av ulike roller en agent kan ha i JADE. Hver atferd 
er implementert som en egen klasse, i de fleste tilfellene en indre klasse i de respektive 
agentene. 
 
4.8.1 UIAgent 
 
 
 
Figur 4.2: UIAgent 
 
Agenten UIAgent settes automatisk opp når brukeren starter applikasjonen. Denne 
agenten har to roller, på den ene siden er den ansvarlig for å vise frem et grafisk 
grensesnitt til brukeren. Denne agenten gjør det ved å utvide typen GUIAgent som er en 
abstrakt klasse som finnes i JADE. Klassen GUIAgent inneholder noen metoder slik som 
OnGuiEvent som alle subklasser må implementere. Denne metoden er til for å fange opp 
hendelser skapt av brukeren gjennom det grafiske grensesnittet. UIAgent inneholder 
funksjonalitet for å lese og skrive til en fil på den mobile brukerens sin maskin. Første 
gangen applikasjonen kjører vil grensesnittet vises og når brukeren har satt opp sine 
kriterier for en flyreise og trykket Search oppretter denne agenten en BuyerAgent. 
Opprettelsen av denne agenten skjer ved at denne instansen av UIAgent genererer et 
unikt navn som er en kombinasjon av tidspunktet agenten ble opprettet i millisekunder og 
navnet buyer. UIAgenten registrerer så den nyskapte BuyerAgenten med 
agentplattformen ved å benytte FIPAAgentManagementOntology og handlingen 
CreateAgent. I forbindelse med at UIAgenten lager en ny BuyerAgent skriver den navnet 
på den nye agenten til filen AgentID. Selve registreringen blir utført av JADE AMS. Den 
nyskapte BuyerAgent settes så opp med parameterne brukeren spesifiserte via det 
grafiske grensesnittet.. 
 
Hvis ikke dette er første gangen denne agentapplikasjonen kjøres vil UIAgent sjekke filen 
AgentID på den mobile brukeren sin maskin. Sjekken av denne filen er en enkel 
     
 66 
mekanisme for å undersøke om den forrige BuyerAgent som ble sendt ut returnerte. Hvis 
den har returnert har den skrevet over sitt navn og erstattet dette med returned. Hvis den 
ikke har kunnet returnere vil det unike navnet den ble tildelt fortsatt være skrevet i filen. 
Hvis filen ikke er tom eller inneholder ordet returned vil UIAgent starte adferden 
HandleAgentRecallBehaviour. Denne atferden søker etter agenten som tilbyr 
lagringstjeneste i denne plattformen, dette vil være en agent av typen StorageAgent. Hvis 
en slik tjeneste finnes vil UIAgent starte atferden RequestAgentResultBehaviour. Denne 
atferden kommuniserer med en StorageAgent og angir hvilken agent den er interessert i 
resultatene fra ved å gi fra seg navnet på agenten. Hvis en slik agent har blitt lagret vil 
StorageAgent svare på denne forespørselen med resultatene til den lagrede BuyerAgent. 
 
4.8.2 BuyerAgent 
 
 
Figur 4.3: BuyerAgent 
 
Denne komponenten er ansvarlig for å utføre selve innsamlingen av tilbud på flybilletter. 
Den blir skapt av en UIAgent og utvider klassen Agent. Etter at denne agenten er satt opp 
med brukerens kriterium for en flyreise initierer den et Itinerary objekt og spesifiserer sin 
lokasjon, hjemmelokasjonen, som parameter til dette objektet sin konstruktør. Videre 
starter den atferden FindStorageServiceBehaviour. Hvis agenten gjennom denne atferden 
finner en lagringstjeneste startes atferden getStorageAgentLocationBehaviour som ber 
plattformen sin AMS om lokasjonen til den navngitte StorageAgent. Hvis en slik lokasjon 
finnes legges den til Itinerary objektet ved at agenten kalle metoden 
setStoragetLocation(Location l). Parallelt med dette starter agenten atferden 
getTravelAgentLocations. Denne atferden er ansvarlig for å søke etter agenter som tilbyr 
     
 67 
en reisetjeneste og så finne deres lokasjon gjennom kommunikasjon med plattformen sin 
AMS. Disse lokasjonene legges så til i agenten sin reiseplan Itinerary objektet.   
 
Når reiseplanen er satt opp er BuyerAgent klar for å begynne å samle inn tilbud på 
flybilletter. Agenten starter så doMoveBehaviour som er en atferd ansvarlig for å hente ut 
neste lokasjon fra Itinerary objektet og så migrere til denne lokasjonen. Denne atferden 
sjekker også om det finnes flere lokasjoner å besøke eller om det er på tide å returnere til 
brukeren. Hvis det finnes flere lokasjoner migrerer agenten til neste lokasjon gitt av 
Itinerary objektet sin metode getNextLocation(). Når agenten kommer frem til neste node 
starter den atferden HandleTicketBehaviour. Denne atferden er ansvarlig for å 
kommunisere med en navngitt TravelAgent. Atferden er også ansvarlig for å starte to 
andre atferder; QueryAvailableBehaviour og RequestOfferBehaviour. 
QueryAvailableBehavio sjekker med reiseagenten om den har noen flybilletter som 
tilsvarer det ønskede kriterium. I kommunikasjonen mellom selger og kjøper benyttes 
ontologien Flight-ontology som er en enkel ontologi satt opp for dette testsystemet. Hvis 
billetter er tilgjengelige starter RequestOfferBehaviour som ber reiseagenten om å komme 
med et tilbud. Reiseagenten kommer med et tilbud og denne agenten kan enten godta 
eller forkaste tilbudet. Jeg har her valgt å gjøre denne delen meget enkel slik at det 
foregår ingen videre forhandling mellom kjøper og selger utover å godta eller forkaste et 
tilbud. Det er imidlertid mulig å bygge ut en slik atferd hvor de to agentene forhandler 
seg frem til et endelig tilbud. Etter å ha mottatt et tilbud startes på nytt doMoveBehaviour 
og agenten reiser videre. 
 
Hvis det ikke finnes flere lokasjoner å besøke vil atferden doMoveHomeBehaviour startes 
og kjøperagenten forsøker å migrere hjem. Denne atferden forsøker å kommunisere med 
en PingResponder som kjører på kjøperagenten sin hjemmecontainer. Hvis 
PingResponder svarer vet denne agenten at det er mulig å nå den mobile klienten og 
migrerer så hjem. Er det imidlertid ikke mulig å kommunisere med PingResponder vet 
agenten at den må lagre en kopi av seg selv. Hvis dette inntreffer startes atferden 
RequestStorageBehaviour, denne atferden tar kontakt med plattformen sin StorageAgent 
og kommuniserer med denne. I denne ”samtalen” sender kjøperagenten over en serialisert 
kopi av seg selv og ber om at denne blir lagret. Hvis den får bekreftelse på at lagring er 
utført ber agenten plattformen sin AMS om å slette seg selv.  
 
En kjøperagent har behov for en enkel form for datalagring. Agenten har behov for å 
lagre resultater underveis mens den utfører sammenligninger av tilbud på veiene av sin 
bruker. Ettersom agenten finner tilbud som kan passe ut fra brukerens kriterium lagres 
disse i en ArrayList. Tilbud lagres i form av Offer objekter som er spesifisert i ontologien 
Flight-ontology. I denne prototypen er det ikke mulig for agenten å foreta et kjøp på 
veiene av brukeren. Agenten har derfor kun en innsamlingsfunksjon. Det er også tenkelig 
at det vil være gunstig å sammenligne ulike tilbud etter hvert som de kommer inn slik at 
tilbud som klart ikke når opp i konkurranse med nyere tilbud kan slettes for å minimere 
størrelsen på agenten. 
 
 
 
     
 68 
 
4.8.3 TravelAgent 
 
 
Figur 4.4: TravelAgent 
 
Oppgaven til denne komponenten er å representere en selger av flybilletter. 
Komponenten er en agent og utvider følgelig klassen Agent. Denne agenten er utplassert 
og satt opp med informasjon om billetter. Den er implementert på en enkel måte og 
benytter seg ikke av noen form for persistent lager av billetter slik som ville være 
situasjonen hvis dette hadde vært et kommersielt system. Når en TravelAgent startes 
registrerer den seg med en den sentrale DF agenten i plattformen. Den registrerer her sitt 
navn, lokasjon, tjenestetype og navn på tjenesten den tilbyr. Etter at den har registrert seg 
sitter den på sin node og venter på å bli kontaktet av en kjøper representert ved en 
BuyerAgent.  
 
Når en TravelAgent blir kontaktet av en kjøper skjer det ved at kjøperen sender en ACL 
melding som er av type FIPANames.InteractionProtocol.FIPA_QUERY. En TravelAgent 
sjekker innkommende beskjeder opp mot en meldingsmal og starter i dette tilfellet opp 
atferden HandleFlightQueriesBehaviour som gir kjøperen et tilbud i form av et Offer 
objekt. Slik som systemet er satt opp nå inneholder disse selgeragentene kun en liten 
mengde flybilletter som er hardkodet inn. Denne agenten kan imidlertid endres slik at den 
implementerer en strategi for å dynamisk prise billettene. For eksempel er det mulig å 
prise billetter i forhold til hvor lenge det er til flyturen skal finne sted og hvor mange 
billetter som allerede er reservert på det aktuelle flyet. Jeg har utelatt dette da det ikke 
tjente noen hensikt i forhold til å illustrere sikring av resultatene fra kjøperagenten. 
 
 
 
 
 
 
 
 
     
 69 
4.8.4 StorageAgent 
 
 
 
Figur 4.5: StorageAgent 
 
Denne komponenten er ansvarlig for å sørge for persistens av kjøperagenter som ikke når 
frem til sin mobile bruker. Det finnes kun en StorageAgent per agentplattform og det er 
kun denne agenten som har tilgang til den relasjonsdatabasen som benyttes som 
persistenslag i systemet. Når denne agenten startes kontakter den plattformen sin DF 
agent og registrerer sin lokasjon, sitt navn og type tjeneste som er storage. Den sjekker 
også tilgangen til databasen og setter opp en tabell for å lagre agenter hvis en slik ikke 
finnes fra før. Etter den har fullført registreringen venter den på sin node til den blir 
kontaktet av enten en BuyerAgent som vil lagre en kopi av seg selv eller en UIAgent som 
vil hente resultatene til en tidligere lagret agent. 
 
Når en StorageAgent får en forespørsel om å lagre en kopi av en BuyerAgent aktiveres 
atferden HandleStorageRequestBehaviour. Denne atferden tar imot navnet og en 
serialisert kopi av agenten den blir forespurt om å lagre. Agenten forsøker så å lagre 
kopien. Hvis dette er vellykket sender den en bekreftelse tilbake til kjøperagenten som 
initierte lagringen. 
 
Tilsvarende hvis en StorageAgent får en forespørsel om å hente frem resultatene til en 
tidligere lagret agent starter den atferden HandleRetrievalRequestBehaviour. Denne 
atferden er ansvarlig for å gjøre en spørring mot databasen for å hente ut den serialiserte 
kopien av en lagret agent. Agenten som hentes ut identifiseres med navn i spørringen. 
Når den serialiserte kopien er hentet ut gjenopprettes den som en BuyerAgent. Når en 
BuyerAgent har blitt gjenopprettet sender den selv tilbake sine resultater til sin bruker 
som er representert ved en UIAgent.  
 
 
 
 
 
 
     
 70 
4.8.5 PingResponder 
 
 
Figur 4.6: PingResponder 
 
Denne komponenten er en ment å fungere som mottaker og sender av ”ping” meldinger. 
Denne komponenten er en agent og utvider klassen Agent. En PingResponder har en 
oppgave og det er å sitte og vente på en melding med innhold ”ping”. Hvis den får en slik 
melding aktiveres atferden WaitPingAndReplyBehaviour og den sender en melding 
tilbake med innhold ”alive”.  
 
4.8.6 Itinerary 
 
 
 
Figur 4.7: Itinerary klasse 
 
Ruteplanen er en laget på bakgrunn av Itinerary mønsteret beskrevet av Aridor og Lange i 
deres artikkel [80]. Mønsteret går ut på å skille ut funksjonalitet assosiert med navigasjon 
og plassere dette i et eget objekt. Dette gjøres ved at det lages et objekt som innkapsler en 
ruteplan og metoder for å endre, oppdatere og lese denne planen. Dette mønsteret kan 
brukes i situasjoner hvor det er viktig å kunne sette opp regler for hvordan agenten skal 
oppføre seg når den reiser fra en vert til den neste. For eksempel kan man sette en øvre 
grense for hvor mange ganger agenten skal forsøke å reise til en node som ikke svarer og 
angi en alternativ handling hvis denne grensen er nådd. Ruteplanen kan også lagres og 
brukes igjen av andre agenter.  
     
 71 
 
I dette systemet er det lagt opp til at en agent får en ruteplan når den har registrert seg 
med agentplattformen. Agentplattformen er ansvarlig for å opprettholde en samling 
oppdaterte adresser på alle agenter som befinner seg i plattformen. Dette inkluderer alle 
lokasjoner for selgeragenter i systemet.  
 
4.9 Sekvensdiagram 
 
Jeg vil nå presentere to sekvensdiagram for å beskrive flyt i mitt testsystem. Disse 
diagrammene er litt forenklet for å gjøre de litt mer lesbare. Det første diagrammet viser 
flyt i en kjøring av systemet hvor den mobile agenten ikke har problemer med å returnere 
til den mobile terminalen. Det andre diagrammet viser detalj for flyt når det ikke er mulig 
å returnere hjem for den mobile agenten. 
 
 
 
 
Figur 4.8: Sekvensdiagram over en kjøring av systemet hvor den mobile klienten er 
tilgjengelig og systemet kan migrere hjem 
     
 72 
 
 
 
 
Figur 4.9: Sekvensdiagram 2 viser detalj fra BuyerAgent som forsøker å migrere hjem, 
men oppdager at mobilklient ikke er tilgjengelig. Sender i stedet forespørsel til 
StorageAgent og blir lagret. Videre startes applikasjonen opp igjen og UIAgent oppdager 
at agent ikke returnerte, UIAgent sender forespørsel til StorageAgent og denne oppretter 
en kopi av BuyerAgent basert på lagret agent. Kopi av BuyerAgent sender sine resultater 
tilbake til UIAgent. 
 
4.10 Kommentar til agentarkitektur 
 
Arkitekturen for dette agentsystemet er forenklet og mangler funksjonalitet i forhold til 
en robust kommersielt system. Den største mangelen er nok fraværet av en egen 
sikkerhetsmodul. Sikkerhet for mobile agenter er et komplisert og stort forskningsområde 
og av hensyn til avgrensning av min oppgave har jeg valgt å utelate disse 
problemstillingene i designet av kjøperagenten. Jeg er dog inneforstått med at dette ville 
ført til at agenten ikke ville være i stand til å utføre sine oppgaver i et scenario med 
virkelige kjøpere og selgere. 
 
I dette kapitlet har jeg gitt en teknisk beskrivelse av mitt designforslag til en 
agentarkitektur som inkorporerer en resultatsikringsmekanisme. Jeg begynte med å 
beskrive valg og avveininger i forhold til teknologi og omfang. Deretter beskrev jeg 
aktørene og komponentene i systemet. Avslutningsvis beskrev jeg flyt i to scenario og ga 
en kort kommentar til arkitekturen.  
 
 
 
 
 
     
 73 
 
5 RESULTATER 
 
I dette kapitlet vil jeg se på resultatene av mitt arbeide med å utvikle et enkel prototyp av 
et mobilt agentsystem hvor retur av resultater er garantert. Dette kapitlet vil begynne med 
en generell beskrivelse av mitt forslag til en løsning. For en mer detaljer beskrivelse av 
teknisk art henvises lesere til designbeskrivelsen i det foregående kapitlet. Jeg vil så gå 
gjennom en typisk kjøring av testsystemet hvor jeg vil forsøke å belyse hvordan systemet 
fungerer og relatere dette til designforslaget. 
 
5.1 Generell løsning 
 
Mitt forslag til en løsning med sikring av resultatene for en mobil agent som ikke kan 
kontakte sin hjemmeplattform baserer seg på å benytte en sentral lagringsplass. Denne 
lagringsplassen vil være en container som kjører på en statisk node med en stabil kobling 
til Internett som alltid er på. Denne noden skal tjene som en lagringsplass for flere 
agenter og fungere slik at den lagrer mobile agenter som ikke kan nå sin 
hjemmeplattform. Noden som kjører agentplattformen skal inneholde en 
relasjonsdatabase som brukes for å lagre agentene.  
 
Det sentrale lagret er representert ved en lagringsagent som ansvarlig for alle oppgaver 
knyttet til mottak og videre behandling av agenter som ikke kan vende hjem. Brukere 
som vil forsikre seg om at deres mobile agent returnerer med et resultat må registrere seg 
med den sentrale lagringsplassen. Det vil være opp til utvikler og valg av agentplattform 
hvordan dette skjer. Det som er viktig i denne sammenhengen er at den mobile agenten 
kan identifiseres unikt. Dette kravet er ufravikelig og identifikasjonen må også være unik 
selv etter at en lagret agent er slettet fra systemet.    
 
Denne løsningen tar også i bruk et designmønster fra agentplattformen Aglets som kalles 
Itinerary - en reiseplan. Prinsippet bak reiseplanen er å sette opp en rute med lokasjonene 
den mobile agenten skal besøke på sin reise. Reiseplanen skal også ha funksjonalitet for å 
endre reiseplanen hvis det ikke er mulig å opprette kontakt med en destinasjon. Dette 
gjelder spesielt den siste destinasjonen som er den mobile agenten sin hjemmeplattform. 
Hvis det viser seg at noden agent kom fra ikke er kontaktbar skal agenten benytte seg av 
en lagringsagent. Den mobile agenten sjekker om hjemmenoden er tilgjengelig ved å 
forsøke å sende en ACL melding til en spesiell agent som lever på den mobile agenten sin 
opphavsnode. Selve utformingen av denne agenten og funksjonalitet knyttet til den er opp 
til utvikler, men det er et minimumskrav at den kan svare på en ”ping” melding. Ved å 
benytte reiseplanen på denne måten vil risikoen for at en mobil agent ikke returnerer sine 
resultater minskes betraktelig. Hvis den ikke når frem til sin destinasjon er det klart 
definerte rutiner for hva som skal inntreffe.  
For å hente resultatene til en lagret agent skal en grensesnittagent på den mobile noden 
kontakte lagringsagenten. Klienten initierer selv henting av resultatene. Når kontakt er 
etablert og klienten har identifisert seg søker lagringsagenten etter lagrede agenter med 
identifikasjonsnummer og navn tilsvarende opplysninger gitt av klienten. 
     
 74 
Lagringsagenten rekonstruerer så agenten på bakgrunn av den lagrede versjonen. Etter at 
agenten har blitt tatt ut av lagring er den selv ansvarlig for å sende sine resultater tilbake 
til den mobile terminalen. Selve formen en agent antar når den blir lagret er opp til 
utvikler. Grensesnittagenten skal automatisk oppdage at en mobil agent ikke har returnert. 
Dette skal skje ved at den mobile agenten selv signaliserer at den er kommet tilbake. 
Denne metoden for å hente resultatene fra en lagret agent er ment å være 
ressursbesparende og sikker. Den er ressurssparende fordi agenthavnen ikke på noen 
måte forsøker å kontakte klienten. Dette kan potensielt spare ressurser da gjentatte forsøk 
på å oppnå kontakt med en frakoblet klient vil være unødig bruk av ressurser som 
båndbredde. Denne metoden er også sikker da den lagrede agenten selv er ansvarlig for å 
oversende sine resultater. Metoden tilbyr også sikring mot fatale krasj på lagringsnoden 
da den benytter seg av en relasjonsdatabase for å lagre de mobile agentene. Såfremt det 
ikke inntreffer en fatal feil på lagringsnoden under lagringen av agenten vil den befinne 
seg i databasen når lagringsnoden igjen er operabel. Det skal også legges inn en 
mekanisme i den mobile agenten slik at denne ikke søker å avslutte sin eksekvering, altså 
slette seg selv, før den har fått bekreftelse på at den har blitt lagret. 
I Forhold til det testsystemet jeg har laget så er lagringsagenten representert ved en 
StorageAgent som kommuniserer med en relasjonsdatabase. Alle klienter registrerer seg 
med navn på container og navn på agentene i denne containeren. Alle navn er unike da 
dette er et krav i JADE rammeverket. Dette rammeverket benytter en kombinasjon av 
navn og lokasjon som en unik agentidentifikasjon (AID). For å være sikker på at det ikke 
oppstår noen konflikter legger jeg også til den eksakte tiden i millisekunder når agenten 
ble skapt. Dette gjøres fordi det er en mulighet for å skape en ny agent med samme navn 
som en lagret agent etter at den lagrede agenten er slettet fra systemet. På grunn av 
begrensninger i den nåværende versjonen av JADE vil mitt testsystem begrense seg til å 
gjøre bruk av intra-platform mobilitet. Mitt testsystem er implementert i rammeverket 
JADE og har jeg har forsøkt å dra nytte av eksiterende funksjonalitet i denne plattformen. 
 
5.2 Testing 
Jeg har testet mitt testsystem ved å spre det over flere maskiner i UIO sitt nettverk. 
Beklageligvis har jeg ikke hatt muligheten til å kjøre systemet på en dedikert samling av 
maskiner så det har vært begrensninger på hvor mange agenter jeg har kunnet kjøre 
samtidig. Ideelt sett ville jeg gjerne hatt muligheten til å kjøre systemet på noen dedikerte 
maskiner slik at jeg kunne testet skalerbarheten. Jeg har spesielt vært interessert i å teste 
hvor godt lagringsagenten ville taklet simultane forespørsler om lagring fra mange 
mobile agenter. Jeg vil nå gi en gjennomgang av testkjøring av systemet og så skissere 
hvordan jeg ville testet et scenario med mange agenter. 
For å teste systemet har jeg benyttet min bærbare maskin med Windows XP som 
operativsystem som den mobile noden. Videre har jeg benyttet maskiner i UIO sitt nett 
som kjører Linux. Agentsystemet er implementert i Java og da dette språket er 
plattformuavhengig har ikke de ulike operativsystemene vært noe problem. Jeg har 
forsøkt å kjøre opp til 30 forskjellige containere på 10 forskjellige maskiner, men har 
ikke sett noen merkbar endring i migrasjonstid eller eksekvering av agenter. Det jeg dog 
     
 75 
har blitt begrenset av er tildeling av minne på maskinene jeg har kjørt testene på. Dette 
har ført til at testing har vært en tidkrevende prosess siden har tatt lang tid å starte de 
ulike containerne. 
En typisk test av systemet har foreløpet på følgende måte: 
Først har jeg startet en hovedcontainer på en maskin i UIO nettverket, for eksempel 
nelja.ifi.uio.no.  
Syntaks for start av hovedcontainer er som følger: 
nelja ~  $ java jade.Boot –local-host nelja.ifi.uio.no –local-port 9999 
storageManager:trader.StorageAgent 
Her kalles Boot klassen i JADE som starter selve agentplattformen. Samtidig spesifiseres 
fullt navn på maskinen som kjører hovedcontainer (-local-host) og porten andre 
containere kan registrere seg via (-local-port). Det siste argumentet starter en 
lagringsagent fra pakken trader. Etter at hovedcontaineren er startet kan 
tilleggscontainere startes.  
Når jeg har testet har jeg spredt tilleggscontainerne ut over forskjellig maskiner i UIO 
nettet. For eksempel ser syntaksen for å starte en container på kahdeksan.ifi.uio.no som 
binder seg til hovedcontaineren og som holder en reiseagent slik ut: 
kahdeksan ~ $ java jade.Boot –container -host nelja.ifi.uio.no -port 9999 
travelOne:trader.TravelAgent\(“CheapTravel”\) 
Her kalles igjen Boot klassen i JADE og denne gangen starter den en container som 
binder seg til hovedcontaineren. Agrementet etter –host sier hvor hovedcontaineren 
befinner seg og argumentet etter –port hvilken port den lytter på. Det siste argumentet 
starter en reiseagent, en selger av flybilletter, fra pakken trader. Denne agenten tar et 
argument som er navnet på reisetjenesten denne reiseagenten tilbyr. Videre har jeg typisk 
startet flere containere med reiseagenter. Det er et krav at alle agentene har forskjellige 
navn og at reisetjenesten de tilbyr også har et unikt navn. 
Videre i testing har jeg startet en container på min bærbare maskin. Under ulike 
testforhold har denne maskinen vært koblet til UIO sitt nettverk med kabel, via trådløs 
tilgang eller via VPN når jeg har testet hjemmefra. Når jeg har startet denne containeren 
har jeg også startet en spesiell agent som ligger i JADE rammeverket som kalles en 
Remote Management Agent (RMA). Denne agenten gir et bilde av agentplattformen og 
har funksjonalitet for blant annet å starte nye agenter eller slette agenter og containere. 
Syntaksen for å starte denne containeren er lik som for å starte en container med en 
reiseagent bortsett fra at det startes en agent kalt UIAgent fra pakken trader. Figur 5.1 
viser en RMA agent med fire containere og en hovedcontainer. Tre av containerne holder 
en reiseagent og en holder en UIAgent kalt user.     
     
 76 
 
Figur 5.1: Agentplattform med 5 containere. Navnet på de ulike agentene er satt sammen 
med navnet på hovedcontaineren selv om de alle ligger på ulike maskiner. Dette 
reflekterer at alle agentene og containerne er knyttet til hovedcontainer.  
Etter at UIAgent som i dette eksempelt heter user er lagt til plattformen viser denne agent 
frem et grensesnitt til brukeren. Dette grensesnittet er vist i Figur 5.2. I grensesnittet kan 
brukeren sette enkle parametere for en flytur. Etter å ha satt parametere for en flytur i 
dette tilfellet en tur fra oslo til london den 1. desember 2005 på turistklasse trykkes 
Search. Når dette er utført genererer grensesnittagenten en instans av en BuyerAgent og 
en instans av en PingResponder. Disse agentene får navnene buyer og ping og i tillegg 
tidspunktet de ble skapt på i form av millisekunder siden 1970. I forbindelse med at disse 
agentene blir opprettet skrives hele navnet til kjøperagenten i en fil. Figur 5.3 viser et 
bilde av hvordan agentplattformen ser ut med de to agentene startet.  
 
     
 77 
 
Figur 5.2: Brukergrensesnitt for å spesifisere reiseparametere for kjøperagent. 
     
 78 
 
Figur 5.3: Viser hvordan agentplattformen ser ut etter at UIAgent har generert en 
BuyerAgent og en PingResponder. 
Etter at kjøperagenten er generert søker den etter agenter som tilbyr reisetjenester. Den 
får så satt opp en reiseplan som inneholder lokasjonen på containeren den er skapt på, 
lokasjoner til alle reiseagenter og lokasjonen til lagringsagenten. Kjøperagenten begynner 
så å migrere til de ulike selgerne og kommuniserer med disse for å innhente tilbud på 
flybilletter. Den migrerer til hver og en og når den ikke har flere lokasjoner å reise til 
forsøker den å migrere hjem. Før den gjør dette sender den en melding til agenten 
PingResponder som har samme tidsmerking som den selv. Hvis denne svarer migrer 
kjøperagenten hjem og viser frem sine resultater til brukeren i terminalvinduet 
containeren den lever på ble startet i. I dette scenarioet går alt som det skal og den mobile 
agenten har ikke behov for lagring.  
Scenario 1: 
- Migrasjon fungerte som forventet 
- Kommunikasjon mellom selger og kjøper fungerte 
- Resultatet var et tilbud på en flybillett fra Oslo til London 
     
 79 
Jeg har så testet to ulike scenario hvor noe går galt. I det første testet jeg å manuelt drepe 
containeren kjøperagenten ble skapt via RMA grensesnittet. Når jeg slettet containeren 
via dette grensesnittet forsvant den øyeblikkelig og systemet skrev også til 
terminalvinduet for hovedcontaineren at containeren var utilgjengelig. Siden dette 
testsystemet ikke involverer særlig mye tidkrevende prosessering måtte jeg legge inn en 
buffer i form av å stoppe kjøperagenten sin eksekveringstråd i 4 sekunder etter hver gang 
den hadde migrert til en ny node. Jeg var nødt til å gjøre dette for å ha mulighet til å slette 
containeren den mobile agenten ble skapt på før kjøperagenten kom tilbake. Når jeg 
slettet hjemmecontainer til kjøperagenten fortsatte den å migrere til den hadde besøkt alle 
selgere og så forsøkte den å sende en melding til sin PingResponder. Når den ikke fikk 
svar fra denne tok den kontakt med lagringsagenten og ba om å bli lagret. 
Lagringsagenten svarte positivt på denne forespørselen og kjøperagenten sendte så over 
en serialisert utgave av seg selv og ventet på bekreftelse på at den var lagret. Når den så 
fikk denne bekreftelsen slettet den seg selv.  
Scenario 2: 
- Migrasjon fungerte som forventet 
- Sletting av container og agenter på denne fungerte som forventet 
- Kommunikasjon mellom kjøperagent og lagringsagent som forventet 
- Lagring fungerte som forventet 
Etter å ha testet å slette en container via RMA grensesnittet forsøkte jeg å slå av min 
nettverkstilkobling for å se om systemet oppførte seg på lik måte. Når jeg slo av 
nettverkstilkoblingen som i dette tilfellet var en trådløs tilkobling ble hjemmecontaineren 
til kjøperagenten værende i RMA grensesnittet og det ble heller ikke skrevet noe til 
terminalvinduet hvor hovedcontaineren var startet. Det så ut til at plattformen ikke 
registrerte at containeren som levde på min maskin ikke lenger hadde kontakt. Dette anså 
jeg som et vesentlig funn da det tilsynelatende ikke utløste en hendelse eller feil da 
containeren mistet tilkobling til plattformen. Da kjøperagenten ikke hadde flere selgere å 
besøke forsøkte den igjen å sende en melding til sin PingResponder. Dette forsøket fikk 
heller ikke noe svar og kjøperagenten ba igjen om å bli lagret på samme måte som i det 
første testscenario. 
Scenario 3: 
- Migrasjon fungerte som forventet 
- Frakobling av container ikke registrert av RMA, dette var uventet. Heller ingen 
melding på terminalskjerm 
- Kommunikasjon mellom kjøperagent og lagringsagent som forventet 
- Lagring fungerte som forventet 
     
 80 
Jeg testet også å kjøre en kjøperagent uten å bruke en PingResponder. Jeg testet da om 
det var mulig å fange en hendelse når ikke agenten kunne migrere videre. Dette var etter 
hva jeg kan forstå ikke mulig og her stoppet bare agenten opp på noden hvor den siste 
selgeragenten befant seg. Det er mulig at det finnes en hendelse for å teste om en 
forespørsel om migrasjon går bra eller ikke, men jeg kunne ikke finne denne i JADE 
rammeverket. Det hjalp heller ikke at det nesten ikke fantes kommentarer i kildekoden til 
JADE.  
Scenario 4: 
- Migrasjon fungerte ikke som forventet, stoppet helt opp. Burde gått til neste  
node. Problemer med pingfunksjonalitet. 
- Ingen kommunikasjon mellom kjøperagent og lagringsagent 
-  Ingen lagring av kjøperagent 
I scenario to og tre jeg manuelt slettet containeren og koblet meg fra nettverket inntraff 
det samme hendelsesforløpet når jeg startet applikasjonen igjen. Som vanlig ble en ny 
instans av en UIAgent startet og denne sjekket en tekstfil for å se om den forrige 
kjøperagenten som ble sendt ut hadde kommet tilbake og overskrevet sitt navn med ordet 
returned. Når den fant at den ikke hadde overskrevet sitt navn to den kontakt med 
lagringsagenten. Den ba så om at lagringsagenten skulle rekonstruere en lagret 
kjøperagent med navnet som var skrevet i tekstfilen. Lagringsagenten fant en slik agent i 
databasen og rekonstruerte denne. Videre tok den rekonstruerte agenten selv kontakt med 
UIAgent og sendte over sine resultater i form av en ACL melding. Resultatene ble så 
fremvist i terminalvinduet på min bærbare maskin. Testen var vellykket og jeg hadde fått 
tilbake resultatene. 
 Scenario 2, 3: 
 - Henting av resultat fungerte som forventet 
 - Resultat var et tilbud på flybillett fra Oslo til London 
 Scenario 4: 
 - Intet resultat 
5.3 Test av skalerbarhet 
Som jeg skrev i begynnelsen av dette kapitlet har jeg ikke hatt muligheten til å teste 
skalerbarheten av mitt løsningsforslag. Jeg vil derfor skissere hvordan dette kunne ha 
vært testet.  
     
 81 
Det interessante å teste i forhold til skalerbarhet i denne prototypen hadde vært hvor 
effektiv lagringsagenten var til å ta i mot forespørsler på lagring. Dette kunne ha blitt 
testet ved å lage et testscenario hvor en agent dynamisk laget flere andre agenter. 
Agenten som ble laget ville kun ha en funksjon, nemlig å forsøke å lagre seg ved å 
kontakte lagringsagenten. Jeg ville så kjørt tester med varierende antall agenter for å 
vurdere hvor stort antall forespørsler en lagringsagent kunne ta i mot før dette resulterte i 
forsinkelser i systemet.  
I dette kapitlet har jeg sett på resultatene av mitt forslag til en agentarkitektur. Jeg 
begynte med å presentere en generell løsning for å sikre retur av resultater fra en mobil 
agent. Så beskrev jeg testing av systemet. Jeg avsluttet med å skissere hvordan jeg ville 
ha testet skalerbarhet i forhold til lagringsagenten. 
 
 
 
     
 82 
 
6 DISKUSJON 
 
I dette kapitlet tar jeg sikte på å undersøke tidligere arbeid og resultater i forhold til 
håndtering av returnerende agenter som ikke kan kontakte sin hjemmeplattform. 
Resultatet av dette arbeidet vil være et forslag til en generell løsning samt å utvikle en 
samling klasser og agenter samlet i et API til bruk med JADE plattformen. Jeg vil i dette 
kapitlet gå gjennom litteratur som omhandler min problemstilling. Jeg vil begynne med 
en kort introduksjon til litteraturen jeg har gjennomgått i forbindelse med denne 
oppgaven. Videre vil jeg presentere en klassifisering av tidligere foreslåtte løsninger. Jeg 
vil i den forbindelse presentere hovedtrekk ved de forskjellige løsningstypene. Så følger 
et kort gjensyn med terminalmobilitet. Kapitlet avsluttes så med en mer detaljert 
gjennomgang av løsningstypene jeg kom frem til i min klassifisering. 
 
6.1 Tidligere arbeider 
 
I min gjennomgang av litteratur om agenter og agentsystemer har jeg funnet flere typer 
løsninger relatert til problemet med en returnerende agent som ikke kan kontakte sin 
hjemmeplattform. Ikke alle disse artiklene er spesifikt opp feiltoleranse i forhold til en 
mobil klient som mister nettverkskontakt etter å ha sendt ut en mobil klient. Det 
eksisterer dog en betydelig mengde litteratur knyttet til feiltoleranse i forhold til mobile 
og transaksjonsorienterte (transactional) agenter. Her finnes det flere forslag til mulige 
løsninger for feilsikring ved situasjoner hvor eksekvering av en agent blir avbrutt som 
følge av systembrudd eller andre uopprettelige feil på noden den kjører på. Pleich et. al 
klassifiserer og analyserer i sin artikkel [81] flere foreslåtte løsninger for slik 
feiltoleranse. Jeg har valgt å ta med et utvalg av disse løsningene. Jeg har også sett på 
ulike løsninger for terminalmobilitet og delvis frakoblet operasjon (partially disconnected 
operation). Her har jeg blant annet sett på caching som beskrevet av Huizinga og 
Heflinger i deres artikkel om erfaringer med tilkoblede og delvis tilkoblede bærbare 
maskiner i distribuerte systemer [82]. Selv om problematikken er lignende er ikke denne 
dette en fullgod løsning da den baserer seg på lagring av informasjon på en klient slik at 
denne kan fortsette prosessering selv om den er frakoblet fra nettverket. En slik løsning er 
ikke tilfredsstillende da den bryter mot en av hovedmålsetningene for agentsystemer 
nemlig å redusere slik lokal lagring av informasjon og trafikk over nettverket. 
 
Agentsystemer er ennå ikke tatt i bruk i stor utstrekning som et kommersielt verktøy og 
en av grunnene til det er at det fortsatt er store utfordringer som må løses, spesielt i 
forhold til sikkerhet. I denne sammenhengen er kanskje ikke problematikken med en 
returnerende agent ansett som like prekær. Allikevel mener jeg at det en viktig oppgave 
for et system som benytter mobile agenter å sørge for at disse returnerer til sine brukere 
med et resultat. Hvis brukeren ikke kan være rimelig sikker på at agenten vil returnere 
med et resultat så faller jo etter min mening mye av anvendbarheten til et agentsystem 
bort. Hvis det skulle inntreffe at en mobil agent ikke kan returnere med sine resultater vil 
ressurser på den lokale og de fjerne nodene samt nettverkstrafikken skapt av agenten 
være brukt forgjeves. Fra en bruker sitt synspunkt er det også tenkelig at tiltroen til et 
slikt system vil bli sterkt redusert hvis man ikke er sikker på å få et resultat. Jeg mener 
     
 83 
det er spesielt viktig for systemer hvor agenten skal forhandle eller utføre et salg/kjøp på 
veiene av en bruker. Jeg mener at det er rimelig å anta at en potensiell bruker av et 
agentsystem vil være skeptisk til å ta dette i bruk hvis han ikke har en forsikring om at 
han vil ha kontroll med hva agenten gjør. Hvis agenten ikke kommer tilbake er det jo 
ingen måte å vite sikkert hva agenten har gjort på veiene av brukeren. En agent som ikke 
returnerer kan også være en sikkerhetsrisiko da den etterlater seg en åpning inn i bruken 
sitt system. Hvis ikke agenten sikkert returnerer sine resultater på en veldefinert måte er 
det en mulighet for at andre kan utnytte at den mobile terminalen venter på en slik retur.   
 
6.1.1 Avgrensning 
 
For å forsøke å gi et helhetlig bilde av metoder for feiltoleranse i forhold til mobile 
agenter har jeg valgt å utvide fokus noe. Jeg har derfor tatt med løsninger for feiltoleranse 
for mobile agenter som ikke når frem til sin destinasjon selv om ikke dette er i 
forbindelse med retur. Jeg har også sett på mekanismer for å sikre mobile agenter i ett 
miljø hvor noen av aktørene kan være fiendtlige. Jeg har valgt å ta med disse forslagene 
fordi jeg mener de kan ha likheter med min problemstilling og relevans for løsningen av 
denne.  
 
Jeg vil nå gjøre en generell inndeling av de ulike løsningstypene jeg har funnet frem til i 
litteraturen. Jeg vil i den forbindelse plassere mitt løsningsforslag inn i denne 
klassifiseringen. Jeg vil her ta med løsninger som ikke direkte er laget for å sikre en 
agents retur, men også ta med løsningstyper som kan utgjøre en del av en endelig løsning. 
Jeg vil forsøke å utlede de generelle prinsipper ved de ulike løsningstypene og så 
presentere ett eksempel på hver av dem i noe mer detalj. I beskrivelsen vil jeg forsøke å 
vurdere styrker og svakheter ved løsningene. 
 
6.1.2 Klassifisering 
 
Grovt sett vil jeg klassifisere de ulike løsningene for feiltoleranse i forhold til agenter 
som ikke når frem til en destinasjon i fire hovedtyper. 
 
6.1.2.1 Sentral lagring / docking 
 
Løsninger som involverer en slags møteplass eller sikker havn for agenter. Denne typen 
løsning har blitt foreslått i ulike former av flere forskningsgrupper [ 83, 84, 85, 86]. 
Motivasjonen for å ha en slik havn er flerdelt. Maes et. al [84] foreslår en slik enhet slik 
at agenter som agerer som kjøpere og selgere kan møtes på ett sikkert og nøytralt sted 
mens Lange og Kotz et al. [85, 86] benytter den som en ren lagringsplass. Felles for disse 
ulike typene bruk av en agenthavn er at noden den kjører på er statisk og forutsettes å 
alltid være tilgjengelig. Jeg vil kalle denne gruppen løsinger docking-baserte løsninger. 
Min løsning vil ligge nærmest opp til denne løsningstypen. 
 
 
 
 
     
 84 
6.1.2.2 Replikasjon / delegasjon 
 
Den neste kategorien løsninger er ikke nødvendigvis direkte koblet til en returnerende 
agent. Disse løsninger baserer seg på en oppdeling av oppgavene til en agent og 
delegering av ansvar fra en hovedagent til underagenter. Brukeren sender ut en agent som 
så starter en eller flere underagenter som den instruerer til å utføre oppgaver. I noen 
tilfeller reiser så hovedagenten videre selv eller den blir igjen og venter på sine ”barn”. 
Denne typen system er foreslått av blant annet Das et al [87]  som en løsning på 
problemer knyttet til agentsikkerhet og for å bedre feiltoleranse og effektivitet.  Det å 
delegere oppgaver til underagenter løser jo ikke problemet med at en returnerende agent 
ikke kan komme hjem, men det kan være en del av en løsning. For eksempel har Kaneda 
et al. [88] foreslått et system hvor den mobile agenten legger igjen en surrogat agent hver 
gang den skal forflytte seg til neste destinasjon. På denne måten kan systemet tolerere feil 
som oppstår på noden agenten befinner seg på ved å droppe agenten og fortsette med 
surrogatet. Det er også utviklet forslag til agentsystemer som benytter en struktur hvor 
spesielle agenter er ansvarlige for de ulike oppgavene assosiert med å migrere agenter. Et 
slikt forslag ble fremlagt av Satho i hans artikkel om adaptive protokoller for agent 
migrasjon [89]. Jeg vil komme tilbake til denne metoden senere i dette kapitlet. Jeg vil 
kalle denne gruppen løsninger replikasjon/delegasjonsbaserte løsninger 
 
6.1.2.3 Resultatorientert 
 
Den tredje hovedkategorien av løsninger som kan benyttes for å sikre at en mobil agent 
får levert sine resultater til brukeren sender ikke agenten tilbake i det hele tatt. I stedet 
benytter agenten ressurser på den noden den befinner seg på når den har utført sitt 
oppdrag til å sende sine resultater i form av en e-post eller en annen meldingstype som 
MMS. Denne metoden for å returnere resultater har blitt foreslått som et alternativ til at 
agenten selv returnerer av blant annet Falchuk og Karmouch i forbindelse med deres 
utvikling av et interaktivt dokumentsystem [90]. Jeg vil kalle denne gruppen av løsninger 
for resultatorienterte løsninger da fokuset er å returnere resultatet og ikke agenten. 
 
6.1.2.4 Klientinitiert retur 
 
Den siste kategorien med løsninger baserer seg på at agenten skal gjenkalles eller hentes 
av klienten som startet den. Hvis klienten selv initierer retur av en mobil agent burde 
dette øke sjansene for at agenten kommer frem. Dette er en fremgangsmåte som blant 
annet Wang et. al har foreslått å bruke i agentsystemer hvor klientene kjøres på PDA eller 
mobiltelefon [91]. Jeg vil kalle disse løsningene for klientinitiert retur. Denne 
løsningstypen krever implisitt også at det enten finnes en statisk node klienten skal kunne 
kalle agenten tilbake fra eller at agenten følger en statisk reiseplan.  
 
6.1.3 Kriterium for klassifisering 
 
Jeg har forsøkt å klassifisere disse fire løsningstypene ut fra fire aspekter ved løsningene. 
Disse aspektene er: 
 
     
 85 
6.1.3.1 Statisk node  
Gjør løsningen bruk av en statisk node, eller forutsettes det at klienten kjenner til agenten 
sin reiseplan slik at den kan hente agenten igjen. 
 
6.1.3.2 Sikkerhet 
Hvor sikker er denne løsningen. Med sikkerhet tenker jeg her spesifikt på mulighetene for 
en tredjepart til å endre agentens resultater eller måten den opererer på. 
 
6.1.3.3 Eksterne Ressurser 
Krever denne løsningen bruk av eksterne ressurser? Med eksterne ressurser menes her 
ressurser som ikke direkte er koblet til et agentsystem sin grunnfunksjonalitet slik som 
for eksempel meldingstjenester og meldingstransportprotokoller. 
 
6.1.3.4 Autonomi  
I hvor stor grad har den mobile agenten selv kontroll over hvordan den håndterer 
situasjoner hvor den ikke kan kontakte sin hjemmeplattform.  
 
6.1.3.5 Garanti  
I hvor stor grad sikrer løsningen at sluttbrukeren får tilbake et resultat. 
 
 
 Statisk 
node 
Eksterne 
ressurser 
Sikkerhet  Autonomi Garanti 
Docking-basert Ja Database Høy Høy Høy 
Replikasjon/Delegasjon Nei Nei Høy Høy Middels 
Resultatorientert Nei Meldingstjeneste 
(SMTP, MMS..) 
Lav Høy Høy 
Klientinitiert retur Nei Nei Middels N/A Middels 
 
Figur 6.1: De fire løsningstypene og hvordan de relaterer til de fem dimensjonene av 
klassifikasjonen. 
 
Som jeg tidligere har nevnt finnes det mange forskjellige løsninger for terminalmobilitet 
slik som Mobile IP. Disse teknologiene kan sørge for at terminalen hvor en mobil agent 
sin hjemmeplattform kjører tilsynelatende alltid har den samme nettverksadressen. Dette 
løser problemet for en returnerende agent som ikke kjenner den nye adressen til sin 
hjemmenode. Agenten reiser over internettverket til den adressen den ble sendt ut fra, 
eller den adresse som er spesifisert som sluttpunkt i dens reiseplan hvis den benytter seg 
av en sådan. Vel fremme blir den så mottatt av en hjemmeagent (under Mobile IP) som 
videresender den til en fremmedagent som igjen sender den til brukerens terminal. Disse 
teknologiene løser langt på vei problemet, men det løser det ikke helt og medfører økt 
nettverkstrafikk. Siden Mobile IP benytter seg av agenter vil det så finnes et ekstra 
agentsystem som bruker ressurser. Siden noe av målsetningen bak bruk av agenter er å 
redusere trafikk over nettverk er dette ikke en fullgod løsning.  
 
     
 86 
Løsninger for terminalmobilitet løser altså noe av problemet, men har liten eller ingen 
verdi hvis terminalen er falt ut av nettverket. Dette kan skje ved at terminalen ikke har 
konstant kobling til nettverket noe som for eksempel er situasjonen i forhold til GPRS og 
de fleste WLAN koblinger. Eller det kan være at terminalen rett og slett har blitt skrudd 
av eller ikke kan kjøre på grunn av feil eller mangel på strøm. I en slik situasjon vil 
løsninger som Mobile IP lede den mobile agenten frem til det som var den riktige 
adressen hvor terminalen befant seg rett før den mistet kontakt med nettet, men her 
stopper det. Agenten vil i denne situasjonen være oppdelt i flere pakker og disse vil så 
legge seg i kø på ruteren hvor fjernagenten kjører. Etter en tid vil normalt køen på ruteren 
fylle seg opp og den vil droppe pakkene som inneholder agenten. Hvis så skjer vil 
agenten og dens resultat være tapt og nettverksressursene vil ha vært brukt forgjeves. 
 
Jeg vil nå se i mer detalj på de fire løsningstypene jeg har kategorisert. Jeg vil kort 
introdusere løsningstypen i noe mer detalj og så gi et eksempel på bruk. Jeg vil avslutte 
hver beskrivelse med en kritikk av hver av løsningstypene. 
 
6.2 Gjennomgang av løsningstyper 
 
6.2.1 Sentral lagring / docking 
 
Den første løsningstypen som jeg har kalt Sentral lagring / docking-basert benytter en 
lokasjon hvor returnerende agentene kan lagres hvis de ikke når frem til sin 
hjemmeplattform. Videre i dette dokumentet vil jeg referere til denne lokasjonen som en 
agenthavn. En agenthavn vil kunne takle problemet som oppstår hvis terminalen 
hjemmeplattformen kjører på ikke har kontakt med nettverket. En slik metode ble 
foreslått tidlig i litteraturen om agenter, nærmere bestemt av Rus et. al i deres artikkel om 
informasjonsagenter [92]. Forfatterne beskrev da bruken av en agenthavn (dock) i sin 
artikkel om transaksjonsorienterte agenter implementert i rammeverket Agent Tcl. Agent 
Tcl er et agentsystem implementert i programmeringsspråket Tcl som kan kjøre agenter 
skrevet i Tcl, Java eller Scheme. Agent Tcl støtter full mobilitet av agenter. Forfatterne 
av denne artikkelen innså at det kunne oppstå problemer i forbindelse med at det til 
enhver tid kunne være en eller flere frakoblet noder i systemet. I tillegg til at noen av 
nodene kunne være frakoblet kunne det også være at den enkelte node var overbelastet 
eller hadde en svak kobling til nettverket for eksempel gjennom en trådløs link. For å 
forhindre at en agent skulle bli sittende fast på en node uten kobling til nettverket foreslår 
forfatterne å utstyre hver agent med nettverkssensor funksjonalitet. Denne 
funksjonaliteten skulle eksponeres til agenten som ett sett med nettverksverktøy.  
 
En enkel variant av dette verktøyet benyttet den kjente applikasjonen ping. Ping er et 
verktøy skrevet av Mike Muuss for å teste nettverkskontakt med en spesifisert node [93]. 
Ping benytter echo funksjonen i ICMP (Internet Control Message Protocol) [94]. En liten 
pakke sendes gjennom nettverket til en spesifisert IP adresse. Maskinen som sendte 
denne pakken lytter så etter en responspakke fra mottakermaskinen. Hvis operasjonen er 
vellykket sendes en returpakke med informasjon om hvor mange hopp pakken gjorde før 
den nådde sin destinasjon og hvor lang tid det tok for pakken å gjøre hele reisen. Det er 
også mulig å implementere slik funksjonalitet på applikasjonsnivå for eksempel ved å 
     
 87 
lage enkle agenter som etteraper funksjonaliteten i Ping. I min prototyp har jeg benyttet 
meg av en slik struktur.  
   
Ved å benytte disse nettverkssensorene kunne Agent Tcl agenter oppdage om en node var 
mulig å nå over nettverket. På denne måten kunne disse agentene endre sine reiseplaner 
underveis. Den andre store gevinsten ved dette systemet er at returnerende agenter enkelt 
kan sjekke om klienten som kjører deres hjemmeplattform er mulig å nå. Hvis den ikke 
var mulig å nå endret agenten sin rute og la seg i en kø i en agenthavn. Under Agent Tcl 
systemet kan alle noder agere som en havn og alle noder har en assosiert havn. Alle noder 
har også en spesiell agent som kalles en Master-docking agent som kontrollerer lagring 
av agenter og som gir beskjed til klienten når denne kommer tilbake på nettveket. Noden 
som agerer som agenthavn vil da umiddelbart sende over agenter tilhørende klienten. I en 
situasjon hvor en node skal sende fra seg en eller flere agenter, men ikke er koblet til 
nettverket venter Master-docking agenten til kontakt oppnås og sender så ut alle ventende 
agenter. For å identifisere hvilken agenthavn en node skal legge seg på brukes det i Agent 
Tcl en navnekonvensjon hvor en node A har en havn som heter A_dock. Disse navnene 
er alias for maskinnavn og siden det er lov med flere alias per maskin kan en node være 
havn for flere klienter.  
 
Maes et. al [84] har foreslått å benytte en møteplass for agenter som skal kjøpe og selge. 
Hovedmålet for dette forslaget var ikke å sørge for at mobile agenter ikke ble strandet på 
noder uten kontakt med nettverket eller returnerende agenter som ikke når sin 
hjemmeplattform. Maes ser i stedet på sikkerhetsaspektet ved å delegere et kjøp eller et 
salg til en agent og sende denne til en fremmed vert for å utføre oppdraget. Dette kan 
potensielt være en risiko da det er fare for at den fremmede verten manipulerer agenten. 
Dette kan skje på flere måter, men da sikkerhet ikke er hovedfokus i denne oppgaven vil 
jeg ikke gå i detalj på hvordan dette kan skje. Jeg nøyer meg med å fastslå at det er en 
risiko for at en vert kan manipulere en agent eller resultatet av en forhandling mellom to 
agenter. Claessens et al. [95] tar for seg flere metoder for å sikre agenter som skal operere 
på noder som ikke er garantert sikre. Her kan det være en løsning å bruke en tredjepart 
som både kjøper og selger stoler på som agerer som en elektronisk markedsplass. Denne 
markedsplassen sørger for å tilby maskinressurser til agentene og tar seg av eventuell 
kryptering og merking/godkjenning av agentene. Jeg mener dette konseptet også kan 
utvides til å opptre som en agenthavn (dock). I dette scenario er det tenkelig at en 
kjøperagent kun reiser til en destinasjon, men forhandler med flere forskjellige selgere. 
Hvis kjøperagenten sin hjemmeplattform ikke er tilgjengelig etter forhandlingene er over 
kan markedsplassen lagre kjøperagenten. 
 
     
 88 
 
Figur 6.2: Viser docking løsning slik som den er beskrevet av Kotz et al. 
 
Løsningen beskrevet av Kotz et. al. [85, 86] ligger nært opp til den løsningen jeg vil 
foreslå i denne oppgaven. På samme måte som i Agent Tcl vil jeg benytte en agenthavn 
for å lagre returnerende agenter som ikke kan nå sin hjemmeplattform. Jeg vil også 
foreslå at alle klienter er tilknyttet en node som fungerer som en agenthavn. Til forskjell 
fra Agent Tcl vil jeg ikke gjøre det obligatorisk å kjøre en Master-docking agent på alle 
noder i systemet. Grunnen til det er at jeg mener dette er å legge til unødvendig 
funksjonalitet på mange noder som ikke har behov for eller interesse av å lagre agenter 
for senere henting av klienter. Eksempel på slike noder kan være nodene som kjører 
salgsagentene i mitt testsystem. Disse nodene har kun statiske agenter og har derfor ikke 
behov for å sikre retur av mobile agenter. Slike noder kan i høyeste grad ha behov for 
feilsikring, men det vil være av en annen type en å sikre retur. Denne strukturen er etter 
mitt skjønn ikke hensiktmessig i et agentsystem som hvor hovedfokus er å formidle kjøp 
og salg av produkter, i dette tilfellet flybilletter. Jeg forutsetter at dette er et system hvor 
det finnes et antall selgere som en kjøperagent skal besøke.  
 
Marques et al. [96] har også foreslått en løsning som også benytter seg av en 
persistensmekanisme for mobile agenter. Denne løsningen benytter seg av et sentralt 
lager. Deres agentsystem er skrevet i Java og er bygget opp ved bruk av separate 
komponenter for å konstruere et agentsystem. For eksempel finnes det en 
mobilitetskomponent som tar seg av alle oppgaver relatert til migrasjon og kloning av 
agenter. Dette systemet er bygget rundt hendelser (events) og det finnes en spesiell 
hendelse som utløses når en agent ikke kan migrere tilbake til sin klient. Når denne 
hendelsen utløses bruker systemet en komponent kalt Disconnected Computing Service 
som igjen kaller en Persistence Store Service som tar seg av å lagre agenten. Etter at 
klienten igjen er tilgjengelig sier den fra til en sentral enhet og den lagrede agenten hentes 
ut av lagring og forsøker å migrere tilbake til klienten på nytt. Denne artikkelen nevner 
ikke hvordan klienten vet om den mobile agenten har returnert. Dette er en løsning som 
ligger nært opp til hva jeg har foreslått, men som skiller seg ved at den ikke benytter en 
     
 89 
reiseplan da agentene i dette systemet er beregnet kun å migrere fra en agent til en 
applikasjonstjener og så tilbake igjen. Disse agentene er altså enkelthoppagenter. Denne 
arkitekturen benytter seg heller ikke av noen form for nettverksverktøy slik at det ikke er 
mulig for en agent å forutse at den ikke kan migrere til neste node som i dette tilfellet er 
tilbake til klienten.   
  
6.2.2 Replikasjon / delegasjon 
 
Den andre hovedtypen av løsninger som jeg har valgt å kalle replikasjon/delegasjon 
baserte løsninger baserer seg i hovedsak på å dele en agent sine oppgaver mellom flere 
agenter.  
 
Satho har i sin artikkel [89] om adaptive protokoller for agentmigrasjon foreslått et 
rammeverk for mobile agenter. Dette rammeverket er bygget opp på med den målsetning 
å gjøre det mulig for en mobil agent å dynamisk endre sin migrasjonsprotokoll fra for 
eksempel TCP til UDP samt å oppdatere sin reiseplan underveis. Satho bemerker at det 
ikke finnes noen rammeverk som støtter slik dynamisk endring av reiseplan og protokoll 
for migrasjon. Han trekker frem Aglets intinerary mønster og ADK sitt hierarki av 
komponenter for å bygge mobile agenter med reiseplan. Hos begge disse rammeverkene 
er reiseplanen en statisk enhet som manuelt må legges til den mobile agenten. Satho 
benytter seg av en hierarkisk inndeling av agenter og lar agenter migrere til hverandre. 
Dette betyr at en agent kan bestå av flere indre agenter.  
 
Målet med denne arkitekturen er å la bestemte agenter ta seg av migrasjon og 
transportprotokoller til motsetning fra å la miljøet agentene kjører i ta seg av dette. På den 
måten kan agentsystemet agere som et aktivt nettverk der hver node har ett sett av agenter 
som tar seg av navigasjon og transport av agenter. For eksempel finnes det en agent som 
kalles en Transmitter agent. Når en mobil agent vil forflytte seg migrerer den først inn i 
Transmitter agenten og benytter de tjenestene den tilbyr. Transmitter agenten er ansvarlig 
for å for å etablere en punkt-til-punkt kanal mellom seg selv og sitt motstykke på noden 
den mobile agenten skal migrere til. Når den har satt opp en slik kanal serialiserer den 
agenten og sender den til dens destinasjon. Hvis det ikke finnes noen Transmitter agent 
på destinasjonsnoden kan denne selv migrere til noden for å utvide det tilgjengelige 
nettverket av agenter. Satho foreslår to ulike varianter av Transmission agenter – 
Navigator agenter eller videresendingsagenter (Forwarding agents). 
Videresendingsagenter er spredt ut over nettverket og samarbeider for å transportere en 
mobil agent til dens destinasjon. Når videresendingsagenten mottar en forespørsel fra en 
mobil agent forsøker den å levere denne til den forespurte destinasjonen. Hvis den ikke 
klarer å gjøre dette leverer den agenten til den videresendingsagenten som er nærmest 
ønsket destinasjon. Videresendingsagenten som er nærmest vil forsøke å videresende 
agenten til dens destinasjon gjentatte ganger inntil agenter når destinasjonen. Figur 6.3 
viser en grafisk fremstilling av migrasjon ved hjelp av videresendingsagenter. 
 
     
 90 
 
Figur 6.3: Eksempel på migrasjon via Forwarder agent 
 
Satho sin løsning vil potensielt kunne løse problemet med å nå frem til en node som i en 
periode er utilgjengelig. Hvis noden som det ikke er mulig å nå frem til er lokasjonen til 
hjemmeplattformen kan den returnerende agenten sendes over så snart det opprettes 
kontakt med nettverket igjen. Jeg forutsetter her at det finnes en viss tidsbegrensning for 
hvor lenge en videresendingsagent vil forsøke å sende en agent før den avslutter. For at 
denne løsningen skal fungere uten noen form for håndtering av terminalmobilitet må 
klienten ha den samme IP adressen når den gjenoppretter kontakten med nettverket. I 
forhold til min problemstilling vil denne løsningen ikke være fullgod hvis terminalen har 
skiftet IP adresse. Så lenge det ikke finnes noe sentralt register hvor klienter registrerer 
seg og blir tildelt en unik identitet finnes det ingen mekanisme i dette systemet for å 
lokalisere hjemmeplattformen til en agent hvis noden den kjører på har endret adresse. 
Min oppfatning er at en slik videresending av agent til hjemmeplattform med ny adresse 
kun kan skje ved bruk av et sentralt register. En klient sin identitet må kobles til en 
hjemmeplattform og en adresse. Denne løsningen er derfor mangelfull i forhold til å sikre 
retur av en mobil agent.  
 
6.2.3 Resultatorientert 
 
Den tredje hovedtypen av løsninger er mobile agenter som selv ikke returnerer til sitt 
utgangspunkt etter endt oppdrag, men i stedet kun returnerer resultatet av sitt arbeid. 
Resultatet returneres i form av en e-post eller en annen meldingstype som SMS eller 
MMS. Jeg har ikke funnet frem til noe agentsystem som baserer seg utelukkende på 
denne løsningen, men det finnes systemer hvor dette er opp til brukeren å bestemme.  
 
I sin artikkel [90] om et interaktivt dokumentsystem benytter Falchuk og Karmouch seg 
av et grafisk grensesnitt for konfigurasjon av systemets mobile agenter. I dette systemet 
samler de mobile agentene inn dokumenter på veiene av en bruker. Normalt vil flyten i en 
     
 91 
slik operasjon være at brukeren konfigurerer agenten via grensesnittet, sender agenten til 
en fjern node hvor den skal søke etter dokumenter som samsvarer med kriterier satt av 
brukeren. Etter agenten er ferdig med å samle dokumenter reiser den enten videre til 
andre destinasjoner for å samle mer informasjon eller forsøker å returnere data tilbake til 
brukeren. Normal vil retur av data dette skje ved at agenten selv returnerer til brukeren. 
Når en agent skal returnere benytter den seg av en såkalt tilrettelegger agent som er en del 
av agentplattformen den kjører på. Tilretteleggeren forsøker å oppnå kontakt med 
hjemmeplattform til den mobile agenten, hvis kontakt opprettes sendes agenten tilbake til 
brukeren. Forfatterne har ikke gått nærmere inn på hva som skjer hvis det ikke lykkes å 
oppnå kontakt. Hvorfor de ikke har beskrevet dette er vanskelig å si, men en grunn kan 
være at de ser for seg et internt nettverk som omfatter brukere og dokumenttjenere hvor 
alle maskiner er statiske terminaler. Dette kan muligens være gyldig i en 
kontorsammenheng, men det er etter min mening en ikke en god løsning for dagens 
heterogene nettverk med flere forskjellige aksessteknologier som for eksempel IEEE 
802.1.  
 
Dokumentsystemet til Falchuk og Karmouch inneholder en mulig løsning for klienter 
som har ustabil nettverkstilgang eller på annen måte ofte mister kontakt eller skifter IP 
adresse. Løsningen ligger i muligheten til å konfigurere en agent til å returnere sine 
resultater i form av en e-post. Denne typen retur av resultater ivaretar den asynkrone 
naturen til en agent; en klient kan sende en agent ut for å innhente tilbud og så koble seg 
fra nettverket. Når agenten er klar med sitt oppdrag sender den resultatene tilbake, men 
det er først når klienten velger å koble seg til nettverket igjen at resultatene leveres. Det 
er også tenkelig at dette systemet kan utvides til å omfatte andre meldingstyper som SMS 
eller SMS slik at det også kan benyttes av mobilbrukere uten tilgang til e-post. Figur 6.4 
viser flyten i denne løsningen  
 
 
 
Figur 6.4: Illustrerer flyten i en resultatorientert løsning hvor resultatet legges inn i en e-
post og sendes til brukeren sin postboks. 
 
     
 92 
Problemet med denne typen løsning er flerdelt slik jeg ser det. For det første er det ikke 
sikkert at agenten har tilgang til ressursene den trenger for å sende en e-post. Noden den 
befinner seg på må i så fall ha en posttjener installert ellers må agenten selv bære med seg 
en SMTP-tjener. Hvis det siste er tilfellet vil dette føre til en økning av agentens kode 
som den må overføre mellom noder. Et av målene med agenter er jo å minske trafikk på 
nettverket så unødige økninger av agenten sin egen størrelse er uønsket. Den andre 
grunnen til at e-post kanskje ikke er en optimal måte å levere resultater på er sikkerhet. 
Det har i en årrekke vært problemer med såkalt Spam, uønsket e-post. En av metodene 
slike "spammere" benytter seg av er å kapre andre organisasjoner eller privatpersoner 
sine posttjenere for så å benytte disse til å sende ut tusenvis av e-post. Porter tar i sin 
artikkel for seg bruk av spam [97]. Dette hjelper til å skjule identiteten til den som sender 
ut spam og er samtidig en kostnadseffektiv løsning siden man stjeler båndbredde. Hvis en 
mobil agent skal ha tilgang til ressurser som e-post kan dette utgjøre en betydelig 
sikkerhetsrisiko. Potensielt ondsinnede agenter kan for eksempel klone seg selv over til 
flere noder og benytte epostjenerne på maskinene og på den måten sette opp et distribuert 
postsystem. Den tredje grunnen til at jeg mener denne fremgangsmåten kan være 
problematisk er også knyttet til sikkerhet, men sett fra agenten eller sluttbrukeren sitt 
ståsted. En agent løper en høyere risiko for å avsløre sine resultater til en tredjepart ved å 
gjøre disse om til en melding slik som en e-post. Hvis ikke agenten selv bærer med seg en 
e-posttjener må den bruke en som gjøres tilgjengelig av noden den kjører på. I denne 
fasen kan en tredjepart for eksempel ta en kopi av agenten sine resultater ved å beholde 
en kopi av den sendte meldingen. Det er også en sjanse for at denne tredjeparten kan 
endre denne informasjonen eller på annen måte benytte den til sin fordel. I scenario som 
inneholder økonomiske transaksjoner eller hvor annen konfidensiell informasjon bæres 
av en agent kan dette være et svakt punkt i systemet.  
 
6.2.4 Klientinitiert retur 
 
Den siste løsningstypen som jeg har valgt å kalle klientinitiert retur er det som navnet 
tilsier klienten som er ansvarlig for å tilbakekalle en mobil agent. Denne fremgangsmåten 
er benyttet av Wang et. al i deres agentsystem. Forfatterne av denne artikkelen har laget 
en høynivåarkitektur for et agentsystem som kan kjøres på klienter med begrensede 
ressurser. En av karakteristikkene ved deres system er at de skiller agentkode fra data og 
grensesnitt for bruker. På denne måten kan en klient med begrensede ressurser slik som 
en mobiltelefon kun kjøre et grensesnitt som lar en bruker konfigurere en mobil agent. 
Dette er en metode som også er benyttet av andre rammeverk for agenter slik som JADE 
som har ett tillegg kalt LEAP [98] for å kjøre agenter på begrensede enheter. Når 
brukeren har konfigurert agenten sendes data over til en agenttjener som kjører på en 
statisk node. Her settes agenten opp med data fra bruker og sendes så ut til sin 
destinasjon. Forfatterne bemerker at det vil være problematisk å sende en agent direkte 
tilbake til sin destinasjon fordi klientene ofte vil være uten nettverkstilgang. Derfor har de 
satt opp en kø på agenttjeneren hvor returnerende agenter legges til de blir hentet. Denne 
løsningen er meget lik løsningen til Kotz; agenttjeneren fungerer her som agenthavn for 
mobile agenter. Figur 6.5 illustrer konseptet med en ”delt” container. 
 
 
     
 93 
 
 
Figur 6.5: Illustrasjon av deling av agentcontainer under JADE-LEAP oppsett. I delt 
eksekverings modus har den mobile terminalen kun grensesnittfunksjonalitet. 
 
En forskjell mellom de to løsningene er at mens Kotz et. al [95, 96] benytter seg av en 
navnekonvensjon for å identifisere de ulike agenthavnene benytter Wang et. al [91] en 
unik id for å identifisere en agent. Ved splitting av agenten mellom en klient og en 
agenttjener må nødvendigvis klienten holde en referanse til denne agenttjeneren. Denne 
referansen kan for eksempel være en kombinasjon av IP adresse, portnummer og navn på 
tjenester tilbudt av agenttjeneren. Med denne referansen og det unike 
identifikasjonsnummeret kan brukeren hente data fra sin mobile agent til enhver tid.  
 
En annen fundamental forskjell mellom denne typen løsning og løsninger som benytter 
en agenthavn er at den splitter opp agenten. I realiteten eksisterer det ikke noen agent på 
klienten. Klienten holder kun en referanse til den statiske noden og har noe logikk utover 
det som behøves for å vise frem et grafisk brukergrensesnitt. En slik deling har tvunget 
seg frem på bakgrunn av manglende kapasitet på de mobile enhetene. Dette mener jeg 
innen kort tid vil være et problem som ikke finnes lenger da utviklingen for mobile 
enheter går raskt fremover og leverandører stadig slipper nye enheter med større 
kapasitet. 
     
 94 
 
Denne delingen av oppgaver mellom den mobile terminalen og den statiske noden er etter 
min mening ikke nødvendig for å sikre at en agent skal kunne komme seg tilbake. Jeg 
tror denne løsningen vil medføre økt nettverkstrafikk og økt bruk av lokale ressurser sett i 
forhold til løsninger med en agenthavn som agenten kun reiser til hvis det ikke er mulig å 
returnere på vanlig måte. Videre mener jeg dette tar vekk noe av agenten sin autonome 
karakter da den ikke selv velger ut fra de gitte omstendigheter (les: nettverkssituasjon) 
om den skal returnere til sin hjemmeplattform. 
 
I dette kapitlet har jeg sett på tidligere publiserte løsninger. Jeg har laget en klassifikasjon 
av disse løsningene og inndelt disse i fire grupper. Disse fire gruppene av løsninger ble så 
satt opp mot hverandre i forhold til sikring av resultater fra en mobil agent. Videre 
presenterte jeg de forskjellige gruppene av løsninger i noe mer detalj og forsøkte å 
kritiserer svakheter eller mangler. I det neste kapitlet vil jeg oppsummere mine funn og 
erfaringer med denne oppgaven. 
 
     
 95 
 
7 KONKLUSJON 
 
I dette kapitlet vil jeg oppsummere mine funn i forbindelse med min målsetting om å lage 
en mekanisme for å sikre resultatene til en mobil agent. Jeg vil først gå gjennom mine 
funn og gjøre en oppsummering av disse. Videre vil jeg komme inn på hva jeg har lært av 
denne oppgaven. Avslutningsvis vil jeg gi noen forslag til forbedringer og videre arbeid 
med min foreslåtte løsning. 
 
7.1 Problemer med agentsystem 
 
Når jeg begynte på denne oppgaven var jeg interessert i å utforske bruken av agenter og 
fleragentsystem i forhold til kjøp og salg av flybilletter. Etter å ha undersøkt flere 
eksempler på slike system fant jeg at de ikke er særlig utbredt i kommersiell bruk. Bruken 
av agenter for salgssystemer er ennå stort sett forbeholdt forskningsinstitusjoner. Jeg fant 
at agenter er i bruk i flere typer nettverksløsninger som for eksempel Mobile IP, men de 
er ennå ikke særlig utbredt som et verktøy for kjøp og salg. Det kan være flere grunner til 
dette og jeg fant problemer i forhold til sikkerhet, standardisering og brukeaksept. 
Problemer med sikkerhet er alvorlige og er gjenstand for utstrakt forskning, men var ikke 
hovedfokus i denne oppgaven. Standardisering av agentsystemer og kommunikasjon 
mellom ulike agentplattformer er også i et tidlig stadium og her er det rom for videre 
arbeid. FIPA ser ut til å være den organisasjonen som har fått størst aksept i agentmiljøet 
for sine forsøk på å utarbeide standarder for agentsystemer. I kapitel 2 så jeg på deres 
arbeid med å utarbeide et felles språk, ACL, slik at agenter fra ulike plattformer kan 
kommunisere på en veldefinert måte. Jeg så også på deres arbeid med å lage en 
spesifikasjon for en abstrakt modell for agentplattformer. Denne modellen var også 
grunnlaget for rammeverket, JADE, som jeg benyttet meg av for å lage mitt testsystem.  
 
7.2 Løsningsforslag for resultatsikring 
 
Jeg skrev i innledningskapitlet at det er et usikkerhetsmoment forbundet med om en 
mobil agent vil returnere med et resultat. Jeg fremmet så påstanden at dette kan være en 
faktor til at bruken av agentsystemer ennå ikke har fått en vid utbredelse. Etter å ha 
undersøkt litteratur om agenter står jeg fortsatt ved den påstanden og har foreslått en 
enkel persistensbasert mekanisme som en løsning på dette problemet. Strukturen i mitt 
forslag baserte seg på elementer fra flere tidligere publiserte løsninger. Spesifikt tok jeg i 
bruk et designmønster for agenter kalt Itinerary - en reiseplan. Dette involverte bruken av 
et eksternt objekt som inneholdt en datastruktur for å holde en reiseplan og metoder for å 
oppdatere og hente ut lokasjoner som en mobil agent kunne migrere til. Jeg kombinerte 
dette designmønstret med et enkelt nettverksverktøy som bygger på applikasjonen Ping. 
Med denne kombinasjonen utstyrte jeg en mobil agent med en metode for å undersøke 
om en node var tilgjengelig. Den mobile agenten kunne så forsikre seg om at det var 
mulig å migrere til neste node før den utførte selve migrasjonen. Min målsetning var å 
sikre at resultatene til en mobil agent ikke gikk tapt selv om den ikke kunne migrere 
tilbake til sitt utgangspunkt. For å sikre dette introduserte jeg en sentral 
persistensmekanisme. Persistensmekanismen ble realisert i form av en lagringsagent og 
     
 96 
en relasjonsdatabase. Lagringsagenten var en sentral del av mitt løsningsforslag og hadde 
alt ansvar forbundet med lagring av en agent. Jeg foreslo videre en enkel mekanisme for å 
hente ut resultatene fra en lagret agent. 
 
7.3 Hva har jeg lært 
 
I arbeidet med denne oppgaven har jeg tilegnet meg kunnskap om agenter og generelle 
problemstillinger knyttet til distribuerte system. Dette gjelder spesielt min forståelse av 
begrepet mobilitet og de tekniske aspektene knyttet til forflyttning av data over 
internettverk. Jeg har fått kjennskap til modeller for standardisering av agentplattformer 
og kommunikasjon mellom agenter. I forbindelse med arbeidet med å undersøke 
kommunikasjon mellom agenter har jeg også fått kjennskap til bruk av ontologier i 
forhold til agenter og nettbaserte tjenester.   
 
Jeg føler at mitt generelle kunnskapsnivå innenfor programmering og systemdesign har 
blitt styrket. Denne oppgaven har tvunget meg til å ta mange valg i forhold til design av 
løsning og bruk av teknologi. Jeg har fått bedre kjennskap til strukturen av komplekse 
system gjennom arbeidet med JADE og studier av kildekoden for dette 
agentrammeverket. Arbeidet med JADE har også lært meg er behovet for god 
dokumentasjon.  
 
Denne oppgaven har også lært meg noen viktige lekser i forhold til planlegging og 
organisering av et større arbeid. Jeg har lært hvor viktig det er å ha et klart mål og å 
arbeide planmessig mot dette målet. 
 
7.4: Erfaring med bruk av JADE 
Mye arbeid har gått med i utformingen av mitt testsystem. Jeg hadde på forhånd ingen 
erfaring med bruk av agenter og agentsystemer og har måttet tilegne meg denne 
kunnskapen underveies. Dette har vært en lærerik prosess selv om den har vært meget 
tidkrevende. Koden til testsystemet er på rundt 3000 linjer så systemet i seg selv er ikke 
spesielt stort, men systemet har vært gjenstand for utallige revisjoner. Jeg bestemte meg 
tidlig for å benytte meg av rammeverket JADE for å implementere mitt testsystem da 
dette var et prosjekt med åpen kildekode. Dette har i senere tid vist seg å ha både positive 
og negative sider. Det har vært nyttig å kunne se på kode til kjernefunksjonalitet i JADE 
og lærerik i forhold til hvordan et slikt system er bygget opp. Jeg har dog hatt noen 
problemer med feil i rammeverket og manglende dokumentasjon. Spesielt har fraværet av 
god dokumentasjon, både i kode og i form av brukerveiledninger økt arbeidsmengden 
betydelig. En positiv side med å bruke JADE har vært kommunikasjon med andre 
brukere av dette rammeverket. Jeg har blant annet vært i kontakt med en av skaperne av 
agentsystemet og flere andre ressurssterke individer fra hele verden som har gitt gode råd 
og hjelp underveis. 
 
 
 
 
     
 97 
7.5 Fremtidig arbeid 
 
Testsystemet jeg laget i forbindelse med denne oppgaven var meget enkelt og var kun 
ment å illustrere metoden med å lagre en mobil agent som ikke kunne migrere tilbake. 
For å lage en ramme rundt dette valgte jeg å bruke et scenario hvor en bruker ønsker å 
innhente priser på flybilletter. Jeg mener dette var et realistisk scenario i forhold til 
bransje og den tidligere nevnte praksis med dynamisk prising innenfor flybransjen. Slik 
jeg ser det har systemet mange muligheter for forbedringer. Dette er noen av de 
forslagene jeg mener kan være mest nyttige: 
  
• Kryptering av kommunikasjon mellom agenter 
 
Kryptering av kommunikasjon mellom agenter kan være en god strategi for å øke 
sikkerheten i et system som dreier seg om kjøp og salg. På den måten vil det være 
vanskeligere for en tredjepart å fange opp beskjeder som sendes mellom de ulike 
agentene. Det er også tenkelig at en kjøperagent kan kryptere sine resultater for å 
redusere muligheten for at en tredjepart ser på resultatene eller verre endrer de. 
 
• Grensesnitt for nettbaserte tjenester 
 
En naturlig utvidelse av dette testsystemet er å legge opp til at salgsagentene 
eksponerer grensesnitt for nettbaserte tjenester. På den måten kan en slik applikasjon 
knyttes opp mot det semantiske nettet. Det finnes allerede forslag til integrasjon 
mellom nettjenester (web services) og JADE. 
 
• Bedre nettverksverktøy 
 
Det er rom for en stor forbedring av nettverkverktøy kjøperagenten benytter seg av. 
Slik som systemet er nå har den kun tilgang til en enkel ping funksjon. Selv om denne 
funksjonaliteten er nok for å illustrere mitt løsningsforslag er det ønskelig med mer 
funksjonalitet. For eksempel kunne det vært bra med en funksjon for å teste 
gjennomsnittlig migrasjonstid til de forskjellige nodene som holder selgeragenter. 
Dette kan være spesielt nyttig i et system hvor nodene er distribuert over store 
avstander og det eksisterer mange selgere. I dette testsystemet eksisterte det også kun 
en test på om hjemmenoden var tilgjengelig. I et kommersielt system må det være 
krav til at alle noder implementerer en slik type funksjonalitet slik at den mobile 
agenten ikke stopper fordi neste lokasjon i reiseplanen ikke er tilgjengelig.  
  
• Utvidet funksjonalitet i reiseplanen 
 
Dette henger sammen med det foregående punktet. Med bedre nettverksverktøy kan 
en agent ha behov for å dynamisk kunne endre sin reiserute underveis. Det kan for 
eksempel hende at neste node i reiseplanen er overbelastet og at det vil være mer 
effektivt å hoppe over denne noden for senere å komme tilbake. 
   
• Valg av retur metode for agent 
     
 98 
 
Det bør være mulig for brukeren å bestemme om bare resultater skal returneres eller 
om hele agenten skal returnere. Jeg har i mitt testsystem tatt avgjørelsen å bare 
returnere resultatet, men jeg kan se noen argumenter for å returnere hele agenten. For 
eksempel kan det være ønskelig at agenten benytter en form for læring slik at den 
både tilpasser seg brukeren og dennes valg og at den utarbeider strategier for å 
innhente best mulig tilbud. 
 
• Bedre brukegrensesnitt 
 
Grensesnittet i dette testsystemet var meget spartansk og her er det store rom for 
utvidelser. For eksempel kan det være ønskelig med forskjellige sett med grensesnitt 
slik at systemet kan kjøres på terminaler som har mindre skjerm, for eksempel på en 
mobiltelefon. Det er også ønskelig at brukeren kan velge hvilken strategi agenten skal 
benytte seg av for å samle inn tilbud. Det å reise rundt til ulike selgere og hente tilbud 
er greit i og for seg, men ikke noe nytt i forhold til andre nettbaserte tjenester. For 
eksempel kunne det vært bra å sette en agent til å være med på en eller flere auksjoner 
på veiene av brukeren.  
 
     
 99 
 
LITTERATUR LISTE 
 
[1] Grover V., Teng J. T. C., “E-commerce and the information market”, 
Communications of the ACM, v.44 n.4, s.79-86, (2001) 
 
[2] Bakos Y.. "The Emerging Role of Electronic Marketplaces on the Internet", in: 
Communications of the ACM, (1998) 
 
[3] Appell K., Gressens B., og Brouseau C., “The value propositions of dyanamic pricing 
in business-to-business e-commerce,”, Defying the Limits: Reaching New Heights in 
Customer Relationship Management. San Francisco, CA: Montgomery Research, s. 237–
246. (2000) 
 
[4] Leloup B., Deveraux L., “Dynamic Pricing on the Internet: Theory and Simulations”, 
Electronic Commerce Research Volume 1, num 3,  s. 265 – 276 (2001)    
 
[5] Morris J., Ree P., Maes P., “Sardine: dynamic seller strategies in an auction 
marketplace”, Proceedings of the 2nd ACM conference on Electronic commerce, s.128-
134, (2000) 
 
[6] Morris D. J., Maes P., Greenwald A.: "Learning Curve: A Simulation-Based 
Approach to Dynamic Pricing.", Journal of Electronic Commerce Research. Vol 3, num 
3-4, s. 245-276, (2003) 
 
[7] Jayaraman V., Baker T.: ”The Internet as an enabler for dynamic pricing of goods”, 
Engineering Management, IEEE Transactions on Volume 50,  num. 4,  s. 470 – 477 
(2003) 
 
[8] Smith B.C., Günther D.P., Rao B. V., Ratliff R.M., “E-Commerce and Operations 
Research in Airline Planning, Marketing, and Distribution”, Interfaces, v.31 n.2, s.37-55, 
(2001) 
 
[9] Belobaba, Peter P., “Airline yield management: An overview of seat inventory 
control”, Transportation Science, Vol. 21, No 2, s. 63-73, (1987) 
 
[10]  Elmaghraby W., Gulcu A.,  Keskinocak P., “Analysis of a price markdown 
mechanism”, Proceedings of the Third International Workshop on Advanced Issues of E-
Commerce and Web-Based Information Systems, (2001)  
 
[11] Lawrence R.D., Hong S.J., Cherrier J., “Passenger-based predictive modeling of 
airline no-show rates”, Proceedings of the ninth ACM SIGKDD international conference 
on Knowledge discovery and data mining, (2003) 
 
     
 100 
[12] Chang Y.C., Li C.S., Smith J. R., “Searching dynamically bundled goods with 
pairwise relations”, Proceedings of the 4th ACM conference on Electronic commerce, 
s.135-143, (2003) 
 
[13] Morris D. J., Greenwald A., Maes P., “Dynamic pricing strategies under a finite time 
horizon”, Proceedings of the 3rd ACM conference on Electronic Commerce, s.95-104, 
(2001) 
 
[14] Kephart J. O., Hanson J. E., Greenwald A. R., “Dynamic pricing by software 
agents”, Computer Networks: The International Journal of Computer and 
Telecommunications Networking, v.32 n.6, s.731-752, (2000) 
 
[15] Greenwald A.R., Kephart J.O., Tesauro G. J., “Strategic pricebot dynamics”, 
Proceedings of the 1st ACM conference on Electronic commerce, s.58-67, (1999) 
 
[16] Deck C.A., Wilson B. J., “Interactions of automated pricing algorithms: an 
experimental investigation”, Proceedings of the 2nd ACM conference on Electronic 
commerce, s.77-85, (2000)  
 
[17] Dasgupta P., Hashimoto Y., “Multi-Attribute Dynamic Pricing for Online Markets 
Using Intelligent Agents”, Proceedings of the Third International Joint Conference on 
Autonomous Agents and Multiagent Systems - Volume 1 s. 277 - 284, (2004)  
 
[18] Jennings, N. R. Sycara, K. Wooldridge K.      
Autonomous Agents and Multi-Agent Systems, Volume 1 Issue 1  
“A Roadmap of Agent Research and Development” (1998) 
 
[19] Luck, M., d'Inverno, M. ”A Conceptual Framework for Agent Definition and 
Development”, The Computer Journal, issue 44(1), p1-20 (2001) 
 
[20] Etzioni O., Weld D.S. “Intelligent agents on the Internet: Fact, Fiction, and 
Forecast.”, IEEE Expert, 10(4), August (1995 
[21] Foster D., McGregor C., El-Masri S. “A Survey of Agent-Based Intelligent Decision 
Support Systems to Support Clinical Management and Research”  
First International Workshop on Multi-Agent Systems for Medicine, Computational 
Biology, and Bioinformatics (2005) 
[22] Weiss, G. Rovatsos, M. Nickles, M. “Capturing Agent Autonomy in Roles and 
XML”, International Conference on Autonomous Agents  
Proceedings of the second international joint conference on Autonomous agents and 
multiagent systems p: 105 – 112 (2003)  
 
[23] Russell S., Norvig  P. “Artificial Intelligence: A Modern Approach” Kap. 2 
“Intelligent Agents”, s ??, Prentice-Hall, Inc., (1995) 
 
     
 101 
[24] Bauer B., Muller J. P., og Odell J.. “Agent UML: A formalism for specifying 
multiagent software systems”. Int. Journal of Software Engineering and Knowledge 
Engineering, 11(3): s. 207 - 230, (2001) 
 
[25] Chaib-draa B., Dignum F.: “Trends in Agent Communication Language.”, 
Computational Intelligence 18(2): s 89-101 (2002) 
 
[26] Martin, I., Jose, J.M.: ”Fetch: A personalised information retrieval tool”. i: Proc. of 
the RIAO'2004 Conf. (2004) 
 
[27] Fikes, R, and Nils Nilsson: “STRIPS: A New Approach to the Application of 
Theorem Proving to Problem Solving”, Artificial Intelligence, Volum 2, no. 3,4, Januar, 
s. 189-208. (1971) 
 
[28] Green, S. Hurst, L. Nagle, B. Cunningham, P. Somers, F. and Evans, R “Software 
Agents: A review” (1997) 
URL http://www.cs.tcd.ie/research_groups/aig/iag/pubreview/chap2/chap2.html 
  
[29] Jennings, N. R. and Wooldridge, M. J. “Applications of Intelligent Agents.”, In 
Agent Technologies: Foundations, Applications, and Markets. N. R. Jennings and M. J. 
Wooldridge (1998) 
 
[30]  Peng S., Mukhopadhyay S.,. Raje R.R,  Palakal M. J., Mostafa J: “A Comparison 
Between Single-agent and Multi-agent Classification of Documents.”, IPDPS 2001: 90 
(2001) 
 
[31] Introduksjon om FIPA, lest på: http://www.fipa.org/index.html  09.10.2005 
 
[32] Serenko, A. and Detlor, B. “Agent toolkits: A general overview of the market and an 
assessment of instructor satisfaction with utilizing toolkits in the classroom.” Working 
Paper #455. Hamilton, Ontario, Michael G. DeGroote School of Business, McMaster 
University. (2002) “ 
 
[33] FIPA board: ”FIPA Abstract Architecture Specification”, URL: 
http://www.fipa.org/specs/fipa00001/SC00001L.pdf  (2002) 
 
[34] FIPA board: “FIPA Agent Management Specification”, URL: 
http://www.fipa.org/specs/fipa00023/SC00023K.pdf  (2004) 
 
[35] Bellifemine F., Caire G., Poggi A., Rimassa G., “JADE – A White Paper”, URL: 
http://jade.tilab.com/ (2003) 
 
[36] Gruber, T. R: “What is an ontology?”, URL: http://www.ksl.stanford.edu/kst/what-
is-an-ontology.html 
 
     
 102 
[37] Gruber, T. R: ”A Translation Approach to Portable Ontology Specifications”, 
Academic Press (1993) 
 
[38] Genesereth MR og Nilsson NJ: “Logical Foundations of Artificial Intelligence”,  
Morgan Kaufmann; pp 128-132 (1987) 
 
[39] Beuster G.: “Ontologies”, URL: http://www.uni-
koblenz.de/~gb/papers/2002_intro_talk_ontology_bang/agent_ontologies.pdf 
 
[40] Sujanani A., Ray P., Bhar R. og Paramesh N., “The Development of Ontology 
Driven Multi-Agent Systems: A Case Study in the Financial Services Domain”, 
Proceedings of the International Workshop on Business Services and Networks (BSN05), 
Hongkong, (2005) 
 
[41] W3C: “Semantic Web”, URL: http://www.w3.org/2001/sw/ 
[42] Bryson J., Martin D., McIlraith S. og Stein L.A.: “Semantic Web Services as 
Behavior-Oriented Agents”, IEEE Computer 35(11): s. 48-54, (2002)  
[43] Buhler P.A., Vidal J.M.. “Semantic Web Services as Agent Behaviors”, I B. Burg, J. 
Dale, T. Finin, H. Nakashima, L. Padgham, C. Sierra, and S. Willmott, redaktører, 
Agentcities: Challenges in Open Agent Environments, s. 25-31. Springer-Verlag, (2003)  
[44] Buhler P A., Vidal J. M.: “Towards the Synthesis of Web Services and Agent 
Behaviors”In B. Burg, J. Dale, T. Finin, H. Nakashima, L. Padgham, C. Sierra, and S. 
Willmott, redaktører, Agentcities: Challenges in Open Agent Environments, Springer-
Verlag, (2003) 
[45] Berners-Lee T., Hendler J., Lassila O.: “The Semantic Web”, Scientific 
American, (2001) 
 
[46] McIlraith, S., Son, TC and Zeng, H. ``Semantic Web Services" , IEEE Intelligent 
Systems. Special Issue on the Semantic Web. 16(2):s. 46-53, (2001) 
 
 [47] Cisco Systems, Inc. “Routing Basics”. (2002). Hentet 4 Juli 2005 fra Cisco.com. 
URL: http://www.cisco.com/univercd/cc/td/doc/cisintwk/ito_doc/routing.htm 
 
[48] ATIS, computer dictionary, ”Node”, URL:http://www.atis.org/tg2k/_node.html 
 
[49] Todd McDonald, Alec Yasinsac og Willard Thompson, "Mobile Agent Data 
Integrity Using Multi-agent Architecture", Proceedings of the 2004 International 
Workshop on Security in Parallel and Distributed Systems, San Francisco, CA, s. 536-42 
(2004) 
 
     
 103 
[50] Feldman M. og Chuang J.: “Hidden-Action in Multi-Hop Routing”, 2nd 
Workshop on 
Economics of Peer-to-Peer Systems, (2004) 
 
[51] Challinor, S. ”An Introduction to IP Networks”, i BT Technology Journal. 18, 
nummer 3. side: 15-22. (2000) 
 
[52] “IPv4 (IP) - A Brief History”, URL: 
http://ntrg.cs.tcd.ie/undergrad/4ba2/ipng/gerd.ipv4.html 
 
[53] Roberts P og Challinor S. ‘IP address management’, BT Technol Journal, 
18, No 3. side 127—136 (2000). 
 
[54] Hinde, R.M. ”IP next generation overview”. Communications of the ACM  
Årgang 39 ,  Nummer 6  (1996) side: 61 - 71    
  
[55] C. Bettstetter, H-J. Vogel, and J. Eberspeher, “GSM Phase 2+ General Packet Radio 
Service GPRS: Architecture, Protocols, and Air Interface,” IEEE Communication 
Survey, (1999) 
 
[56] Kirstein, PT, K. Carlberg, K. Hasler og P. O’Hanlon, “Media Transmission over 
Coupled Wired/Wireless Networks using Applications Level Active IPv6 Networks”, 
Proc. Converged Networking – Data and Real-time Communications over IP, 
Interworking 2002, Kluwer Academic Publishers, s 197-211, (2002) 
 
[57] S. Keshav, “Why Cell Phones Will Dominate the Future Internet”, ACM Computer 
Communication Review, (2005) 
 
[58] Charles E. Perkins, “Mobile Networking Through Mobile IP”, IEEE 
Internet Computing, volume 2 num. 1, s.58-69, (1998) 
 
[59] Christian Erfurth, Arndt Döhler, Wilhelm Rossak, “A First Look at the Performance 
of Autonomous Mobile Agents in Dynamic Networks.”, HICSS (2004) 
 
[60] Stevens, W. R, “ARP: Address Resolution Protocol” .TCP/IP Illustrated, Volume 1: 
The Protocols. Addison Wesley. Kap. 4 (1993).  
 
[61] Ben-Ami D., Shehory O.: “A comparative evaluation of agent location mechanisms 
in large scale MAS”, AAMAS  s. 339-346 (2005) 
 
[62] Fiege L., Gartner F. C., Kasten O., og Zeidler A.: ”Supporting 
mobility in content-based publish/subscribe middleware.”, i Proceedings of 
ACM/IFIP/USENIX International Middleware Conference, s. 103 - 134. ACM 
Press, (2003) 
 
[63] Wang Q. og Abu-Rgheff M. A., "Next-Generation Mobility Support", IEE 
     
 104 
Communications Engineer, Vol. 1, No. 1, Jan/Feb 2003, pp. 16-19 
 
[64] Wang Q. og Abu-Rgheff M.A., "Towards a Complete Solution to Mobility 
Management for Next-Generation Wireless System", Proc. London Communications 
Symposium, London, UK, s. 281-284 (2002) 
 
[65] ”Network design with Mobile IP”, Lest 14.09.95 på: URL: 
http://www.isoc.org/isoc/conferences/inet/01/CD_proceedings/T40/inet_T40.htm 
 
[66] Akyildiz I.F., Xie J., Mohanty S., “A survey of mobility management in next-
generation all-IP-based wireless systems”, IEEE Wireless Communications 11 (4) 16–28. 
(2004) 
 
[67] Perkins C. E. og Johnson D. B.: “Route Optimization in Mobile IP,” Internet draft, 
IETF, draft-ietf-mobileipoptim-11.txt, (2001) 
 
[68] Ramjee R., Varadhan K., Salgarelli L., Thuel S., Wang S. og La Porta T., 
“HAWAII: A Domain-Based Approach for Supporting Mobility in Wide-Area Wireless 
Networks”,  IEEE/ACM Transactions on Networking, 10(3) s. 396-410, (2002) 
 
[69] Valkó A. G., “Cellular IP: a new approach to Internet host mobility”, ACM 
SIGCOMM Computer Communication Review, v.29 n.1, (1999)  
 
[70] Campbell A. T. og Gomez J., "IP Micro-Mobility Protocols" , ACM SIGMOBILE 
Mobile Computer and Communication Review (MC2R),V. 4, No. 4, s 45-54, (2001)   
 
[71] Fuggetta A., Picco G. P. og Vigna G.: ”Understanding Code Mobility”, IEEE Trans. 
on Software Engineering, (1998) 
 
[72] Carzaniga A., Pietro E. og Vigna G.: “Designing Distributed Applications with 
Mobile Code Paradigms.” I International Conference on Software Engineering, pages 22-
32, Boston, MA, (1997) 
 
[73] Chakravarti, A.J., Wang, X., Hallstrom, J.O., og Baumgartner, G.: “Implementation 
of Strong Mobility for Multi-Threaded Agents in Java”, Proceedings of the 2003 
International Conference on Parallel Processing, Taiwan, Republic of China, s. 321 – 
330, (2003). 
 
[74] Bellifemine F., Caire G., Trucco T. og Rimassa G: “JADE PROGRAMMER’S 
GUIDE”. TILab S.p.A. URL: http://sharon.cselt.it/projects/jade/. (2002) 
 
[75] Lange, D., Oshima, M., "Java Agent API: Programming and Deploying Aglets with 
Java", Addison Wesley, s. 70-71, 136-140 (1998) 
 
[76] Garcia A., Kulesza U., Sant'Anna C og Lucena C. ”The Mobility Aspect Pattern”, 
Fourth Latin American Conference on Pattern Languages of Programming, 
     
 105 
SugarLoafPLoP'04. (2004) 
 
[77] Voelter M.: “Aspect-Oriented Programming in Java”, URL: 
http://www.voelter.de/data/articles/aop/aop.html  
 
[78] FIPA Architecture Board, ”FIPA Agent Management Support for Mobility 
Specification” 
 
[79]  Bergenti, F. and Poggi, A., “LEAP: a FIPA Platform for Handheld and Mobile 
Devices”, i Proceedings. of ATAL 2001. 
 
[80]  Aridor, Y. Lange, D. B. ”Agent Design Patterns: Elements of Agent Application 
Design”, Autonomous Agents 98 Minneapolis, (1998) 
 
 [81] S. Pleisch, and A. Schiper: Approaches to Fault-Tolerant and Transactional Mobile 
Agent Execution -- An Algorithmic View. 
ACM Computing Surveys, September 2004. Pages 219-262 
 
[82] Huizinga D.M, Heflinger K.A., “Experience with connected and disconnected 
operation of portable notebook computers in distributed systems”, Mobile Computing 
Systems and Applications, Workshop on 8-9 Dec. 1994 side:119 - 123 
 
[83] Lange, D., and Oshima, M. “Programming and Deploying Java Mobile 
Agents with Aglets”. Addison-Wesley Longman, Reading, Mass., (1998) 
 
[84] Maes P., Guttman R. H., Moukas A. G., “Agents that buy and sell”, 
Communications of the ACM, v.42 n.3, p.81-ff., (1999) 
 
[85] Kotz  D., Gray R., Rus D., “Transportable agents support worldwide applications”. 
ACM SIGOPS European Workshop p. 41-48, (1996) 
 
[86] Gray R., Kotz D., Nog S., Rus D. og  Cybenko G.: “Mobile Agents: The Next 
Generation in Distributed Computing.”, In Proceedings of the Second Aizu International 
Symposium on Parallel Algorithms and Architectures Synthesis, IEEE Computer Society 
Press, s. 8-24, (1997)  
 
[87] Das, S., Shuster, K., Wu, C., and Levit, I. "Mobile Agents for Distributed and 
Heterogeneous Information Retrieval," Journal of Information Retrieval, Kluwer-
Academic, vol. 8, pp. 383-416. (2005) 
 
[88] Kaneda T., Tanaka Y., Enokido T., Takizawa M. “Transactional agent model for 
fault-tolerant object systems”. SAC p. 1133-1138 (2005) 
 
[89] I. Satoh, “Adaptive Protocols for Agent Migration”, Proceedings of IEEE 
International Conference on Distributed Computing Systems, s.711-714, (2001) 
 
     
 106 
[90] Falchuk B., Karmouch A., “The Mobile Agent Paradigm Meets Digital Document 
Technology: Designing for Autonomous Media Collection”, Multimedia Tools and 
Applications, v.8 n.1, p.137-166, (1999) 
 
[91] Wang A., Sørensen C., Indal E., “A mobile agent architecture for heterogeneous 
Devices”, (2002) 
 
[92] Rus D., Gray R. S., Kotz D. “Transportable Information Agents.” Journal of 
Intelligent Information Systems, 9, 215–238 (1997) 
  
[93] Ping 127.0.0.1 Computer Services, “The Ping page”, lest:  26.11.05 på 
http://www.ping127001.com/pingpage.htm 
 
[94] Postel, J., "Internet Control Message Protocol – DARPA Internet Program Protocol 
Specification", RFC 792, USC/Information Sciences Institute, (1981). 
 
[95] Claessens J., Preneel B. , Vandewalle J., “(How) can mobile agents do secure 
electronic transactions on untrusted hosts? A survey of the security issues and the current 
solutions”, ACM Transactions on Internet Technology (TOIT), v.3 n.1, s.28-48, (2003) 
 
[96] Marques P., Silva L., Silva J., "A Flexible Mobile Agent Framework for Accessing 
Information Systems in Disconnected Computing Environments", Third International 
Workshop on Mobility in Databases and Distributed Systems, s. 173-177 (2000) 
 
[97] Porter C. “Email Marketing and Spam: Two Sides of the Same Penny”, Middlesex 
University, (2003) 
 
[98] Moreno, A., Valls, A., Viejo, A., Using JADE-LEAP to implement agents in mobile 
devices, DEIM-RR-03-008 (2003) 
 
     
 107 
 
ORDLISTE 
 
AI  Artificial Intelligence 
ACL    Agent Communication Language 
ARP  Address Resolution Protocol 
AMS   Agent Management System 
ATIS  Alliance for Telecommunications Industry Solutions 
CDMA  Code-Division Multiple Access 
CIP  Cellular IP 
COD   Code On Demand  
DF   Directory Facilitator 
DARPA Defense Advanced Research Projects Agency  
DAML DARPA Agent Markup Language 
DHCP  Dynamic Host Configuration Protocol 
DRR   Domain Root Router  
EDGE  Enhanced Data for Global Evolution 
FIPA    Foundation for Intelligen Physical Agents 
GPRS  General Packet Radio Services 
GSM   Global System for Mobile communication 
HLR   Home Location Registers  
HTTP  Hyper Text Transfer Protocol 
ICMP   Internet Control Message Protocol 
IIOP  Internet Inter ORB Protocol 
IEEE   Institute of Electrical and Electronics Engineers 
IETF   Internet Engineering Task Force  
IP  Internet Protocol 
JADE    Java Agent Development Environment 
JVM    Java Virtual Machine 
KIF   Knowledge Interchange Format 
KQML  Knowledge Query Management Language 
MAC  Media Access Control 
MAS  Multi Agent System 
MAP  Mobile Application Messages 
MTS  Message Transport System 
NAT   Network Address Translation  
OIL   Ontology Inference Language 
OMG   Object Management Group 
OSI  Open Systems Interconnection 
PRACH  Packet Random Access Channel  
PAGCH  Packet Grant kanalen 
PPP   Point-to-Point Protocol 
RDF   Resource Description Framework 
RIP  Routing Information Protocol 
ROV  Remote EValuation  
RMA  Remote Management Agent 
     
 108 
RMI  Remote Method Invocation 
RPC  Remote Procedure Call 
SGSN  Serving Gprs Support Node  
SIPP  Simple Internett Protocol Pluss 
SMTP   Simple Mail Transfer Protocol 
SNDCP  Sub Network Dependent Convergence Protocol  
SQL  Structured Query Language 
TCP  Transmission Control Protocol 
UDP  User Datagram Protocol 
UML   Unified Modeling Language 
UMTS  Universal Mobile Telecommunication System 
URI   Uniform Resource Identifier 
XML   eXtensible Markup Language 
 
     
 109 
 
APPENDIKS A 
 
Kildekode. Jeg har ikke inkludert all kildekoden kun tre sentrale klasser: BuyerAgent, 
Itinerary og StorageAgent. Hvis det er ønskelig å ha tilgang til all kildekode er det bare å 
kontakte meg. Det er også generert JavaDoc for prosjektet. 
 
BUYERAGENT 
 
package trader; 
 
import jade.content.abs.AbsContentElementList; 
import jade.content.abs.AbsObject; 
import jade.content.abs.AbsPredicate; 
import jade.content.lang.Codec; 
import jade.content.lang.sl.SLCodec; 
import jade.content.lang.sl.SLVocabulary; 
import jade.content.onto.Ontology; 
import jade.content.onto.OntologyException; 
import jade.content.onto.basic.Action; 
import jade.content.onto.basic.Result; 
import jade.core.AID; 
import jade.core.Agent; 
import jade.core.Location; 
import jade.core.behaviours.Behaviour; 
import jade.core.behaviours.SequentialBehaviour; 
import jade.core.behaviours.SimpleBehaviour; 
import jade.domain.DFService; 
import jade.domain.FIPAException; 
import jade.domain.FIPANames; 
import jade.domain.FIPAAgentManagement.DFAgentDescription; 
import jade.domain.FIPAAgentManagement.SearchConstraints; 
import jade.domain.FIPAAgentManagement.ServiceDescription; 
import jade.domain.JADEAgentManagement.JADEManagementOntology; 
import jade.domain.JADEAgentManagement.WhereIsAgentAction; 
import jade.domain.mobility.MobilityOntology; 
import jade.lang.acl.ACLMessage; 
import jade.lang.acl.UnreadableException; 
import jade.proto.SimpleAchieveREInitiator; 
import jade.util.leap.Serializable; 
 
import java.io.FileNotFoundException; 
import java.io.FileOutputStream; 
import java.io.IOException; 
import java.io.PrintStream; 
import java.util.ArrayList; 
import java.util.Date; 
import java.util.Iterator; 
import java.util.Vector; 
 
import trader.ontology.Flight; 
import trader.ontology.FlightClass; 
import trader.ontology.FlightOntology; 
import trader.ontology.Offer; 
     
 110 
import trader.ontology.TicketAvailable; 
 
public class BuyerAgent extends Agent implements Serializable { 
  
 // AGENT LOCAL VARIABLES 
 ArrayList offers = new ArrayList(); // The list of the available flights 
  
 // found by this agent 
  
 private AID travelAgent; // AID of the agent the travel requests and 
 private String agentIdFile = "../agentID.txt"; 
  
 private boolean storageFlag = false; 
   
 private AID storageAgent; // AID of the agent the storage requests will be 
  
 // sent to 
  
 private Flight search_flight = null; 
  
 private FlightClass search_flight_class = null; 
  
 private Intinerary intinerary = null; 
  
 private Location nextNode; // this variable holds the destination site 
  
 private Long ID = null; 
  
 private boolean home = false; // Is the agent returning home? 
  
 class HandleTicketBehaviour extends SequentialBehaviour { 
  // Local variables 
  Behaviour queryBehaviour = null; 
   
  Behaviour requestBehaviour = null; 
   
  Flight flight_ = null; 
   
  FlightClass flight_class = null; 
   
  Date flight_date = null; 
   
  // Constructor 
  public HandleTicketBehaviour(Agent myAgent, Flight flight, 
    FlightClass fc) { 
   super(myAgent); 
   flight_ = flight; 
   flight_class = fc; 
  } 
   
  // This is executed at the beginning of the behaviour 
  public void onStart() { 
   if 
(myAgent.getContentManager().lookupLanguage(FIPANames.ContentLanguage.FIPA_SL1) == 
null){ 
     
 111 
    myAgent.getContentManager().registerLanguage(new 
SLCodec(),FIPANames.ContentLanguage.FIPA_SL1); 
   } 
   if 
(myAgent.getContentManager().lookupLanguage(FlightOntology.NAME) == null){ 
   
 getContentManager().registerOntology(FlightOntology.getInstance()); 
   } 
    
   // Create an object representing the fact that a ticket t is 
   // available for flight f 
   TicketAvailable ta = new TicketAvailable(); 
   ta.setFlight(flight_); 
   ta.setFlight_class(flight_class); 
    
   // Create an ACL message to query the travel agent if the above fact is 
true or false 
   ACLMessage queryMsg = new ACLMessage(ACLMessage.QUERY_IF); 
   queryMsg.addReceiver(((BuyerAgent) myAgent).travelAgent); 
    
   queryMsg.setLanguage(FIPANames.ContentLanguage.FIPA_SL1); 
   queryMsg.setOntology(FlightOntology.NAME); 
   try { 
    myAgent.getContentManager().fillContent(queryMsg, ta); 
   } catch (Exception e) { 
    e.printStackTrace(); 
   } 
    
   // Create and add a behaviour to query the travel agent about ticket 
   // information 
   queryBehaviour = new QueryAvailableBehaviour(myAgent, queryMsg); 
   addSubBehaviour(queryBehaviour); 
  } 
   
   
  // This is executed at the end of the behaviour 
  public int onEnd() { 
   Object [] tmp = intinerary.getNextLocation(); 
   if(tmp != null){ 
    nextNode = (Location)tmp[0]; 
    travelAgent = (AID)tmp[1]; 
    addBehaviour(new doMoveBehaviour(myAgent , /*new 
ACLMessage(ACLMessage.QUERY_REF),*/ nextNode)); 
   } 
   else { 
    addBehaviour(new doMoveHomeBehaviour(myAgent)); 
   } 
    
   return 1; 
  } 
   
  // Extends the reset method in order to remove the sub-behaviours that 
  // are dynamically added 
  public void reset() { 
   if (queryBehaviour != null) { 
    removeSubBehaviour(queryBehaviour); 
     
 112 
    queryBehaviour = null; 
   } 
   if (requestBehaviour != null) { 
    removeSubBehaviour(requestBehaviour); 
    requestBehaviour = null; 
   } 
   super.reset(); 
  } 
 } 
  
 class QueryAvailableBehaviour extends SimpleAchieveREInitiator { 
  // Constructor 
   
  public QueryAvailableBehaviour(jade.core.Agent myAgent, ACLMessage 
queryMsg) { 
   super(myAgent, queryMsg); 
   queryMsg.setProtocol(FIPANames.InteractionProtocol.FIPA_QUERY); 
  } 
   
  protected void handleInform(ACLMessage msg) { 
   try { 
    AbsPredicate cs = (AbsPredicate) myAgent.getContentManager() 
    .extractAbsContent(msg); 
    Ontology o = myAgent.getContentManager().lookupOntology( 
      FlightOntology.NAME); 
     
    if 
(cs.getTypeName().equals(FlightOntology.TICKET_AVAILABLE)) { 
     // The indicated flight is available. 
      
     TicketAvailable ta = (TicketAvailable) o 
     .toObject((AbsObject) cs); 
     Flight f = (Flight) ta.getFlight(); 
     FlightClass fc = (FlightClass) ta.getFlight_class(); 
      
     Offer offer = new Offer(); 
     offer.setFlight(f); 
     offer.setFlight_class(fc); 
     offer.setPrice(new Integer(0)); 
     // Create an ACL message to request the travel agent to 
make 
     // us an offer 
     ACLMessage requestMsg = new 
ACLMessage(ACLMessage.REQUEST); 
     requestMsg.addReceiver(((BuyerAgent) 
myAgent).travelAgent); 
    
 requestMsg.setLanguage(FIPANames.ContentLanguage.FIPA_SL1); 
     requestMsg.setOntology(FlightOntology.NAME); 
      
     // Write the action in the :content slot of the message 
     Action a = new Action(); 
     a.setActor(((BuyerAgent) myAgent).travelAgent); 
     a.setAction(offer); 
     try { 
     
 113 
     
 myAgent.getContentManager().fillContent(requestMsg, a); 
     } catch (Exception pe) { 
     } 
     // Create and add a behaviour to request the travel agent 
to 
     // make an offer for Flight f following a FIPARequest 
     // protocol 
     ((HandleTicketBehaviour) parent).requestBehaviour = 
new RequestOfferBehaviour(myAgent, requestMsg); 
     ((SequentialBehaviour) parent) 
     .addSubBehaviour(((HandleTicketBehaviour) 
parent).requestBehaviour); 
    } else if (cs.getTypeName().equals(SLVocabulary.NOT)) { 
     System.out.println("Flight is unavailable"); 
    } else { 
     // Unexpected response received from the travel agent. 
     // Inform the user 
     System.out.println("Unexpected response from travel 
agent"); 
    } 
     
   } // End of try 
   catch (Codec.CodecException fe) { 
    System.err.println("FIPAException in fill/extract Msgcontent:" 
      + fe.getMessage()); 
   } catch (OntologyException fe) { 
    System.err.println("OntologyException in getRoleName:" 
      + fe.getMessage()); 
   } 
  } 
   
 } 
  
 /** 
  * This behaviour embeds the request to the travel agent to make an offer 
  * This is done following a FIPA-Request interaction protocol 
  */ 
 class RequestOfferBehaviour extends SimpleAchieveREInitiator { 
  // Constructor 
  public RequestOfferBehaviour(Agent myAgent, ACLMessage requestMsg) { 
   super(myAgent, requestMsg); 
  
 requestMsg.setProtocol(FIPANames.InteractionProtocol.FIPA_REQUEST); 
  } 
   
  protected void handleAgree(ACLMessage msg) { 
   System.out.println("AGREE"); 
  } 
   
  protected void handleInform(ACLMessage msg) { 
   System.out.println("Offer successfully recieved"); 
   try { 
    Result res = (Result) 
myAgent.getContentManager().extractContent(msg); 
     
 114 
    Ontology o = 
myAgent.getContentManager().lookupOntology(FlightOntology.NAME); 
    Action a = (Action) res.getAction(); 
    Offer ticket = (Offer) a.getAction(); 
    
    if (ticket != null) { 
     offers.add(ticket); 
    } 
 
   } catch (Codec.CodecException fe) { 
    System.err.println("FIPAException reading failure reason: " 
      + fe.getMessage()); 
   } catch (OntologyException oe) { 
    System.err.println("OntologyException reading failure reason: " 
      + oe.getMessage()); 
   } 
  } 
   
  protected void handleNotUnderstood(ACLMessage msg) { 
   System.out.println("Offer request not understood by travel agent"); 
  } 
   
  protected void handleFailure(ACLMessage msg) { 
   System.out.println("Failure in recieving offer"); 
   // Get the failure reason and communicate it to the user 
   try { 
    AbsPredicate absPred = (AbsPredicate) myAgent 
    .getContentManager().extractContent(msg); 
     
    System.out.println("The reason is: " + absPred.getTypeName()); 
   } catch (Codec.CodecException fe) { 
    System.err.println("FIPAException reading failure reason: " 
      + fe.getMessage()); 
   } catch (OntologyException oe) { 
    System.err.println("OntologyException reading failure reason: " 
      + oe.getMessage()); 
   } 
  } 
   
  protected void handleRefuse(ACLMessage msg) { 
   System.out.println("Request for offer refused"); 
   // Get the refusal reason and communicate it to the user 
   try { 
    AbsContentElementList list = (AbsContentElementList) myAgent 
    .getContentManager().extractAbsContent(msg); 
    AbsPredicate absPred = (AbsPredicate) list.get(1); 
    System.out.println("The reason is: " + absPred.getTypeName()); 
   } catch (Codec.CodecException fe) { 
    System.err.println("FIPAException reading refusal reason: " 
      + fe.getMessage()); 
   } catch (OntologyException oe) { 
    System.err.println("OntologyException reading refusal reason: " 
      + oe.getMessage()); 
   } 
  } 
 } 
     
 115 
  
 public class GetTravelAgentLocations extends SimpleBehaviour{ 
  boolean done = false; 
   
  public GetTravelAgentLocations(Agent agent){ 
   super(agent); 
  } 
   
  public void action() { 
   ACLMessage request = new ACLMessage(ACLMessage.REQUEST); 
   Location serviceLocation = null; 
  
 getContentManager().registerOntology(JADEManagementOntology.getInstance()); 
    
   try {  
    // Build the description used as template for the search 
    DFAgentDescription template = new DFAgentDescription(); 
    ServiceDescription templateSd = new ServiceDescription(); 
    templateSd.setType("travel");  
    template.addServices(templateSd); 
     
    SearchConstraints sc = new SearchConstraints();  
    sc.setMaxResults(new Long(10)); 
     
    DFAgentDescription[] results = DFService.search(myAgent, 
template, sc); 
     
    for (int i = 0;i < results.length; i++) {  
     DFAgentDescription dfd = results[i]; 
     AID provider = dfd.getName();  
     Iterator it = dfd.getAllServices();  
     ServiceDescription sd = (ServiceDescription) it.next();  
     if(sd.getType().equals("travel")) {  
      System.out.println("- Service \"" + sd.getName() 
+ "\" provided by agent " + provider.getName()); 
       
      // fills all parameters of the request ACLMessage 
      request.clearAllReceiver(); 
      request.addReceiver(myAgent.getAMS()); 
     
 request.setLanguage(FIPANames.ContentLanguage.FIPA_SL0); 
     
 request.setOntology(JADEManagementOntology.NAME); 
     
 request.setProtocol(FIPANames.InteractionProtocol.FIPA_REQUEST); 
      // creates the content of the ACLMessage 
      try { 
       WhereIsAgentAction whereisAgent = 
new WhereIsAgentAction(); 
      
 whereisAgent.setAgentIdentifier(provider); 
       Action action = new Action(); 
       action.setActor(myAgent.getAMS()); 
       action.setAction(whereisAgent); 
      
 myAgent.getContentManager().fillContent(request, action); 
     
 116 
       send(request);    
      
       ACLMessage reply = blockingReceive(); 
       Object o = 
myAgent.getContentManager().extractContent(reply); 
        
       if(o instanceof Result) { 
        Result r = (Result)o; 
        System.out.println(" value: " + 
r.getValue()); 
         
       
 ((BuyerAgent)myAgent).intinerary.addLocation((Location)r.getValue(), provider); 
       } 
        
       done = true;    
      } catch (Exception fe) { 
       fe.printStackTrace(); 
       done = true; 
      }      
   
     }  
     else { 
      System.out.println("Agent " + getLocalName() + " 
did not find any travel service");  
     }  
    } 
   } catch (FIPAException fe) { 
    fe.printStackTrace();  
   }  
  } 
  public boolean done() { 
   Object [] tmp = intinerary.getNextLocation(); 
 
   if(tmp != null){ 
    nextNode = (Location)tmp[0]; 
    travelAgent = (AID)tmp[1]; 
    System.out.println("NEXT IN LINE: " + nextNode.toString()); 
    addBehaviour(new doMoveBehaviour(myAgent, nextNode)); 
   }else{ 
    System.out.println("No travel agents or locations to visit"); 
   } 
   return done; 
  } 
   
   
 } 
  
  
 /** 
  * This behaviour embeds the request to the AMS 
  * to retrieve the location of the StorageAgent 
  */ 
 public class GetStorageAgentLocationBehaviour extends SimpleAchieveREInitiator { 
   
  private ACLMessage request; 
     
 117 
   
  public GetStorageAgentLocationBehaviour(Agent a) { 
   // call the constructor of FipaRequestInitiatorBehaviour 
   super(a, new ACLMessage(ACLMessage.REQUEST));    
   request = (ACLMessage) getDataStore().get(REQUEST_KEY); 
   // fills all parameters of the request ACLMessage 
   request.clearAllReceiver(); 
   request.addReceiver(a.getAMS()); 
   request.setLanguage(FIPANames.ContentLanguage.FIPA_SL0); 
   request.setOntology(JADEManagementOntology.NAME); 
   request.setProtocol(FIPANames.InteractionProtocol.FIPA_REQUEST); 
   // creates the content of the ACLMessage 
   try { 
    WhereIsAgentAction whereisAgent = new WhereIsAgentAction(); 
    System.out.println("AID OF STORAGEAGENT: " + 
storageAgent.toString()); 
    whereisAgent.setAgentIdentifier(storageAgent); 
    Action action = new Action(); 
    action.setActor(a.getAMS()); 
    action.setAction(whereisAgent); 
    a.getContentManager().fillContent(request, action); 
   } catch (Exception fe) { 
    fe.printStackTrace(); 
   } 
   reset(request); 
  } 
   
  protected void handleNotUnderstood(ACLMessage reply) { 
   System.out.println(myAgent.getLocalName() 
     + " handleNotUnderstood : FIND storage LOCATION " 
     + reply.toString()); 
  } 
   
  protected void handleRefuse(ACLMessage reply) { 
   System.out.println(myAgent.getLocalName() + " handleRefuse : " 
     + reply.toString()); 
  } 
   
  protected void handleFailure(ACLMessage reply) { 
   System.out.println(myAgent.getLocalName() + " handleFailure : " 
     + reply.toString()); 
  } 
   
  protected void handleAgree(ACLMessage reply) { 
  } 
   
  protected void handleInform(ACLMessage inform) { 
  
 getContentManager().registerOntology(JADEManagementOntology.getInstance()); 
   getContentManager().registerLanguage(new 
SLCodec(),FIPANames.ContentLanguage.FIPA_SL0); 
   try { 
    Result results = (Result) 
myAgent.getContentManager().extractContent(inform); 
    ((BuyerAgent) myAgent).intinerary.setStorageLocation((Location) 
results.getValue()); 
     
 118 
    System.out.println("THE STORAGENODE IS AT LOCATION: " + 
intinerary.getStorageLocation().toString()); 
   } catch (Exception e) { 
    e.printStackTrace(); 
   } 
  } 
 } 
  
   
 class RequestStorageIdBehaviour extends SimpleBehaviour{ 
  boolean done = false; 
   
  public RequestStorageIdBehaviour(Agent agent){ 
   super(agent); 
  } 
   
  public void action() { 
   ACLMessage request = new ACLMessage(ACLMessage.REQUEST); 
   request.addReceiver(storageAgent); 
   request.setContent("id_request"); 
   send(request); 
    
   ACLMessage reply = blockingReceive(); 
   Object tmp; 
   try { 
    tmp = reply.getContentObject(); 
    if(tmp instanceof Long) { 
     ID = (Long)tmp; 
     System.out.println("*********ID = " + ID.toString()); 
    } 
   } catch (UnreadableException e) { 
    e.printStackTrace(); 
   } 
   done = true; 
  } 
 
  public boolean done() { 
   return done; 
  } 
   
   
 } 
  
 class RequestStorageBehaviour extends SimpleAchieveREInitiator { 
  public RequestStorageBehaviour(Agent myAgent, ACLMessage msg){ 
   super(myAgent, msg); 
    
   try{  
    msg.addReceiver(storageAgent); 
    BuyerAgent copy = (BuyerAgent) myAgent; 
     
    msg.setContentObject(copy); 
    msg.setLanguage("JavaSerialization"); 
   
 msg.setProtocol(FIPANames.InteractionProtocol.FIPA_REQUEST); 
    send(msg); 
     
 119 
    System.out.println("BUYER SENT STORAGE MSG.."); 
   } catch (IOException e ) { 
    e.printStackTrace(); 
   } 
  } 
   
  protected void handleAgree(ACLMessage msg) { 
   System.out.println("--- SAVING...");    
   myAgent.doDelete(); 
  } 
     
  protected void handleNotUnderstood(ACLMessage msg) {} 
   
  protected void handleFailure(ACLMessage msg) { 
   System.out.println("Failure in storing agent"); 
   // Get the failure reason and communicate it to the user 
   try { 
    AbsPredicate absPred = (AbsPredicate) myAgent 
    .getContentManager().extractContent(msg); 
     
    System.out.println("The reason is: " + absPred.getTypeName()); 
   } catch (Codec.CodecException fe) { 
    System.err.println("FIPAException reading failure reason: " 
      + fe.getMessage()); 
   } catch (OntologyException oe) { 
    System.err.println("OntologyException reading failure reason: " 
      + oe.getMessage()); 
   } 
  } 
   
  protected void handleRefuse(ACLMessage msg) { 
   System.out.println("Request for storage refused"); 
   // Get the refusal reason and communicate it to the user 
   try { 
    AbsContentElementList list = (AbsContentElementList) 
myAgent.getContentManager().extractAbsContent(msg); 
    AbsPredicate absPred = (AbsPredicate) list.get(1); 
    System.out.println("The reason is: " + absPred.getTypeName()); 
   } catch (Codec.CodecException fe) { 
    System.err.println("FIPAException reading refusal reason: " 
      + fe.getMessage()); 
   } catch (OntologyException oe) { 
    System.err.println("OntologyException reading refusal reason: " 
      + oe.getMessage()); 
   } 
  } 
 } 
  
public class FindStorageServiceBehaviour extends SimpleBehaviour { 
   
  public FindStorageServiceBehaviour(Agent agent) { 
   super(agent); 
  } 
   
  public void action() { 
   try { 
     
 120 
    // Build the description used as template for the search 
    DFAgentDescription template = new DFAgentDescription(); 
    ServiceDescription templateSd = new ServiceDescription(); 
    templateSd.setType("storage"); 
    template.addServices(templateSd); 
     
    SearchConstraints sc = new SearchConstraints(); 
    // We want to receive 1 result (name and id of storage agent) 
    sc.setMaxResults(new Long(1)); 
     
    DFAgentDescription[] results = 
DFService.search(super.myAgent, 
      template, sc); 
    if (results.length > 0) { 
     System.out.println("Agent " + getLocalName() + " found 
the following storage service:"); 
     for (int i = 0; i < results.length; ++i) { 
      DFAgentDescription dfd = results[i]; 
      AID provider = dfd.getName(); 
      // The same agent may provide several services; 
we are 
      // only interested in the storage service 
      Iterator it = dfd.getAllServices(); 
      while (it.hasNext()) { 
       ServiceDescription sd = 
(ServiceDescription) it 
       .next(); 
       if (sd.getType().equals("storage")) { 
        System.out.println("- Service \"" + 
sd.getName() + "\" provided by agent " + provider.getName()); 
        storageAgent = new 
AID(provider.getName(),AID.ISGUID); 
        addBehaviour(new 
GetStorageAgentLocationBehaviour(myAgent)); 
       } 
      } 
     } 
    } else { 
     System.out.println("NO STORAGE FACILITY..."); 
    } 
   } catch (FIPAException fe) { 
    fe.printStackTrace(); 
   } 
  } 
   
  public boolean done() { 
   return true; 
  } 
   
 } 
  
 /** 
  * This behaviour embeds the request to a storage agent to request the AMS 
  * to freeze this agent for later retrival by userAgent 
  */ 
 class RequestRetrievalBehaviour extends Behaviour { 
     
 121 
   
  Agent agent_ = null; 
   
  ACLMessage msg_ = null; 
   
  public RequestRetrievalBehaviour(Agent agent, ACLMessage msg) { 
   agent_ = agent; 
   msg_ = msg; 
   msg_.setProtocol(FIPANames.InteractionProtocol.FIPA_REQUEST); 
  } 
   
  public void action() { 
  } 
   
  public boolean done() { 
   return false; 
  } 
 } 
  
 class doMoveBehaviour extends SimpleBehaviour{ 
   
  boolean done = false; 
  Location loc = null; 
   
  public doMoveBehaviour(Agent agent, Location loc) { 
   super(agent); 
   this.loc = loc; 
  } 
   
  public void action() { 
   if(loc != null){ 
     doMove(loc); 
    } 
    else { 
     Object [] tmpObj = 
((BuyerAgent)myAgent).intinerary.getNextLocation(); 
     if(tmpObj != null){ 
      nextNode = (Location)tmpObj[0]; 
      travelAgent = (AID)tmpObj[1]; 
      doMove(nextNode); 
     } 
     else{ 
      myAgent.addBehaviour(new 
doMoveHomeBehaviour(myAgent)); 
     } 
    } 
   done = true; 
  } 
   
   
  public boolean done() { 
   return done; 
  } 
   
 } 
  
     
 122 
 class doMoveHomeBehaviour extends SimpleBehaviour{ 
   
  boolean done = false; 
   
  public doMoveHomeBehaviour(Agent agent) { 
   super(agent); 
  } 
   
  public void action() { 
   
 System.out.println("********************MOVING********HOME*************************"); 
    ACLMessage query = new 
ACLMessage(ACLMessage.QUERY_REF); 
    String pingHomeName = "ping"+myAgent.getAID().getName(); 
    System.out.println("********************************PINGING : " + 
pingHomeName); 
    query.addReceiver(new AID(pingHomeName, false)); 
    query.setContent("ping"); 
    send(query); 
    ACLMessage reply = blockingReceive(); 
    String res = reply.getContent().toUpperCase(); 
    System.out.println("res ER LIK: " + res); 
    if(res.equals("ALIVE")){ 
     System.out.println("THE HOMENODE IS ALIVE...."); 
    
 doMove(((BuyerAgent)myAgent).intinerary.getHomeLocation()); 
     home = true; 
    } 
    else { 
     System.out.println("THE HOMENODE IS NOT 
ALIVE...."); 
     myAgent.addBehaviour(new 
RequestStorageBehaviour(myAgent, new ACLMessage(ACLMessage.INFORM))); 
     home = false; 
     storageFlag = true; 
    } 
   done = true; 
  } 
   
   
  public boolean done() { 
   // TODO Auto-generated method stub 
   return done; 
  } 
   
 } 
 
  
 // AGENT SETUP 
 protected void setup() { 
   Object[] args = getArguments(); 
    
   Date flight_date = new Date(Long.parseLong((String) args[2])); 
    
   search_flight = new Flight((String)args[0], (String)args[1], flight_date, new 
Float(0)); 
     
 123 
   search_flight_class = new FlightClass(); 
    
   if (Integer.parseInt((String) args[3]) == 1) { 
    search_flight_class.setClassTypeBudget(); 
   } else { 
    search_flight_class.setClassTypeBusiness(); 
   } 
 
//   register the SL0 and the SL1 content language 
  getContentManager().registerLanguage(new 
SLCodec(),FIPANames.ContentLanguage.FIPA_SL0); 
  getContentManager().registerLanguage(new 
SLCodec(),FIPANames.ContentLanguage.FIPA_SL1); 
   
  // register the mobility ontology  
  getContentManager().registerOntology(MobilityOntology.getInstance()); 
 
 getContentManager().registerOntology(JADEManagementOntology.getInstance()); 
 
  //Store agent name for possible retrieval 
  try { 
   System.out.println("SAVING ID..."); 
   PrintStream out = new PrintStream(new 
FileOutputStream("c:/jade/uio/agentID.txt")); 
   out.print(getAID().getName()); 
   out.close(); 
    
  } catch (Exception e) { 
   e.printStackTrace(); 
  } 
   
  Location l = here(); 
  intinerary = new Intinerary(l); 
   
  addBehaviour(new FindStorageServiceBehaviour(this)); 
  addBehaviour(new GetTravelAgentLocations(this)); 
} 
   
 protected void beforeMove() { 
 } 
  
 protected void afterMove() { 
  try { 
   Thread.sleep(4000); 
  } catch (Exception e) { 
  } 
   
  if(home == true){ 
   System.out.println("I'M HOME!!! -- DISPLAY RESULTS"); 
   Iterator itr = offers.iterator(); 
   Offer tmp = null; 
   System.out.println("OFFERS -->"); 
   while (itr.hasNext()) { 
    tmp = (Offer) itr.next(); 
    Flight f = tmp.getFlight(); 
    FlightClass fc = tmp.getFlight_class(); 
     
 124 
    Integer price = tmp.getPrice(); 
    System.out.println("OFFER FOR FLIGHT: origin: " 
      + f.getOrigin() + "destination: " + 
f.getDestination() + " Date: " + f.getDate() +  
      " On class: " + fc.get_class_type() + " PRICE: " + 
price.intValue()); 
   } 
   System.out.println("<-- OFFERS"); 
   PrintStream out; 
   try { 
    out = new PrintStream(new 
FileOutputStream("c:/jade/uio/agentID.txt")); 
    out.print("returned"); 
    out.close(); 
   } catch (FileNotFoundException e) { 
    e.printStackTrace(); 
   }    
  } 
  else if(storageFlag == true){ 
   addBehaviour(new RequestStorageBehaviour(this, new 
ACLMessage(ACLMessage.INFORM))); 
  } 
  else{ 
   addBehaviour(new HandleTicketBehaviour(this, this.search_flight, 
this.search_flight_class)); 
  } 
   
 } 
   
 public Vector afterLoad() { 
  Vector res = new Vector(); 
  System.out.println("******* IN AFTER LOAD ******************************************  
"); 
   
  for (Iterator it = offers.iterator(); it.hasNext();) { 
   Offer o = (Offer) it.next(); 
   res.add(o); 
   System.out.println("OFFER: origin: " + o.getFlight().getOrigin() + " 
destination: " + o.getFlight().getDestination()); 
  } 
 
  return res; 
 } 
} 
     
 125 
StorageAgent: 
 
package trader; 
 
import jade.core.AID; 
import jade.core.Agent; 
import jade.core.Location; 
import jade.core.behaviours.SimpleBehaviour; 
import jade.domain.DFService; 
import jade.domain.FIPAException; 
import jade.domain.FIPANames; 
import jade.domain.FIPAAgentManagement.DFAgentDescription; 
import jade.domain.FIPAAgentManagement.NotUnderstoodException; 
import jade.domain.FIPAAgentManagement.RefuseException; 
import jade.domain.FIPAAgentManagement.ServiceDescription; 
import jade.lang.acl.ACLMessage; 
import jade.lang.acl.MessageTemplate; 
import jade.lang.acl.UnreadableException; 
import jade.proto.SimpleAchieveREResponder; 
import jade.tools.ToolAgent; 
 
import java.io.ByteArrayInputStream; 
import java.io.IOException; 
import java.io.ObjectInputStream; 
import java.sql.Connection; 
import java.sql.DatabaseMetaData; 
import java.sql.DriverManager; 
import java.sql.PreparedStatement; 
import java.sql.ResultSet; 
import java.sql.SQLException; 
import java.sql.Statement; 
import java.util.Vector; 
 
public class StorageAgent extends ToolAgent { 
  
 // AGENT LOCAL VARIABLES 
  
 private String str = ""; 
 private Connection c = null;  
  
 protected void toolSetup() { 
  // Name of the service this agent performs and registers with DF agent  
   
  String serviceName = "storage-facilitator"; 
  try { 
   Class.forName("org.hsqldb.jdbcDriver"); 
     
 126 
   c = 
DriverManager.getConnection("jdbc:hsqldb:file:c:/jade/uio/DB/agentdb", "sa", ""); 
  } catch (SQLException e) { 
   System.err.println("Could not connect to db.."); 
   e.printStackTrace(); 
  } catch (ClassNotFoundException e) { 
   System.err.println("Could not find drive class.."); 
   e.printStackTrace(); 
  } 
   
  try{ 
   System.out.println("Checking the database..."); 
   Statement stat = c.createStatement(); 
   DatabaseMetaData dbmd = c.getMetaData(); 
    
   ResultSet rs = dbmd.getTables(null,null,"AGENTS",null); 
    
   // Test if there is an agents table 
   if(rs.next() != true){ 
   //stat.execute("DROP TABLE agents"); 
   System.out.println("<--------------  CREATING DB  ------------------
>"); 
   stat.execute("CREATE TABLE agents" + "(" + 
      "agent_id VARCHAR(255), " + 
      "date_added DATE, " + 
      "agent LONGVARBINARY)"); 
   } 
   stat.close(); 
  }catch (SQLException e) { 
   System.err.println("Could not create table"); 
  } 
     
  try { 
   //register agent with directory facilitator 
   AID me = this.getAID(); 
   DFAgentDescription dfd = new DFAgentDescription(); 
   dfd.setName(me); 
   ServiceDescription sd = new ServiceDescription(); 
   sd.setName(serviceName); 
   sd.setType("storage"); 
   // Agents that want to use this service need to "speak" the FIPA-SL 
language 
   sd.addLanguages(FIPANames.ContentLanguage.FIPA_SL0); 
   dfd.addServices(sd); 
    
    
     
 127 
   DFService.register(this, dfd); 
   System.out.println("Agent "+getLocalName()+" has registered 
service \""+serviceName+"\" of type \"storage\""); 
   addBehaviour(new HandleStorageRequest(this)); 
   addBehaviour(new HandleRetrievalRequestsBehaviour(this)); 
  
  } 
  catch (FIPAException fe) { 
   fe.printStackTrace(); 
  }  
   
 } 
  
 private class HandleStorageIdRequest extends SimpleBehaviour { 
  boolean done = false; 
   
  HandleStorageIdRequest(Agent agent){ 
   super(agent); 
  } 
   
  public void action() { 
   ACLMessage  msg = receive(); 
    
   if(msg != null){ 
    ACLMessage reply = msg.createReply(); 
    long current = System.currentTimeMillis(); 
    Long id = Long.valueOf(current); 
    try { 
     reply.setContentObject(id); 
    } catch (IOException e) { 
     e.printStackTrace(); 
    } 
    send(reply); 
   } 
  } 
 
  public boolean done() { 
   return false; 
  } 
   
   
 } 
  
 private class HandleStorageRequest extends SimpleAchieveREResponder{ 
 
  private int flag = 0; 
     
 128 
   
  public HandleStorageRequest(Agent agent) { 
   super(agent, MessageTemplate.and( 
    
 MessageTemplate.MatchLanguage("JavaSerialization"), 
    
 MessageTemplate.MatchProtocol(FIPA_REQUEST))); 
  } 
  
  public ACLMessage prepareResultNotification(ACLMessage request, 
ACLMessage response) { 
      // Prepare a dummy ACLMessage used to create the content of all reply 
messages 
  ACLMessage reply = request.createReply(); 
     Object obj = null; 
     byte[] serialized = null; 
  String name = ""; 
     try { 
      serialized = request.getByteSequenceContent(); 
   obj = request.getContentObject(); 
   name = request.getSender().getName(); 
  } catch (UnreadableException e) { 
   e.printStackTrace(); 
  } 
   
  if(obj instanceof Agent && flag == 0){ 
   try{ 
 
//    convert serialized object to input stream 
    ByteArrayInputStream baiStream = new 
ByteArrayInputStream( serialized );  
              
    java.util.Date today = new java.util.Date(); 
    java.sql.Date sqlToday = new 
java.sql.Date(today.getTime()); 
     
    PreparedStatement pStat = c.prepareStatement("INSERT 
INTO agents VALUES(?,?,?);"); 
     
    pStat.setString(1, name); 
    pStat.setDate(2, sqlToday); 
    pStat.setBinaryStream(3, baiStream, serialized.length); 
    int success = pStat.executeUpdate(); 
    if(success < 1){ 
     System.err.println("Something is WRONG when 
exec of Update.."); 
     
 129 
    } 
    else{ 
     System.out.println("ROWS AFFECTED : " + 
success); 
     flag = 1; 
    } 
 
    System.out.println(getLocalName()+ " read Java Object " + 
obj.getClass().getName() + obj.toString());     
    pStat.close(); 
   } 
   catch (SQLException e) { 
    e.printStackTrace(); 
   } 
   catch (NullPointerException e){} 
  } 
  else{ 
   reply.setPerformative(ACLMessage.FAILURE); 
  } 
   
     return reply; 
  } 
   
  protected ACLMessage prepareResponse(ACLMessage msg){ 
   ACLMessage reply = msg.createReply(); 
   reply.setPerformative(ACLMessage.AGREE); 
 
   return reply;    
  } 
   
 } 
 
 class HandleRetrievalRequestsBehaviour extends SimpleAchieveREResponder{ 
   
  public HandleRetrievalRequestsBehaviour(Agent agent){ 
   super(agent, 
MessageTemplate.MatchConversationId("agentRetrieval")); 
  } 
   
  protected ACLMessage prepareResponse(ACLMessage request) throws 
NotUnderstoodException, RefuseException { 
   System.out.println("PREPARING RESULTS......"); 
   ACLMessage reply = null; 
   Location homeNode = null; 
   String agent_id = ""; 
   boolean finished = false; 
     
 130 
    
   try{     
    reply =  request.createReply(); 
    Object tmp = request.getContentObject(); 
 
   if(tmp instanceof Vector){ 
    Vector tmpVec = (Vector)tmp; 
    agent_id = (String) tmpVec.get(0); 
    homeNode = (Location) tmpVec.get(1); 
   } 
    
   if(finished == false){ 
   Statement s = c.createStatement(); 
   ResultSet res = s.executeQuery("SELECT * FROM agents 
WHERE agent_id = '" + agent_id + "'"); 
    
   if(res.next()){ 
    System.out.println(str + "The result was name " + 
res.getString("agent_id") + " date: " + res.getDate("date_added") + "test was: " + 
res.getBinaryStream("agent").toString()); 
    ObjectInputStream in = new 
ObjectInputStream(res.getBinaryStream("agent")); 
    Object obj = in.readObject(); 
    System.out.println("I read a " + obj.getClass() + "; 
expecting a BuyerAgent "); 
    if(obj instanceof BuyerAgent){ 
     BuyerAgent b = (BuyerAgent) obj; 
     System.out.println("TTEST IS " + 
b.getAID().toString() /*+ ((BuyerAgent) obj).getSecret()*/); 
     Vector results = b.afterLoad(); 
     reply.setPerformative(ACLMessage.INFORM); 
     reply.setContentObject(results); 
     send(reply); 
    }  
   } 
   s.close(); 
   finished = true; 
   } 
   } 
   catch (IOException ex) { 
    ex.printStackTrace(); 
   } 
   catch (ClassNotFoundException e) { 
    e.printStackTrace(); 
   } catch (SQLException e) { 
    e.printStackTrace(); 
     
 131 
   } catch (UnreadableException e) { 
    e.printStackTrace(); 
   }  
       
   return reply; 
  } 
 } 
private Agent retrieveAgent(String agent_name){  
 try{ 
   
 Statement s = c.createStatement(); 
 ResultSet res = s.executeQuery("SELECT * FROM agents WHERE name = " + 
agent_name); 
  
 if(res.next()){ 
  System.out.println(str + "The result wass date: " + 
res.getDate("date_added") + "test was: " + res.getBinaryStream("agent").toString()); 
  ObjectInputStream in = new 
ObjectInputStream(res.getBinaryStream("agent")); 
  Object obj = in.readObject(); 
  System.out.println("I read a " + obj.getClass() + "; expecting a 
BuyerAgent"); 
  }  
 } 
 s.close(); 
 } 
 catch (IOException ex) { 
  ex.printStackTrace(); 
 } 
 catch (ClassNotFoundException e) { 
  e.printStackTrace(); 
 } catch (SQLException e) { 
  e.printStackTrace(); 
 } 
 return null; 
} 
 protected void tooltakeDown(){ 
  try { 
   c.close(); 
  } catch (SQLException e) { 
   e.printStackTrace(); 
  } 
 } 
} 
     
 132 
Itinerary 
 
package trader; 
 
import jade.core.AID; 
import jade.core.Location; 
 
import java.io.Serializable; 
import java.util.ArrayList; 
import java.util.Iterator; 
 
public class Intinerary implements Serializable{ 
  
 private ArrayList availableLocations = new ArrayList(); 
 private ArrayList visitedLocations = new ArrayList(); 
 private Location homeNode; 
 private Location storageNode; 
  
 public Intinerary(Location homeNode){ 
  this.homeNode = homeNode; 
 } 
  
 // Constructor for setting Location of storage directly 
 public Intinerary(Location homeNode, Location storageNode){ 
  this.homeNode = homeNode; 
  this.storageNode = storageNode; 
 } 
  
 public void addLocation(Location loc, AID agentToMeet){ 
  Object[] tmp = {loc, agentToMeet}; 
  availableLocations.add(tmp); 
 } 
   
 public ArrayList getAvailableLocations(){ 
  return availableLocations;   
 } 
  
 public Object[] getNextLocation() {    
  Object [] next = null; 
  Iterator iter = availableLocations.iterator(); 
  if(iter.hasNext()){  
   next = (Object[])iter.next(); 
   visitedLocations.add(next); 
   iter.remove(); 
  } 
  return next; 
 }   
  
 public void setVisitedLocation(Location loc){ 
  Location tmp = null; 
  for (Iterator iter = availableLocations.iterator() ; iter.hasNext(); ) { 
   tmp = (Location)iter.next(); 
   if(tmp.equals(loc)){ 
    visitedLocations.add(loc); 
    iter.remove(); 
     
 133 
   } 
  } 
 } 
  
 public Location getHomeLocation(){ 
  return homeNode; 
 } 
  
 public void setHomeLocation(Location homeNode){ 
  this.homeNode = homeNode;   
 } 
  
 public Location getStorageLocation(){ 
  return storageNode; 
 } 
  
 public void setStorageLocation(Location store){ 
  storageNode = store; 
 } 
  
} 
 
 
 
